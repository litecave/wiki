{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Free60.org Wiki archive Welcome to the archive of Free60.org Mediawiki. To submit changes: 1. Fork the repo 2. Make changes 3. Send a Pull Request Categories Xbox360_Hardware Xbox360 System Software Xbox360_Homebrew_Software Xbox360_Linux Xbox360_Development Support Pages with missing images Template documentation ToDo TODO Index Generic Hardware Software Attack 8051 8052 1bl Code Boot Process CPU 360FlashTool Contribute Case 849x System Update Error Codes Chatpad Bootloader FAQ DVD Drive CB Code Dump Flash the NAND Toolchain Ethernet Console Security Certificate Falcon Cross Compiler Finding the right timing Dashboard Flash Debian-etch Fusesets Debian-lenny GamePad Debian-squeeze Gamepad Keyboard Dumpana GPU HDD Emulators Harddrive FATX Headset Motherboard Flash Filesystem Jasper GDFX Level Shifter GPD Free60 Git Repository Generic Xbox 360 File Container Genesis Plus Help Histogram Homebrew Games Homebrew Launchers Homebrew Repository HvxExpansionInstall HvxKeysExecute HvxPostOutput Hypervisor Hypervisor (Old Notes) IRC Kernel Kernel Exports King Kong Hack Launchers Lflash LibHomebrew LibXenon LibXenon Examples Lib Homebrew Libraries Libxenonexamples Links Linux Bootloader Linux Distributions Linux Distros Linux Kernel Linux Kernel Development List of PC utilities List of Unix Distributions List of all homebrew List of development tools List of homebrew applications List of homebrew emulators List of homebrew games List of homebrew loaders List of system tools LiveCD Mainboard Media Remote Memory Memory MAP Memory Unit Modesetting Mupen64-360 NAND NAND: Bad Blocks NANDPro NAND File System NAND Reading NFS Root NandCompare Northbridge Old Main Page Opus Other OS Loader PCSXR-Xenon PC Software PEC POST Pin Headers Play and Charge Kit Pong Pre-release differences Profile: Account R6T3 README RF Module Rawflash Reading Out nand Reset Glitch Hack Reversing the bootloaders Run Code SDLQuake SFCX SMBus Controller SMC SMC Command 0x01 SMC Command 0x82 SMC Hack SMS Plus SPA SPI SPI Programmer STFS Sandbox Secure Transacted File System Sega Genesis Plus GX Sega Master System Plus Serial Console Shadowboot Snes9x-Gx Southbridge Starting Homebrew Development Stereo DAC System Calls Tanks 360 Timing Attack Toolchain Trinity UART USB Ubuntu Ubuntu11.10 Ubuntu7.10 Utilities Valhalla Webcam Wifi Adapter XCP XConfig XContent XDBF XDK Kernel XEX XMENU XMPlayer XTAF Xbox 360 Motherboards Xbox Revision Identification Xbox Revisions Xbox Software Xbox System Software XeLL XeLL Reloaded XeLLous Xenon Xenon (CPU) Xenon (Motherboard) Xenon Toolchain Xenos Xenos (GPU) Xenos Framebuffer ZLX Browser Zephyr","title":"Home"},{"location":"#free60org-wiki-archive","text":"Welcome to the archive of Free60.org Mediawiki. To submit changes: 1. Fork the repo 2. Make changes 3. Send a Pull Request","title":"Free60.org Wiki archive"},{"location":"#categories","text":"Xbox360_Hardware Xbox360 System Software Xbox360_Homebrew_Software Xbox360_Linux Xbox360_Development Support Pages with missing images Template documentation","title":"Categories"},{"location":"#todo","text":"TODO","title":"ToDo"},{"location":"#index","text":"Generic Hardware Software Attack 8051 8052 1bl Code Boot Process CPU 360FlashTool Contribute Case 849x System Update Error Codes Chatpad Bootloader FAQ DVD Drive CB Code Dump Flash the NAND Toolchain Ethernet Console Security Certificate Falcon Cross Compiler Finding the right timing Dashboard Flash Debian-etch Fusesets Debian-lenny GamePad Debian-squeeze Gamepad Keyboard Dumpana GPU HDD Emulators Harddrive FATX Headset Motherboard Flash Filesystem Jasper GDFX Level Shifter GPD Free60 Git Repository Generic Xbox 360 File Container Genesis Plus Help Histogram Homebrew Games Homebrew Launchers Homebrew Repository HvxExpansionInstall HvxKeysExecute HvxPostOutput Hypervisor Hypervisor (Old Notes) IRC Kernel Kernel Exports King Kong Hack Launchers Lflash LibHomebrew LibXenon LibXenon Examples Lib Homebrew Libraries Libxenonexamples Links Linux Bootloader Linux Distributions Linux Distros Linux Kernel Linux Kernel Development List of PC utilities List of Unix Distributions List of all homebrew List of development tools List of homebrew applications List of homebrew emulators List of homebrew games List of homebrew loaders List of system tools LiveCD Mainboard Media Remote Memory Memory MAP Memory Unit Modesetting Mupen64-360 NAND NAND: Bad Blocks NANDPro NAND File System NAND Reading NFS Root NandCompare Northbridge Old Main Page Opus Other OS Loader PCSXR-Xenon PC Software PEC POST Pin Headers Play and Charge Kit Pong Pre-release differences Profile: Account R6T3 README RF Module Rawflash Reading Out nand Reset Glitch Hack Reversing the bootloaders Run Code SDLQuake SFCX SMBus Controller SMC SMC Command 0x01 SMC Command 0x82 SMC Hack SMS Plus SPA SPI SPI Programmer STFS Sandbox Secure Transacted File System Sega Genesis Plus GX Sega Master System Plus Serial Console Shadowboot Snes9x-Gx Southbridge Starting Homebrew Development Stereo DAC System Calls Tanks 360 Timing Attack Toolchain Trinity UART USB Ubuntu Ubuntu11.10 Ubuntu7.10 Utilities Valhalla Webcam Wifi Adapter XCP XConfig XContent XDBF XDK Kernel XEX XMENU XMPlayer XTAF Xbox 360 Motherboards Xbox Revision Identification Xbox Revisions Xbox Software Xbox System Software XeLL XeLL Reloaded XeLLous Xenon Xenon (CPU) Xenon (Motherboard) Xenon Toolchain Xenos Xenos (GPU) Xenos Framebuffer ZLX Browser Zephyr","title":"Index"},{"location":"%21TODO/","text":"TODO - Broken links, comments etc. Attack.md 109 perhabs link to early version of Boot_Process.md Attack.md 242-252 things from the website Debian-etch.md 24 newer version? Debian-etch.md 47 no archive in the waybackmachine, other source? Debian-etch.md 85 newer version? other source than waybackmachine? Debian-etch.md 88 newer version? other source than waybackmachine? Debian-lenny.md 17 newer version? other source than waybackmachine? Debian-lenny.md 21 newer version? other source than waybackmachine? Debian-lenny.md 49 version not available Debian-lenny.md 56 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server) Debian-lenny.md 86 no archive in the waybackmachine, other source? Debian-lenny.md 89 newer version? other source than waybackmachine? Debian-squeeze.md 62 version not available Debian-squeeze.md 68 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server) EEProm.md 154 i cant load the page; repleace with waybackmachine? Error_Codes.md 2 No Picture in ./images Genesis_Plus.md 3 no archive in the waybackmachine, other source? HDD.md 105 no archive in the waybackmachine, other source? HDD.md 111 i cant load the page; repleace with waybackmachine? HDD.md 115 i cant load the page; repleace with waybackmachine? Help.md 18 below Help.md 21 broken category link Help.md 24 free60.org/old not available King_Kong_Hack.md 41 no archive in the waybackmachine, other source? King_Kong_Hack.md 77 no archive in the waybackmachine, other source? LibXenon_Examples.md 1 below LibXenon_Examples.md 7 below LibXenon_Examples.md 12 removed User link (User:cpasjuste) LibXenon_Examples.md 4 below LibXenon_Examples.md 14 not in the file.libxenon.org repository LibXenon_Examples.md 8-9 no archive in the waybackmachine, other source? Links.md 4 perhaps not safe Links.md 20 no archive in the waybackmachine, other source? Links.md 26 not all pictures (archive.org) Linux_Kernel.md 63 file missing, but folder is there? List_of_development_tools.md 32-34 repository missing? Memory_Unit.md 69 something is broken (redirect to start page of waybackmachine) Motherboard.md 34 lost reference (wikipedia) NAND_Bad_Blocks.md 280 no useable archive in the waybackmachine, other source? NAND_Reading.md 113 no archive in the waybackmachine, other source? NAND_Reading.md 739 no archive in the waybackmachine, other source? NAND.md 111 below NAND.md 113 below NAND.md 117 no archive in the waybackmachine, other source? NAND.md 115 Waybackmachine infinte loop?!? NAND.md 210 no archive in the waybackmachine, other source? Old_Main_Page.md 49 at the end: Press_Release_2007-05-08 PC_Software.md 11 newer version? PC_Software.md 35 newer version? PC_Software.md 44 newer version? R6T3.md 72 no archive in the waybackmachine, other source? Sega_Master_System_Plus.md 3 no archive in the waybackmachine, other source? SMBus_Controller.md 118 i cant load the page; repleace with waybackmachine? SMC_Hack.md 19 dont know where to link SMC_Hack.md 78 dont know where to link STFS.md 504 not avaiable (perhaps waybackmachine) STFS.md 512 i cant load the page; repleace with waybackmachine? Timing_Attack.md 229 below Timing_Attack.md 233 below Timing_Attack.md 238 below Timing_Attack.md 241 below Timing_Attack.md 246 below Timing_Attack.md 255 \"anchor\" broken Ubuntu11.10.md 62 not available Ubuntu11.10.md 68 below Ubuntu11.10.md 84 below Ubuntu11.10.md 85 below Ubuntu11.10.md 87 below Ubuntu11.10.md 88 below Ubuntu11.10.md 89 below Ubuntu11.10.md 91-94 dont think the command will work Utilities.md 9 below Utilities.md 18 dead link Wifi_Adapter.md 3 below Wifi_Adapter.md 20 below Wifi_Adapter.md 29 missing pictures from free60 Wifi_Adapter.md 65 no archive in the waybackmachine, other source? Xbox_Revision_Identification.md 2612 i cant load the page; repleace with waybackmachine? Xenon_(CPU).md 63 http://www.ibm.com/developerworks/library/pa-soc1/ and other ibm links should be repleaced with newer version Xenon_Toolchain.md 106 Use of updated version? XEX.md 230 no archive in the waybackmachine, other source? 849x_System_Update.md 10-12 update free60 links?","title":"ToDo"},{"location":"%21TODO/#todo-broken-links-comments-etc","text":"Attack.md 109 perhabs link to early version of Boot_Process.md Attack.md 242-252 things from the website Debian-etch.md 24 newer version? Debian-etch.md 47 no archive in the waybackmachine, other source? Debian-etch.md 85 newer version? other source than waybackmachine? Debian-etch.md 88 newer version? other source than waybackmachine? Debian-lenny.md 17 newer version? other source than waybackmachine? Debian-lenny.md 21 newer version? other source than waybackmachine? Debian-lenny.md 49 version not available Debian-lenny.md 56 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server) Debian-lenny.md 86 no archive in the waybackmachine, other source? Debian-lenny.md 89 newer version? other source than waybackmachine? Debian-squeeze.md 62 version not available Debian-squeeze.md 68 change to mirrors.kernel.org/debian/ ; dont think the command will work (missing files at the server) EEProm.md 154 i cant load the page; repleace with waybackmachine? Error_Codes.md 2 No Picture in ./images Genesis_Plus.md 3 no archive in the waybackmachine, other source? HDD.md 105 no archive in the waybackmachine, other source? HDD.md 111 i cant load the page; repleace with waybackmachine? HDD.md 115 i cant load the page; repleace with waybackmachine? Help.md 18 below Help.md 21 broken category link Help.md 24 free60.org/old not available King_Kong_Hack.md 41 no archive in the waybackmachine, other source? King_Kong_Hack.md 77 no archive in the waybackmachine, other source? LibXenon_Examples.md 1 below LibXenon_Examples.md 7 below LibXenon_Examples.md 12 removed User link (User:cpasjuste) LibXenon_Examples.md 4 below LibXenon_Examples.md 14 not in the file.libxenon.org repository LibXenon_Examples.md 8-9 no archive in the waybackmachine, other source? Links.md 4 perhaps not safe Links.md 20 no archive in the waybackmachine, other source? Links.md 26 not all pictures (archive.org) Linux_Kernel.md 63 file missing, but folder is there? List_of_development_tools.md 32-34 repository missing? Memory_Unit.md 69 something is broken (redirect to start page of waybackmachine) Motherboard.md 34 lost reference (wikipedia) NAND_Bad_Blocks.md 280 no useable archive in the waybackmachine, other source? NAND_Reading.md 113 no archive in the waybackmachine, other source? NAND_Reading.md 739 no archive in the waybackmachine, other source? NAND.md 111 below NAND.md 113 below NAND.md 117 no archive in the waybackmachine, other source? NAND.md 115 Waybackmachine infinte loop?!? NAND.md 210 no archive in the waybackmachine, other source? Old_Main_Page.md 49 at the end: Press_Release_2007-05-08 PC_Software.md 11 newer version? PC_Software.md 35 newer version? PC_Software.md 44 newer version? R6T3.md 72 no archive in the waybackmachine, other source? Sega_Master_System_Plus.md 3 no archive in the waybackmachine, other source? SMBus_Controller.md 118 i cant load the page; repleace with waybackmachine? SMC_Hack.md 19 dont know where to link SMC_Hack.md 78 dont know where to link STFS.md 504 not avaiable (perhaps waybackmachine) STFS.md 512 i cant load the page; repleace with waybackmachine? Timing_Attack.md 229 below Timing_Attack.md 233 below Timing_Attack.md 238 below Timing_Attack.md 241 below Timing_Attack.md 246 below Timing_Attack.md 255 \"anchor\" broken Ubuntu11.10.md 62 not available Ubuntu11.10.md 68 below Ubuntu11.10.md 84 below Ubuntu11.10.md 85 below Ubuntu11.10.md 87 below Ubuntu11.10.md 88 below Ubuntu11.10.md 89 below Ubuntu11.10.md 91-94 dont think the command will work Utilities.md 9 below Utilities.md 18 dead link Wifi_Adapter.md 3 below Wifi_Adapter.md 20 below Wifi_Adapter.md 29 missing pictures from free60 Wifi_Adapter.md 65 no archive in the waybackmachine, other source? Xbox_Revision_Identification.md 2612 i cant load the page; repleace with waybackmachine? Xenon_(CPU).md 63 http://www.ibm.com/developerworks/library/pa-soc1/ and other ibm links should be repleaced with newer version Xenon_Toolchain.md 106 Use of updated version? XEX.md 230 no archive in the waybackmachine, other source? 849x_System_Update.md 10-12 update free60 links?","title":"TODO - Broken links, comments etc."},{"location":"1bl_Code/","text":"1BL - Pseudocode Have not reversed all of the hardware error subroutines. // version 0x583 #define STACK 0x800002000001F700 // r1 #define TOCP 0x8000020000000000 // r2 #define SRAM 0x8000020000010000 #define NAND 0x80000200C8000000 #define PCI 0x80000200D0000000 #define _HW_REG_POST 0x8000020000061010 #define _HW_REG_61008 0x8000020000061008 #define HW_REG_POST (*((volatile QWORD *)_HW_REG_POST)) #define HW_REG_61008 (*((volatile QWORD *)_HW_REG_61008)) #define BITMASK32(n) ((~0ul) >> 32-bits) #define BITMASK32_L(n) ~((~0ul) >> bits) // left justified bitmask, assumes the hardware makes bits shifted in 0 #define BITMASK64(n) ((~0ull) >> 64-bits) #define BITMASK64_L(n) ~((~0ull) >> bits) // left justified bitmask, assumes the hardware makes bits shifted in 0 #define ROTL32(data, bits) ((data << bits) | data >> 32-bits) & ~0ul #define ROTR32(data, bits) ((data >> bits) | data << 32-bits) & ~0ul #define ROTL64(data, bits) ((data << bits) | data >> 64-bits) & ~0ull #define ROTR64(data, bits) ((data >> bits) | data << 64-bits) & ~0ull BYTE Salt[0xB] = <redacted>; BYTE BLKey[0x10] = { <redacted> }; XECRYPT_RSAPUB_2048 xRSA; xRSA = <redacted> typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 QWORD Pad[4]; // 0x20 : 0x20 XECRYPT_SIG Sig; // 0x40 : 0x100 // Header: 0x140 }BLHeader, *PBLHeader; // write to the post bus void POST(QWORD postCode) { HW_REG_POST = (postCode << 56); } // outputs a given byte, then the same byte OR'ed with 0x80 // probably for their internal post sniffer void POST_DATA(BYTE outPost) { POST(outPost); POST(outPost | 0x80); } // outputs a given amount of bytes from a given address in high-low format void POST_ADDRESS(QWORD pqwAddy, DWORD cbAddy) { for(int i = 0;i < cbAddy;i++) { BYTE bData = *(BYTE*)pqwAddy+i; POST(data >> 4); // output high POST(data & 0xF); // output low } } void PanicGen() { while(1) continue; } void Panic(QWORD postCode) { POST(postCode); PanicGen(); } QWORD ReadHighestByte(QWORD Address) { return ((*(QWORD*)Address) >> 56); } DWORD sub_36A8() { DWORD ret = ReadHighestByte(HW_REG_61008); if((ret & 0x80) != 0) ret = (~ret) & 0xFF; return = ret & 0xF8; } // rough translation for the cntlzw instruction DWORD countLeadingZeros(DWORD data) { DWORD count = 0; for(int i = 0;i < 31;i++) { if(data >> 31-i) return count; count++; } } /* Basically this happens when its detected that the SOC doesn't carry correct values, it goes into a loop and starts outputting data from a certain SOC register (0x8000020000061008) - possibly error register? It doesn't repeat it's output unless the SOC register changes */ void HARDWARE_ERROR_PRINT(DWORD dwUnk1) { while(1) { BYTE bUnk1_p = ROTL32(dwUnk1, 3) & 0x1F; POST_DATA(bUnk1_p | 0x60); BYTE tmp = 0; BYTE bUnk1 = dwUnk1 & FF; if(bUnk1 == 0x78) tmp = 1; else { if(bUnk1 == 0) sub_3878(tmp); else if(bUnk1 == 8) sub_38B8(tmp); else if(bUnk1 == 0x10) sub_3AE0(tmp); else if(bUnk1 == 0x18) sub_3B30(tmp); else if(bUnk1 == 0x20) sub_3BB0(tmp); else if(bUnk1 == 0x28) sub_39C8(tmp); else if(bUnk1 == 0x30) sub_3F88(tmp, PCI + 0x8000); else if(bUnk1 == 0x38) sub_3C78(tmp); else if(bUnk1 == 0x40) sub_3D08(tmp); else if(bUnk1 == 0x48) sub_3DE0(tmp); else if(bUnk1 == 0x50) POST_ADDRESS(TOCP+2, 2); else if(bUnk1 == 0x58) sub_3F88(tmp, PCI); else if(bUnk1 == 0x60) sub_4008(tmp); tmp = 0; } POST_DATA(bUnk1_p | 0x70); DWORD r30 = (countLeadingZeros(bUnk1-0x50) >> 27) & 1; do { for(int i = 1;i < 6;i++) { DWORD dwUnk2 = sub_36A8(); if(dwUnk1 & 0xFF != dwUnk2 & 0xFF) { dwUnk1 = dwUnk2; i = 0; } } } while(((countLeadingZeros((dwUnk1 & 0xFF) - 0x50) >> 27) & 1) == r30); } } bool CB_VerifyOffset(DWORD offset, DWORD arg2) { if(offset != (offset + 0xF) & 0xFFFFFFF0) return false; if(offset - 0x80 > 0x7FFFF7F) return false; if((arg2 + 0xF) & 0xFFFFFFF0 >= offset - 0x8000000) return false; return true; } // Copies by 0x10 byte blocks // cBlocks: how many 0x10 byte blocks to copy void CB_Copy(QWORD dest, QWORD src, DWORD cBlocks) { for(int i = 0; i < cBlocks; i++) { *(QWORD*)dest+(i*0x10) = *(QWORD*)src+(i*0x10); *(QWORD*)dest+(i*0x10)+8 = *(QWORD*)src+(i*0x10)+8; } } void CB_Jump(QWORD address, QWORD arg2) { // grabs data from the CB before nulling the area QWORD r27 = *(QWORD*)SRAM+0x20; QWORD r28 = *(QWORD*)SRAM+0x28; QWORD r29 = *(QWORD*)SRAM+0x30; QWORD r30 = *(QWORD*)SRAM+0x38; // nulls 0x20-0x140(?) QWORD tmp = SRAM+0x20; for(int i = 0; i < 0x12; i++) { *tmp+(i*0x10) = 0ULL; *tmp+(i*0x10)+8 = 0ULL; } // check the size tmp = (((*(DWORD*)SRAM+0xC) + 0xF) & 0xFFFFFFF0); if(tmp >= 0x10000) Panic(0x98); // nulls the area after the CB QWORD addy = tmp + SRAM; for(int i = 0; i < (tmp - 0x10000) >> 4; i++) { *addy+(i*0x10) = 0ULL; *addy+(i*0x10)+8 = 0ULL; } // sets up tlb page // sets registers r0-r26 to 0 // jump to CB goto (address & 0xFFFF) + 0x2000000; return; } void CB_Load() { POST(0x11); FSB1(); // sub_3450 POST(0x12); FSB2(); // sub_34D0 POST(0x13); FSB3(); // sub_35A8 POST(0x14); FSB4(); // sub_3658 POST(0x15); DWORD cbOffset = *(DWORD*)NAND+8; // r25 if(!CB_VerifyOffset(cbOffset, 0x10)) Panic(0x94); POST(0x16); QWORD cbNAddy = NAND+cbOffset; // r26 CB_Copy(SRAM, cbNAddy, 1); POST(0x17); PBLHeader cbHeader = (PBLHeader)SRAM; if((cbHeader->Size - 0x264) > 0xBD9C || (cbHeader->Magic & 0xFFF) != 0x342 || (cbHeader->EntryPoint & 0x3) || (cbHeader->EntryPoint) < 0x264 // on slim its < 0x3B8 || (cbHeader->Size & 0xFFFFFFFC) >= (cbHeader->EntryPoint & 0x3) // doesn't make sense, check later offset 0x4340 - On slim it makes sense: if(entrypoint >= size & 0xFFFFFFFC) panic || !CB_VerifyOffset(cbOffset, cbHeader->Size)) Panic(0x95); POST(0x18); QWORD tmp = ((cbHeader->Size + 0xF) & 0xFFFFFFF0); CB_Copy(SRAM+0x10, cbNAddy+0x10, (tmp - 0x10) >> 4); POST(0x19); // overwrites the old key with the new one XeCryptHmacSha(BLKey, 0x10, &cbHeader->key, 0x10, 0, 0, 0, 0, &cbHeader->key, tmp); POST(0x1A); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, cbHeader->key, 0x10); // key = HmacSha(1BLKey, cbKey, 0x10) POST(0x1B); XeCryptRc4Ecb(&rc4, SRAM+0x20, tmp - 0x20); // Decrypts everything after the header POST(0x1C); BYTE Hash[0x14] = { 0 }; XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tmp - 0x140, Hash, 0x14); // hashes everything after the sig POST(0x1D); if(XeCryptBnQwBeSigDifference(&cbHeader->Sig, Hash, Salt, &xRSA)) // checks sig against hash with public rsa key Panic(0x96); POST(0x1E); CB_Jump(cbHeader->EntryPoint, tmp+cbOffset); // sets up tbl page and loads some registers before jumping to cb return; } void BL_1() { // thread check? POST(0x10); // entered 1bl // null the sram area for(int i = 0; i < 0x1000; i++) { *(QWORD*)SRAM+(i*0x10) = 0ULL; *(QWORD*)SRAM+((i*0x10)+8) = 0ULL; } DWORD tmp = sub_36A8(); if((tmp & 0xFF) == 0x50) HARDWARE_ERROR_PRINT(tmp); // look into later // load and execute the CB CB_Load(); // CB_Load shouldn't return... PanicGen(); return; }","title":"1BL - Pseudocode"},{"location":"1bl_Code/#1bl-pseudocode","text":"Have not reversed all of the hardware error subroutines. // version 0x583 #define STACK 0x800002000001F700 // r1 #define TOCP 0x8000020000000000 // r2 #define SRAM 0x8000020000010000 #define NAND 0x80000200C8000000 #define PCI 0x80000200D0000000 #define _HW_REG_POST 0x8000020000061010 #define _HW_REG_61008 0x8000020000061008 #define HW_REG_POST (*((volatile QWORD *)_HW_REG_POST)) #define HW_REG_61008 (*((volatile QWORD *)_HW_REG_61008)) #define BITMASK32(n) ((~0ul) >> 32-bits) #define BITMASK32_L(n) ~((~0ul) >> bits) // left justified bitmask, assumes the hardware makes bits shifted in 0 #define BITMASK64(n) ((~0ull) >> 64-bits) #define BITMASK64_L(n) ~((~0ull) >> bits) // left justified bitmask, assumes the hardware makes bits shifted in 0 #define ROTL32(data, bits) ((data << bits) | data >> 32-bits) & ~0ul #define ROTR32(data, bits) ((data >> bits) | data << 32-bits) & ~0ul #define ROTL64(data, bits) ((data << bits) | data >> 64-bits) & ~0ull #define ROTR64(data, bits) ((data >> bits) | data << 64-bits) & ~0ull BYTE Salt[0xB] = <redacted>; BYTE BLKey[0x10] = { <redacted> }; XECRYPT_RSAPUB_2048 xRSA; xRSA = <redacted> typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 QWORD Pad[4]; // 0x20 : 0x20 XECRYPT_SIG Sig; // 0x40 : 0x100 // Header: 0x140 }BLHeader, *PBLHeader; // write to the post bus void POST(QWORD postCode) { HW_REG_POST = (postCode << 56); } // outputs a given byte, then the same byte OR'ed with 0x80 // probably for their internal post sniffer void POST_DATA(BYTE outPost) { POST(outPost); POST(outPost | 0x80); } // outputs a given amount of bytes from a given address in high-low format void POST_ADDRESS(QWORD pqwAddy, DWORD cbAddy) { for(int i = 0;i < cbAddy;i++) { BYTE bData = *(BYTE*)pqwAddy+i; POST(data >> 4); // output high POST(data & 0xF); // output low } } void PanicGen() { while(1) continue; } void Panic(QWORD postCode) { POST(postCode); PanicGen(); } QWORD ReadHighestByte(QWORD Address) { return ((*(QWORD*)Address) >> 56); } DWORD sub_36A8() { DWORD ret = ReadHighestByte(HW_REG_61008); if((ret & 0x80) != 0) ret = (~ret) & 0xFF; return = ret & 0xF8; } // rough translation for the cntlzw instruction DWORD countLeadingZeros(DWORD data) { DWORD count = 0; for(int i = 0;i < 31;i++) { if(data >> 31-i) return count; count++; } } /* Basically this happens when its detected that the SOC doesn't carry correct values, it goes into a loop and starts outputting data from a certain SOC register (0x8000020000061008) - possibly error register? It doesn't repeat it's output unless the SOC register changes */ void HARDWARE_ERROR_PRINT(DWORD dwUnk1) { while(1) { BYTE bUnk1_p = ROTL32(dwUnk1, 3) & 0x1F; POST_DATA(bUnk1_p | 0x60); BYTE tmp = 0; BYTE bUnk1 = dwUnk1 & FF; if(bUnk1 == 0x78) tmp = 1; else { if(bUnk1 == 0) sub_3878(tmp); else if(bUnk1 == 8) sub_38B8(tmp); else if(bUnk1 == 0x10) sub_3AE0(tmp); else if(bUnk1 == 0x18) sub_3B30(tmp); else if(bUnk1 == 0x20) sub_3BB0(tmp); else if(bUnk1 == 0x28) sub_39C8(tmp); else if(bUnk1 == 0x30) sub_3F88(tmp, PCI + 0x8000); else if(bUnk1 == 0x38) sub_3C78(tmp); else if(bUnk1 == 0x40) sub_3D08(tmp); else if(bUnk1 == 0x48) sub_3DE0(tmp); else if(bUnk1 == 0x50) POST_ADDRESS(TOCP+2, 2); else if(bUnk1 == 0x58) sub_3F88(tmp, PCI); else if(bUnk1 == 0x60) sub_4008(tmp); tmp = 0; } POST_DATA(bUnk1_p | 0x70); DWORD r30 = (countLeadingZeros(bUnk1-0x50) >> 27) & 1; do { for(int i = 1;i < 6;i++) { DWORD dwUnk2 = sub_36A8(); if(dwUnk1 & 0xFF != dwUnk2 & 0xFF) { dwUnk1 = dwUnk2; i = 0; } } } while(((countLeadingZeros((dwUnk1 & 0xFF) - 0x50) >> 27) & 1) == r30); } } bool CB_VerifyOffset(DWORD offset, DWORD arg2) { if(offset != (offset + 0xF) & 0xFFFFFFF0) return false; if(offset - 0x80 > 0x7FFFF7F) return false; if((arg2 + 0xF) & 0xFFFFFFF0 >= offset - 0x8000000) return false; return true; } // Copies by 0x10 byte blocks // cBlocks: how many 0x10 byte blocks to copy void CB_Copy(QWORD dest, QWORD src, DWORD cBlocks) { for(int i = 0; i < cBlocks; i++) { *(QWORD*)dest+(i*0x10) = *(QWORD*)src+(i*0x10); *(QWORD*)dest+(i*0x10)+8 = *(QWORD*)src+(i*0x10)+8; } } void CB_Jump(QWORD address, QWORD arg2) { // grabs data from the CB before nulling the area QWORD r27 = *(QWORD*)SRAM+0x20; QWORD r28 = *(QWORD*)SRAM+0x28; QWORD r29 = *(QWORD*)SRAM+0x30; QWORD r30 = *(QWORD*)SRAM+0x38; // nulls 0x20-0x140(?) QWORD tmp = SRAM+0x20; for(int i = 0; i < 0x12; i++) { *tmp+(i*0x10) = 0ULL; *tmp+(i*0x10)+8 = 0ULL; } // check the size tmp = (((*(DWORD*)SRAM+0xC) + 0xF) & 0xFFFFFFF0); if(tmp >= 0x10000) Panic(0x98); // nulls the area after the CB QWORD addy = tmp + SRAM; for(int i = 0; i < (tmp - 0x10000) >> 4; i++) { *addy+(i*0x10) = 0ULL; *addy+(i*0x10)+8 = 0ULL; } // sets up tlb page // sets registers r0-r26 to 0 // jump to CB goto (address & 0xFFFF) + 0x2000000; return; } void CB_Load() { POST(0x11); FSB1(); // sub_3450 POST(0x12); FSB2(); // sub_34D0 POST(0x13); FSB3(); // sub_35A8 POST(0x14); FSB4(); // sub_3658 POST(0x15); DWORD cbOffset = *(DWORD*)NAND+8; // r25 if(!CB_VerifyOffset(cbOffset, 0x10)) Panic(0x94); POST(0x16); QWORD cbNAddy = NAND+cbOffset; // r26 CB_Copy(SRAM, cbNAddy, 1); POST(0x17); PBLHeader cbHeader = (PBLHeader)SRAM; if((cbHeader->Size - 0x264) > 0xBD9C || (cbHeader->Magic & 0xFFF) != 0x342 || (cbHeader->EntryPoint & 0x3) || (cbHeader->EntryPoint) < 0x264 // on slim its < 0x3B8 || (cbHeader->Size & 0xFFFFFFFC) >= (cbHeader->EntryPoint & 0x3) // doesn't make sense, check later offset 0x4340 - On slim it makes sense: if(entrypoint >= size & 0xFFFFFFFC) panic || !CB_VerifyOffset(cbOffset, cbHeader->Size)) Panic(0x95); POST(0x18); QWORD tmp = ((cbHeader->Size + 0xF) & 0xFFFFFFF0); CB_Copy(SRAM+0x10, cbNAddy+0x10, (tmp - 0x10) >> 4); POST(0x19); // overwrites the old key with the new one XeCryptHmacSha(BLKey, 0x10, &cbHeader->key, 0x10, 0, 0, 0, 0, &cbHeader->key, tmp); POST(0x1A); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, cbHeader->key, 0x10); // key = HmacSha(1BLKey, cbKey, 0x10) POST(0x1B); XeCryptRc4Ecb(&rc4, SRAM+0x20, tmp - 0x20); // Decrypts everything after the header POST(0x1C); BYTE Hash[0x14] = { 0 }; XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tmp - 0x140, Hash, 0x14); // hashes everything after the sig POST(0x1D); if(XeCryptBnQwBeSigDifference(&cbHeader->Sig, Hash, Salt, &xRSA)) // checks sig against hash with public rsa key Panic(0x96); POST(0x1E); CB_Jump(cbHeader->EntryPoint, tmp+cbOffset); // sets up tbl page and loads some registers before jumping to cb return; } void BL_1() { // thread check? POST(0x10); // entered 1bl // null the sram area for(int i = 0; i < 0x1000; i++) { *(QWORD*)SRAM+(i*0x10) = 0ULL; *(QWORD*)SRAM+((i*0x10)+8) = 0ULL; } DWORD tmp = sub_36A8(); if((tmp & 0xFF) == 0x50) HARDWARE_ERROR_PRINT(tmp); // look into later // load and execute the CB CB_Load(); // CB_Load shouldn't return... PanicGen(); return; }","title":"1BL - Pseudocode"},{"location":"360FlashTool/","text":"General Info NFO This tool will allow you to decrypt and extract various parts of a XBox360 flash dump. This tool will allow you to decrypt/encrypt and extract various parts of a XBOX360 flash dump and much more!! The flash is devided into 2 major parts 1) The Cx sections (CB,CD,CE & 0,1 or 2 CF & CG sections). CB, CPU bootup CD, unpacker for CE CE, contains the HV and Kernel in a .cab archive CF&CG are upgrade patches The tool will extract and decrypt sections CB, CD, CE. Additionally it will extract the .cab file in section CE. This can be opened with winrar and the content (xboxkrnl.img) extracted. The first 256K of xboxkrnl.img is the Hypervisor, the remainder is the 2.0.1888 Kernel. 2) The Flash File System. The tool expects a dump to contain the data (512 bytes) followed by the ECC (16 bytes). The ECC bytes are used to locate FS entries & identify the version. The tool consists of the exe and CxKey.txt. CxKey.txt is delivered with 32 '0's and they should be replaced with the key obtained from the 1BL. After all the fuss about AACS keys recently it seems risky to put the key in the exe Wink The Cx sections extracted from a dump will only decrypt correctly if the correct hex digits are inserted in the CxKey.txt file Version History ----------------- (v0.97) - Improved Nand Image detection - Added support for small XeLL Images (1,3MB) - Added ability to extract/import Slot0/Slot1 of ZeroPaired Images [XBR/freeBOOT/small XeLL] - Added ability to detect/convert raw Images (made with external programmer) to proper read format - Added ability to detect/convert Images without ECC data (made with Infectus device) - Added ability to extract/import new 'dae.bin' file [DvdAuthEx] - Added support for \"Alternate KeyVault\" decrypting/extracting - Added option to rebuild an opened Nand Image with different CPU-Key (Bootloaders/HV and generic files) - Added option in Settings to allow randomized encryption - Added option in Settings to allow cut short BigBlock Nand Images (64MB) - Fixed bug, regarding to saving config block checksum at wrong offset (in rare cases) - Changed, more accurate file extraction, automatically create subfolders - A lot of improvements and bug fixes (v0.95) - Added support for Trinity (XBOX360 Slim) dumps - Added ability to extract new 'fcrt.bin' file (encrypted only atm) - Added ability to display SMC Code Version - Added ability to view Advanced KeyVault Info - Fixed bug, patching KeyVault works again - Fixed bug, no longer crashes if Bootloaders are small in size (in rare cases) - Fixed bug, regarding to re-encrypting the SMC when the image is Zero Paired Image (v0.94) - Added static SMC Config editing [change CPU/GPU Fan Speed, Calibration Data, MAC Address, ....] (Thanks to q36) - Added support for single file \"config.bin\" editing/converting via Drag'n'Drop - Added ability to convert Xellous/NandPro raw SMC Config to different Styles and vice versa, e.g. for ibuild (Thanks to foouser) // FreeBOOT SmallBlock Style 16Kb // FreeBOOT BigBlock Style 128Kb // FlashTool SmallBlock Style 64Kb // FlashTool BigBlock Style 512Kb // BinCrypt2 Style 32Kb - Added checksum calculation for static SMC Config Block (Thanks to cory1492) - Added ability to extract/import encrypted KeyVault without known CPU Key [For Advanced Users] - Added ability to extract ibuild compatible files (..\\freeBOOT\\Data) - Added ability to open 70MB images (dumped with nandpro \"-r70\") - Added Option menu to enable/disable several features - Added Tooltips and Glass Effect - Bugfix in Multiple CPU Key handling - Fixed a lot small bugs (v0.93) - Fixed CPU-Key detection/correction in Multiple Keys section - Added ability to save KeyVault to file - Added ability to export a registry file from all added Keys - Added support to extract the Console Revocation List to a readable format 'dynamic_list.txt' - Improved state indication via Progress Bar - Minor changes (v0.92) - Added Support for Large Block nands (Jasper 256MB and 512MB nands) - Added Support for DevKit images + region for DevKit - Added Support for XBR/ZeroPaired images (still in development) - Added Single CPU Key or Multiple CPU Key handling (max. 25 Keys) - Added simple state indication via Progress Bar - Added ability to display Bad Blocks with true image offsets - Fixed bug in reading 7BL (CG) that have more blocks than specified in 6BL (CF) - Fixed bug in reading bootloaders that are smaller than 1 block - Fixed bug in kernel extract log with double slashes, more accurate extract log - Fixed multiple memory leaks - Fixed application can now start without Administrator Rights or UAC enabled - Updated config block logic with new info - Changed appearance for more read comfort (v0.91) 2009-12-06 * Added, support for Jasper 16MB nands, Block ID and Block Version in a different location. Uses offset 0x71 to determine metadata style, 0 = Original, 1 = New 16MB, 2 = Large Block. * Added ability to open ZeroPaired images, but WARNING this should be treated as read only. I suspect it will destroy the nand image if used to modify the file. (v0.90) - Bugfix, regarding to CD decryption. If you have a 1920+ CD version it doesn't decrypt CD properly. (by arnezami) - Bugfix, if a CPU key starts with 00 then the program crashed. (by arnezami) - Added, separate extract option for all important stuff (Security Data, Extended Key Vault, Console Revocation List, AP25 Challenge Database, Config Blocks) - Added, console ID generation method (source from xorloser) - Added, detection and correction of 1 wrong byte in the CPU-Key (by MODFREAKz) - Added, XValue decryption (by Redline99) - Added, support when raw extracting a file that it sets the Date/Time stamps as per original in Nand - Fixed, decryption for \"Console Revocation List\" (Thanks to xorloser and Redline99) - Fixed, \"Kernels not extracted (CPU Key required, CD Ver == 1920)\" - Changed, full KV.bin extract and patch - Added new OSIG types and unspoof possibility - Added/Changed new regions - 1BL, XEX1 and XEX2 are set as standard - Improved exception handling - Added Drag and Drop - Changed Icon - Code cleanup - Fixed a lot of other small bugs (v0.88B) - Fixed the Region bug (HK/Asia <=> EU and AUS) - Redesigned (XP style) (v0.88A) - A small upgrade allowing the secdata.bin file to be decrypted. (You need the XEX and CPU keys then extract the filesystem and you will get a decrypted secdata.bin as well as a bunch of other stuff.) (v0.88) - The flash image can now be patched with modified SMC code and the 2BL hash is fixed up to allow the 360 to boot. - You can also modify the Pairing Data and LDV in the headers. (v0.87) - Added, KV editting (change region, DVD-Key, OSIG type or import a new KV) (v0.86B) - Fixed bug (patching KV works again) - 5787 contains a modified CF, this build of the tool will now extract the HV & Kernel correctly (It doesn't change the way the extractor/patcher works but the change in CFs size broke my code) (v0.86A) - Fixes bug introduced in v0.85 when patching CB LDV - Changed file filter to '*.bin' (v0.86) - Adds support for bad blocks (no more crashes if you have a bad block in you dump) (v0.85) - Added option to patch CB LDV - Extract using new v1920 CD decryption - Extracts SMC code (v0.81) - Adds the possibility to dump just the flash in 3 parts: 1) Cx Sections 2) KV 3) File System Note: If you have bad flash blocks that prevent you dumping a particular area this will is a work around while I write some bad block handling code. (v0.80) - Fixed bug that ment xexp files were not applied correctly - Updated to prefix the XEX2 header on the front of the decrypted/patched binary for compatibility with the IDA Pro XEX loader. - Added the ability to re-encrypt and insert a KeyVault (by SeventhSon) (v0.72) - Fixed stupid no CPU key crash bug - Applies the patches (xexp files) it finds to the xex. (So, for a flash dump that contains: dash.xex (v1888), dash.xexp1 (v2241), dash.xexp2 (v2868)) (v0.70) - There are upto 4 keys required by the tool, you can enter these by clicking the Keys button. 1) 1BL Key 2) CPU Key 3) XEX 1 the Key used by the HV when the an XEXs certificate flag has bit 2 set 4) XEX 2 the Key used by the HV when the an XEXs certificate flag has bit 2 clear - The Extract button will cause the tool to extract as much as possible from the Flash dump to a directory you select. During the extraction process a log file (log.txt) is generated containing \"Useful Stuff To Know\": If 1BL is known - CB,CD,CE,CF(s),CG(s), xboxkrnl.1888.exe and xboxkrnl.XXXX.exe(s) as before If 1BL & CPU Key is known - KeyVault.bin If XEX1 & XEX2 & ECC data are known the tool will extract and decrypt & decompress the XEXs in the flash dump. The decrypted XEX is named xxxx.xex.bin. More info about the xex (and its patches) is contained in the log file. - Possibility to zero the pairing data in the CB section (tmbinc thought this caused the mfgbootlauncher.xex plus v1888 Kernel to be loaded) by clicking the Zero PD button. You do need the 1BL key but you DO NOT need your CPU key for this patch. - The Patch button allows you to change the Lockdown Counter(s) in the CF sections, as before, you DO need your CPU key (v0.61) - Fixed bug, the decryption of CG works again so now you can extract the different HV/Kernel versions from CE - Fixed bug, no longer crashes if it finds an invalid CG section - Added, load dumps (with or without ECC data). A non ECC dump must be exactly 16MB, all the Cx sections, Kernels, Key Vault will decrypt but you don't get access to the Flash File System. Note: (you cant dump a map of the ECC bytes and you cant save an image with a modified Lock Down Counter in CF. (v0.60) - Supports downgrading if you know your CPU key. - The CG decryption is broken in this version. (v0.51) - Added, Flash Map option (v0.50) - Now decrypts and extracts the Key Vault (DVD Key, Serialnumber & Date of Manufacture). You will need your CPU Fuses as dumped by Xell. - The CxKey.txt file has changed, you need to add a ',' and your CPU Fuse data. Example: XXXXXXXXXXXXXXXX,YYYYYYYYZZZZZZZZ XXXXXXXXXXXXXXXX is the 1BL key YYYYYYYYZZZZZZZZ is the fuse data (CPU Key) (v0.40) - Extraction of CE section is now working, you may now right click and select 'Extract' and get just the raw, decrypted CE Section or Kernel(s). (Thanks TheSpecialist) - Selecting Kernel(s) causes the application to extract the base (typically 1888) HV and Kernel as an uncompressed file - \"xboxkrnl.1888.exe\". - The option to extract them as a .cab file has now been removed. If 1 or both of the patch (CF/CG) slots are occupied they will be applied to the base kernel and the result is also written as a file - xboxkrnl.XXXX.exe. For example, if you have a base kernel (1888) and 2 patches (2858 and 4552) in your flash dump, load into the tool, right click on CE and choose kernel(s) you will get 3 files xboxkrnl.1888.exe The base HV & kernel, no patches xboxkrnl.2858.exe The base HV & kernel, patched to 2858 xboxkrnl.4552.exe The base HV & kernel, patched to 4552 (v0.30) - Fixed CG extraction (see NAND Layout thread for info) - Reverted CE.cab to single file (Thanks Takires) - Patch pairing data in CF and re-encrypt (v0.20) - Decrypts CF & CG (Thanks again tmbinc) - The .cab file extracted from CE now contains 2 files, Hypervisor.bin and xboxkrnl.exe - Exported sections now include version number in the name (v0.10) - Initial Release Category:Xbox360_Homebrew_Software","title":"General Info"},{"location":"360FlashTool/#general-info","text":"","title":"General Info"},{"location":"360FlashTool/#nfo","text":"This tool will allow you to decrypt and extract various parts of a XBox360 flash dump. This tool will allow you to decrypt/encrypt and extract various parts of a XBOX360 flash dump and much more!! The flash is devided into 2 major parts 1) The Cx sections (CB,CD,CE & 0,1 or 2 CF & CG sections). CB, CPU bootup CD, unpacker for CE CE, contains the HV and Kernel in a .cab archive CF&CG are upgrade patches The tool will extract and decrypt sections CB, CD, CE. Additionally it will extract the .cab file in section CE. This can be opened with winrar and the content (xboxkrnl.img) extracted. The first 256K of xboxkrnl.img is the Hypervisor, the remainder is the 2.0.1888 Kernel. 2) The Flash File System. The tool expects a dump to contain the data (512 bytes) followed by the ECC (16 bytes). The ECC bytes are used to locate FS entries & identify the version. The tool consists of the exe and CxKey.txt. CxKey.txt is delivered with 32 '0's and they should be replaced with the key obtained from the 1BL. After all the fuss about AACS keys recently it seems risky to put the key in the exe Wink The Cx sections extracted from a dump will only decrypt correctly if the correct hex digits are inserted in the CxKey.txt file Version History ----------------- (v0.97) - Improved Nand Image detection - Added support for small XeLL Images (1,3MB) - Added ability to extract/import Slot0/Slot1 of ZeroPaired Images [XBR/freeBOOT/small XeLL] - Added ability to detect/convert raw Images (made with external programmer) to proper read format - Added ability to detect/convert Images without ECC data (made with Infectus device) - Added ability to extract/import new 'dae.bin' file [DvdAuthEx] - Added support for \"Alternate KeyVault\" decrypting/extracting - Added option to rebuild an opened Nand Image with different CPU-Key (Bootloaders/HV and generic files) - Added option in Settings to allow randomized encryption - Added option in Settings to allow cut short BigBlock Nand Images (64MB) - Fixed bug, regarding to saving config block checksum at wrong offset (in rare cases) - Changed, more accurate file extraction, automatically create subfolders - A lot of improvements and bug fixes (v0.95) - Added support for Trinity (XBOX360 Slim) dumps - Added ability to extract new 'fcrt.bin' file (encrypted only atm) - Added ability to display SMC Code Version - Added ability to view Advanced KeyVault Info - Fixed bug, patching KeyVault works again - Fixed bug, no longer crashes if Bootloaders are small in size (in rare cases) - Fixed bug, regarding to re-encrypting the SMC when the image is Zero Paired Image (v0.94) - Added static SMC Config editing [change CPU/GPU Fan Speed, Calibration Data, MAC Address, ....] (Thanks to q36) - Added support for single file \"config.bin\" editing/converting via Drag'n'Drop - Added ability to convert Xellous/NandPro raw SMC Config to different Styles and vice versa, e.g. for ibuild (Thanks to foouser) // FreeBOOT SmallBlock Style 16Kb // FreeBOOT BigBlock Style 128Kb // FlashTool SmallBlock Style 64Kb // FlashTool BigBlock Style 512Kb // BinCrypt2 Style 32Kb - Added checksum calculation for static SMC Config Block (Thanks to cory1492) - Added ability to extract/import encrypted KeyVault without known CPU Key [For Advanced Users] - Added ability to extract ibuild compatible files (..\\freeBOOT\\Data) - Added ability to open 70MB images (dumped with nandpro \"-r70\") - Added Option menu to enable/disable several features - Added Tooltips and Glass Effect - Bugfix in Multiple CPU Key handling - Fixed a lot small bugs (v0.93) - Fixed CPU-Key detection/correction in Multiple Keys section - Added ability to save KeyVault to file - Added ability to export a registry file from all added Keys - Added support to extract the Console Revocation List to a readable format 'dynamic_list.txt' - Improved state indication via Progress Bar - Minor changes (v0.92) - Added Support for Large Block nands (Jasper 256MB and 512MB nands) - Added Support for DevKit images + region for DevKit - Added Support for XBR/ZeroPaired images (still in development) - Added Single CPU Key or Multiple CPU Key handling (max. 25 Keys) - Added simple state indication via Progress Bar - Added ability to display Bad Blocks with true image offsets - Fixed bug in reading 7BL (CG) that have more blocks than specified in 6BL (CF) - Fixed bug in reading bootloaders that are smaller than 1 block - Fixed bug in kernel extract log with double slashes, more accurate extract log - Fixed multiple memory leaks - Fixed application can now start without Administrator Rights or UAC enabled - Updated config block logic with new info - Changed appearance for more read comfort (v0.91) 2009-12-06 * Added, support for Jasper 16MB nands, Block ID and Block Version in a different location. Uses offset 0x71 to determine metadata style, 0 = Original, 1 = New 16MB, 2 = Large Block. * Added ability to open ZeroPaired images, but WARNING this should be treated as read only. I suspect it will destroy the nand image if used to modify the file. (v0.90) - Bugfix, regarding to CD decryption. If you have a 1920+ CD version it doesn't decrypt CD properly. (by arnezami) - Bugfix, if a CPU key starts with 00 then the program crashed. (by arnezami) - Added, separate extract option for all important stuff (Security Data, Extended Key Vault, Console Revocation List, AP25 Challenge Database, Config Blocks) - Added, console ID generation method (source from xorloser) - Added, detection and correction of 1 wrong byte in the CPU-Key (by MODFREAKz) - Added, XValue decryption (by Redline99) - Added, support when raw extracting a file that it sets the Date/Time stamps as per original in Nand - Fixed, decryption for \"Console Revocation List\" (Thanks to xorloser and Redline99) - Fixed, \"Kernels not extracted (CPU Key required, CD Ver == 1920)\" - Changed, full KV.bin extract and patch - Added new OSIG types and unspoof possibility - Added/Changed new regions - 1BL, XEX1 and XEX2 are set as standard - Improved exception handling - Added Drag and Drop - Changed Icon - Code cleanup - Fixed a lot of other small bugs (v0.88B) - Fixed the Region bug (HK/Asia <=> EU and AUS) - Redesigned (XP style) (v0.88A) - A small upgrade allowing the secdata.bin file to be decrypted. (You need the XEX and CPU keys then extract the filesystem and you will get a decrypted secdata.bin as well as a bunch of other stuff.) (v0.88) - The flash image can now be patched with modified SMC code and the 2BL hash is fixed up to allow the 360 to boot. - You can also modify the Pairing Data and LDV in the headers. (v0.87) - Added, KV editting (change region, DVD-Key, OSIG type or import a new KV) (v0.86B) - Fixed bug (patching KV works again) - 5787 contains a modified CF, this build of the tool will now extract the HV & Kernel correctly (It doesn't change the way the extractor/patcher works but the change in CFs size broke my code) (v0.86A) - Fixes bug introduced in v0.85 when patching CB LDV - Changed file filter to '*.bin' (v0.86) - Adds support for bad blocks (no more crashes if you have a bad block in you dump) (v0.85) - Added option to patch CB LDV - Extract using new v1920 CD decryption - Extracts SMC code (v0.81) - Adds the possibility to dump just the flash in 3 parts: 1) Cx Sections 2) KV 3) File System Note: If you have bad flash blocks that prevent you dumping a particular area this will is a work around while I write some bad block handling code. (v0.80) - Fixed bug that ment xexp files were not applied correctly - Updated to prefix the XEX2 header on the front of the decrypted/patched binary for compatibility with the IDA Pro XEX loader. - Added the ability to re-encrypt and insert a KeyVault (by SeventhSon) (v0.72) - Fixed stupid no CPU key crash bug - Applies the patches (xexp files) it finds to the xex. (So, for a flash dump that contains: dash.xex (v1888), dash.xexp1 (v2241), dash.xexp2 (v2868)) (v0.70) - There are upto 4 keys required by the tool, you can enter these by clicking the Keys button. 1) 1BL Key 2) CPU Key 3) XEX 1 the Key used by the HV when the an XEXs certificate flag has bit 2 set 4) XEX 2 the Key used by the HV when the an XEXs certificate flag has bit 2 clear - The Extract button will cause the tool to extract as much as possible from the Flash dump to a directory you select. During the extraction process a log file (log.txt) is generated containing \"Useful Stuff To Know\": If 1BL is known - CB,CD,CE,CF(s),CG(s), xboxkrnl.1888.exe and xboxkrnl.XXXX.exe(s) as before If 1BL & CPU Key is known - KeyVault.bin If XEX1 & XEX2 & ECC data are known the tool will extract and decrypt & decompress the XEXs in the flash dump. The decrypted XEX is named xxxx.xex.bin. More info about the xex (and its patches) is contained in the log file. - Possibility to zero the pairing data in the CB section (tmbinc thought this caused the mfgbootlauncher.xex plus v1888 Kernel to be loaded) by clicking the Zero PD button. You do need the 1BL key but you DO NOT need your CPU key for this patch. - The Patch button allows you to change the Lockdown Counter(s) in the CF sections, as before, you DO need your CPU key (v0.61) - Fixed bug, the decryption of CG works again so now you can extract the different HV/Kernel versions from CE - Fixed bug, no longer crashes if it finds an invalid CG section - Added, load dumps (with or without ECC data). A non ECC dump must be exactly 16MB, all the Cx sections, Kernels, Key Vault will decrypt but you don't get access to the Flash File System. Note: (you cant dump a map of the ECC bytes and you cant save an image with a modified Lock Down Counter in CF. (v0.60) - Supports downgrading if you know your CPU key. - The CG decryption is broken in this version. (v0.51) - Added, Flash Map option (v0.50) - Now decrypts and extracts the Key Vault (DVD Key, Serialnumber & Date of Manufacture). You will need your CPU Fuses as dumped by Xell. - The CxKey.txt file has changed, you need to add a ',' and your CPU Fuse data. Example: XXXXXXXXXXXXXXXX,YYYYYYYYZZZZZZZZ XXXXXXXXXXXXXXXX is the 1BL key YYYYYYYYZZZZZZZZ is the fuse data (CPU Key) (v0.40) - Extraction of CE section is now working, you may now right click and select 'Extract' and get just the raw, decrypted CE Section or Kernel(s). (Thanks TheSpecialist) - Selecting Kernel(s) causes the application to extract the base (typically 1888) HV and Kernel as an uncompressed file - \"xboxkrnl.1888.exe\". - The option to extract them as a .cab file has now been removed. If 1 or both of the patch (CF/CG) slots are occupied they will be applied to the base kernel and the result is also written as a file - xboxkrnl.XXXX.exe. For example, if you have a base kernel (1888) and 2 patches (2858 and 4552) in your flash dump, load into the tool, right click on CE and choose kernel(s) you will get 3 files xboxkrnl.1888.exe The base HV & kernel, no patches xboxkrnl.2858.exe The base HV & kernel, patched to 2858 xboxkrnl.4552.exe The base HV & kernel, patched to 4552 (v0.30) - Fixed CG extraction (see NAND Layout thread for info) - Reverted CE.cab to single file (Thanks Takires) - Patch pairing data in CF and re-encrypt (v0.20) - Decrypts CF & CG (Thanks again tmbinc) - The .cab file extracted from CE now contains 2 files, Hypervisor.bin and xboxkrnl.exe - Exported sections now include version number in the name (v0.10) - Initial Release Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"8051_8052/","text":"8051 / 8052 The 8051/8052 is an 8-bit microcontroller developed by Intel in 1980. The 8051/8052 is used in the Xbox 360. It is known as the SMC . It controls the front panel lights, DVD tray, fans, temperature sensors, etc. Category:Xbox360_Hardware","title":"8051 / 8052"},{"location":"8051_8052/#8051-8052","text":"The 8051/8052 is an 8-bit microcontroller developed by Intel in 1980. The 8051/8052 is used in the Xbox 360. It is known as the SMC . It controls the front panel lights, DVD tray, fans, temperature sensors, etc. Category:Xbox360_Hardware","title":"8051 / 8052"},{"location":"849x_System_Update/","text":"From Free60 Felix Domke, Michael Steil, Free60 Project 11 August 2009 Dangerous Xbox 360 Update Killing Homebrew** On Tuesday, Microsoft has released an Xbox 360 software update that overwrites the first stage bootloader of the system. Although there have been numerous software updates for Microsoft's gaming console in the past, this is the first one to overwrite the vital boot block. Any failure while updating this will break the Xbox 360 beyond repair. Statistics from other systems have shown that about one in a thousand bootloader updates goes wrong, and unless Microsoft has a novel solution to this problem, this puts tens of thousands of Xboxes at risk. It seems that this update is being done to fix a vulnerability already known to the Free60 Project. This vulnerability has been successfully exploited to run arbitrary code, and a complete end user compatible hack has been in development for some time and is planned to be released on free60.org shortly. It will allow users to take back control of their Xboxes and run arbitrary code like homebrew applications or Linux right after turning on the console and without the need of a modchip, finally opening up the Xbox 360 to a level of hacking as the original Xbox. Because of the dangerousness of the update and the homebrew lockout, the Free60 Project advises all Xbox 360 users to not update their systems to the latest software version . The Project website at http://free60.org/ will provide the latest information on this ongoing topic, including the final hack software. Free60 (www.free60.org) is a project that aims to enable Xbox 360 users to run homebrew applications and operating systems like Linux on their consoles. The effort is headed by Felix Domke and Michael Steil, who have a background in dbox2, Xbox and GameCube hacking, and who have spoken at various conferences about their findings. Two years ago, Free60 released a hack that allowed arbitrary code execution using a game (\"King Kong Hack\") as well as an adapted version of Linux, but this possibility has been disabled by Microsoft in subsequent updates of the Xbox 360 software. Felix and Michael have repeatedly argued that game console manufacturers should open up their platforms to Linux and homebrew, similar to what Sony has done with the PlayStation 3, before they removed the functionality of course. Category:Xbox360 System Software","title":"From Free60"},{"location":"849x_System_Update/#from-free60","text":"Felix Domke, Michael Steil, Free60 Project 11 August 2009","title":"From Free60"},{"location":"849x_System_Update/#dangerous-xbox-360-update-killing-homebrew","text":"On Tuesday, Microsoft has released an Xbox 360 software update that overwrites the first stage bootloader of the system. Although there have been numerous software updates for Microsoft's gaming console in the past, this is the first one to overwrite the vital boot block. Any failure while updating this will break the Xbox 360 beyond repair. Statistics from other systems have shown that about one in a thousand bootloader updates goes wrong, and unless Microsoft has a novel solution to this problem, this puts tens of thousands of Xboxes at risk. It seems that this update is being done to fix a vulnerability already known to the Free60 Project. This vulnerability has been successfully exploited to run arbitrary code, and a complete end user compatible hack has been in development for some time and is planned to be released on free60.org shortly. It will allow users to take back control of their Xboxes and run arbitrary code like homebrew applications or Linux right after turning on the console and without the need of a modchip, finally opening up the Xbox 360 to a level of hacking as the original Xbox. Because of the dangerousness of the update and the homebrew lockout, the Free60 Project advises all Xbox 360 users to not update their systems to the latest software version . The Project website at http://free60.org/ will provide the latest information on this ongoing topic, including the final hack software. Free60 (www.free60.org) is a project that aims to enable Xbox 360 users to run homebrew applications and operating systems like Linux on their consoles. The effort is headed by Felix Domke and Michael Steil, who have a background in dbox2, Xbox and GameCube hacking, and who have spoken at various conferences about their findings. Two years ago, Free60 released a hack that allowed arbitrary code execution using a game (\"King Kong Hack\") as well as an adapted version of Linux, but this possibility has been disabled by Microsoft in subsequent updates of the Xbox 360 software. Felix and Michael have repeatedly argued that game console manufacturers should open up their platforms to Linux and homebrew, similar to what Sony has done with the PlayStation 3, before they removed the functionality of course. Category:Xbox360 System Software","title":"Dangerous Xbox 360 Update Killing Homebrew**"},{"location":"Attack/","text":"Attack From Free60 This page was created when knowledge was low, everything on here is impossible, due to the 360's hypervisor. The only exploit there is and ever will be is the King Kong/JTAG (SMC)/or any other exploit for the 4532 kernel - slasherking823 Actually, upon further examination, this page was created by someone with no knowledge even when public knowledge existed. Bad Ideas are as follows: Please reply and comment each attack and tell us if such attacks are possible or not Please do not erase wrong things but reply instead Ideas Software Old Xbox games Known bugs on the old games Maybe it works (small probability that it has not been fixed) It's been noted that few of the Original Xbox's games whose game saves were exploitable appear on the Xbox 360 backwards list. However it's also worth knowing that games in addition to 007AUF, MA, and SC1 contain similar flaws - but their exploitation was not felt neccessary. This probably won't work, since the Xbox 360 emulates the old Xbox (with a customized emulator for each game). Using a bug in an old game would just \"break out\" into the emulated old Xbox. Of course, if the emulator design is sufficiently sloppy, it might be possible to have a second step that then compromises the actual Xbox 360 security. Patched games Patching (French) (Early Versions?) King Kong will need a patch in order to be playable on some screens The patch needs a HDD Manipulated media files Images, Music Files, Video Windows Media Center, after authenticating with the server, uses a client compiled for the 360 to access all Media Center functionality. The software is very buggy. It would be a prime target for attack. Start by trying out some exploits that are already known and see how Xbox 360 reacts to them There is potential to use a .tiff overflow(?) Certainly if the hypervisor behaves as suggested, it will catch the buffer overflow, but it might provide insight as to how it works. I emailed the team that did the .tiff overflow with the PSP (for anyone who knows about their work), and asked for info regarding how they went about .tiff exploit. They had some interesting things to say (I can email anyone their response if they want), and recommended this . I'm sure it's old business for a lot of people, but its over my head; I'm not able enough to get a lot of it. If someone wants to work in conjunction with me to try this exploit out, my email is GBW88@comcast.net. Maybe the recent WMF bug (escape function) will work too. WMF Files don't play on the 360. Save game attack Will require another hack first to be able to hijack a game's save game signing Network compromise Fuzzing services/network connections File system drivers Manipulating entries like the partition table, etc Hard Drive Mod.htm ] Decompression routines Cause a buffer overflow Hardware DMA attack Someone has developed an exploit for Firewire DMA FireWire - all your memory belongs to us Firewire can copy data between two Firewire HDDs without using the CPU at all (no irq gestion ...) Maybe retrieve some data that can't be retrieved USB and IDE that have DMA Maybe it doesn't work with non-Firewire devices Video: [2] Manipulated USB device Webcam iPod Torx and Solder Boot suggests various CPU parameters including the hypervisor mode and boot vector are set by the I2C/SPI bus on start up. If the I2C/SPI bus is accessible and modifiable then security features could be disabled allowing another vector to succeed. Theories are floating around some forums as to the validity of hacking DVD drive firmware to authenticate all discs as OK. Firmware has some basic bitswapping and xor-ing which was defeated quickly, maybe potential to change it? Good technical thread here at xboxhacker.net. Unfortunately, it starts in the name of backups, but it contains large amounts of insight as to how the DVD system functions. Signing code would still be a problem, but bypassing mediachecks could help at least. (Offtopic) If it is possible to modify the firmware, would it then not also be possible to read the 'hidden' security areas on (for example) audio-dvd? Buses If some bus are accessible but at too much high speed (don't remember well the design of the 360, I should re-read the documentation and websites) maybe use of highspeed DAC or professionals osciloscope for electronic design or aviation (maybe some people have access to such devices) or home-made ones (using some DAC of some cards (video-cards,tv-cards)) Easiest way to do DAQ is to use an NI DAQ system of allmost any kind (w/ fast enough DAC, something like FLASH-DAC) [3] Develop program for a snatching data from the bus. with high input impendances, megaohm range. If somebody is able to get those DAQ systems, I'm going to write a program for snatching data. Failed Vectors To save people revisiting old ground please list any attempts that have failed here Discussion Page design This is a stub or whatever you call this kind of page... It's as a \"brouillon(french)\" This page has not been reviewed by skilled persons... (maybe they haven't got the time) this page could be reviewed by someone that is not a developer (precious time) but is a press expert and know what is possible and what isn't. So put evrything on the main page and discuss it on the main page it's meant for this. And if something clean and verified can be produced we will make another \"stable\" page that developers should read. Ideas Xbox 360's OS has its root in the OS of the original Xbox (which is derivate from Windows 2000). I think that some bug and exploit in the Original Xbox (or even 2000) still works on the 360, we have to try every bug/fuzzing/hole knowed to find exploits. Ideas: File format fuzzing (there are some tools in Sourceforge), example: image format like WMF (recent exploit in Win 2000 and XP platform due to implementation of the fct escape() and not a BO!!!!!) XMA is a very good way to find some holes, and Sounds aren't signed (Demo DVD) Someone has Doc about XMA ? maybe in XACT ? By network UPnP (use XML), it's seems that the norm thinks about security like not permit to send XML break char, or limit ACL hack, but if there are an XML implementation (libXML) there are chance to find an exploit. We all know Microsoft's security in their implementation of norms (like IP stack or other). By DMA, using USB (security hole in Win 2000\\&XP ohcpi) other way: IDE (sata), we can try to access to DMA with a PC connected to the Xbox...by SATA ;-) the idea is to use the PC like an IDE device for the Xbox 360. I'm reading the DMA-API and IDE doc for Linux (if you have Linux, interessting stuff is in /include/Documentation/DMA-API.txt & DMA-mapping.txt and in /include/Drivers/ide/ ) By threads, if we can use the GPU to access to RAM and access to the same area as the CPU we can do some buggy things (in fact thread is not necessary) Resources: Metasploit, a huge DB for exloits and shellcodes https://metasploit.com/ Milw0rm, exploits milw0rm.com Fuzzing file and network http://rtos.trinux.org/secwiki/FuzzingTools XEX executables What security problems are known about the XEX files. They can be burned to DVD/CD and used to install the backwards compatability emulator, so attacking them would be a good idea. Since the OS for the 360 is based on Windows, is the .xex file in any way related to .exe? .xex files renamed to end in .exe do not do anything in Windows. I would like further documentation on what happens when the emulation software is executed via CD/DVD. -- Monsuco 19:29, 9 Mar 2006 (CET) The Xbox 360 CPU is based on the PowerPC architecture, not on Intel like PC CPUs. For that simple reason, an Xbox 360 executable will never run under a PC version of Windows. --Silence 10:59, 10 Mar 2006 (CET) First guy is absolutely retarded >_> - Thilo XNA The XNA libraries are .NET wrappers around various DirectX libraries (XACT, XInput, Direct3D, etc), and runs on the .NET Compact Framework. Both frameworks are fairly large and complex and it could be a possible candy store for exploits. Category:Support","title":"Attack"},{"location":"Attack/#attack","text":"","title":"Attack"},{"location":"Attack/#from-free60","text":"This page was created when knowledge was low, everything on here is impossible, due to the 360's hypervisor. The only exploit there is and ever will be is the King Kong/JTAG (SMC)/or any other exploit for the 4532 kernel - slasherking823 Actually, upon further examination, this page was created by someone with no knowledge even when public knowledge existed. Bad Ideas are as follows: Please reply and comment each attack and tell us if such attacks are possible or not Please do not erase wrong things but reply instead","title":"From Free60"},{"location":"Attack/#ideas","text":"","title":"Ideas"},{"location":"Attack/#software","text":"Old Xbox games Known bugs on the old games Maybe it works (small probability that it has not been fixed) It's been noted that few of the Original Xbox's games whose game saves were exploitable appear on the Xbox 360 backwards list. However it's also worth knowing that games in addition to 007AUF, MA, and SC1 contain similar flaws - but their exploitation was not felt neccessary. This probably won't work, since the Xbox 360 emulates the old Xbox (with a customized emulator for each game). Using a bug in an old game would just \"break out\" into the emulated old Xbox. Of course, if the emulator design is sufficiently sloppy, it might be possible to have a second step that then compromises the actual Xbox 360 security. Patched games Patching (French) (Early Versions?) King Kong will need a patch in order to be playable on some screens The patch needs a HDD Manipulated media files Images, Music Files, Video Windows Media Center, after authenticating with the server, uses a client compiled for the 360 to access all Media Center functionality. The software is very buggy. It would be a prime target for attack. Start by trying out some exploits that are already known and see how Xbox 360 reacts to them There is potential to use a .tiff overflow(?) Certainly if the hypervisor behaves as suggested, it will catch the buffer overflow, but it might provide insight as to how it works. I emailed the team that did the .tiff overflow with the PSP (for anyone who knows about their work), and asked for info regarding how they went about .tiff exploit. They had some interesting things to say (I can email anyone their response if they want), and recommended this . I'm sure it's old business for a lot of people, but its over my head; I'm not able enough to get a lot of it. If someone wants to work in conjunction with me to try this exploit out, my email is GBW88@comcast.net. Maybe the recent WMF bug (escape function) will work too. WMF Files don't play on the 360. Save game attack Will require another hack first to be able to hijack a game's save game signing Network compromise Fuzzing services/network connections File system drivers Manipulating entries like the partition table, etc Hard Drive Mod.htm ] Decompression routines Cause a buffer overflow","title":"Software"},{"location":"Attack/#hardware","text":"DMA attack Someone has developed an exploit for Firewire DMA FireWire - all your memory belongs to us Firewire can copy data between two Firewire HDDs without using the CPU at all (no irq gestion ...) Maybe retrieve some data that can't be retrieved USB and IDE that have DMA Maybe it doesn't work with non-Firewire devices Video: [2] Manipulated USB device Webcam iPod","title":"Hardware"},{"location":"Attack/#torx-and-solder","text":"Boot suggests various CPU parameters including the hypervisor mode and boot vector are set by the I2C/SPI bus on start up. If the I2C/SPI bus is accessible and modifiable then security features could be disabled allowing another vector to succeed. Theories are floating around some forums as to the validity of hacking DVD drive firmware to authenticate all discs as OK. Firmware has some basic bitswapping and xor-ing which was defeated quickly, maybe potential to change it? Good technical thread here at xboxhacker.net. Unfortunately, it starts in the name of backups, but it contains large amounts of insight as to how the DVD system functions. Signing code would still be a problem, but bypassing mediachecks could help at least. (Offtopic) If it is possible to modify the firmware, would it then not also be possible to read the 'hidden' security areas on (for example) audio-dvd? Buses If some bus are accessible but at too much high speed (don't remember well the design of the 360, I should re-read the documentation and websites) maybe use of highspeed DAC or professionals osciloscope for electronic design or aviation (maybe some people have access to such devices) or home-made ones (using some DAC of some cards (video-cards,tv-cards)) Easiest way to do DAQ is to use an NI DAQ system of allmost any kind (w/ fast enough DAC, something like FLASH-DAC) [3] Develop program for a snatching data from the bus. with high input impendances, megaohm range. If somebody is able to get those DAQ systems, I'm going to write a program for snatching data.","title":"Torx and Solder"},{"location":"Attack/#failed-vectors","text":"To save people revisiting old ground please list any attempts that have failed here","title":"Failed Vectors"},{"location":"Attack/#discussion","text":"","title":"Discussion"},{"location":"Attack/#page-design","text":"This is a stub or whatever you call this kind of page... It's as a \"brouillon(french)\" This page has not been reviewed by skilled persons... (maybe they haven't got the time) this page could be reviewed by someone that is not a developer (precious time) but is a press expert and know what is possible and what isn't. So put evrything on the main page and discuss it on the main page it's meant for this. And if something clean and verified can be produced we will make another \"stable\" page that developers should read.","title":"Page design"},{"location":"Attack/#ideas_1","text":"Xbox 360's OS has its root in the OS of the original Xbox (which is derivate from Windows 2000). I think that some bug and exploit in the Original Xbox (or even 2000) still works on the 360, we have to try every bug/fuzzing/hole knowed to find exploits. Ideas: File format fuzzing (there are some tools in Sourceforge), example: image format like WMF (recent exploit in Win 2000 and XP platform due to implementation of the fct escape() and not a BO!!!!!) XMA is a very good way to find some holes, and Sounds aren't signed (Demo DVD) Someone has Doc about XMA ? maybe in XACT ? By network UPnP (use XML), it's seems that the norm thinks about security like not permit to send XML break char, or limit ACL hack, but if there are an XML implementation (libXML) there are chance to find an exploit. We all know Microsoft's security in their implementation of norms (like IP stack or other). By DMA, using USB (security hole in Win 2000\\&XP ohcpi) other way: IDE (sata), we can try to access to DMA with a PC connected to the Xbox...by SATA ;-) the idea is to use the PC like an IDE device for the Xbox 360. I'm reading the DMA-API and IDE doc for Linux (if you have Linux, interessting stuff is in /include/Documentation/DMA-API.txt & DMA-mapping.txt and in /include/Drivers/ide/ ) By threads, if we can use the GPU to access to RAM and access to the same area as the CPU we can do some buggy things (in fact thread is not necessary) Resources: Metasploit, a huge DB for exloits and shellcodes https://metasploit.com/ Milw0rm, exploits milw0rm.com Fuzzing file and network http://rtos.trinux.org/secwiki/FuzzingTools","title":"Ideas"},{"location":"Attack/#xex-executables","text":"What security problems are known about the XEX files. They can be burned to DVD/CD and used to install the backwards compatability emulator, so attacking them would be a good idea. Since the OS for the 360 is based on Windows, is the .xex file in any way related to .exe? .xex files renamed to end in .exe do not do anything in Windows. I would like further documentation on what happens when the emulation software is executed via CD/DVD. -- Monsuco 19:29, 9 Mar 2006 (CET) The Xbox 360 CPU is based on the PowerPC architecture, not on Intel like PC CPUs. For that simple reason, an Xbox 360 executable will never run under a PC version of Windows. --Silence 10:59, 10 Mar 2006 (CET) First guy is absolutely retarded >_> - Thilo","title":"XEX executables"},{"location":"Attack/#xna","text":"The XNA libraries are .NET wrappers around various DirectX libraries (XACT, XInput, Direct3D, etc), and runs on the .NET Compact Framework. Both frameworks are fairly large and complex and it could be a possible candy store for exploits. Category:Support","title":"XNA"},{"location":"Boot_Process/","text":"Boot process This page details the boot process used in the Xbox 360. The process is slightly different between Devkit/Retail and certain boxes which have a secondary CB loader (trinity/some jaspers) Retail In Summary: Slim: 1BL -> CB_A -> CB_B -> CD -> CF -> CD -> HV -> Kernel -> Dashboard Phat (older): 1BL -> CB -> CD -> CF -> CD -> HV -> Kernel -> Dashboard Phat (newer): 1BL -> CB_A -> CB_B -> CD -> CF -> CD -> HV -> Kernel -> Dashboard 1BL (Inside CPU) Loads and decrypts CB(_A) into ram, it computes a RotSumSha1 of CB(_A) and uses it to verify its RSA signature. If the signature is valid, 1BL jumps to CB(_A). You can find reversed pseudocode of the 1bl here: 1BL Code CB SLIMS ONLY : CB_A loads and decrypts CB_B into ram, it computes a RotSumSha1 of CB_B and checks it against the known hash. If it matches CB_A jumps to CB_B. CB(_B) starts up a virtual machine, which does: - initializes the PCI Bridge - disables the GPU PCIE JTAG test port - initializes the serial port - talks to the SMC to clear the \"handshake\" bit - initializes memory - generates RROD if memory init fails CB(_B) loads and decrypts CD into ram, it computes a RotSumSha1 of CD and checks it against the known hash. If it matches CB(_B) jumps to CD. Methods to dump the CB bootloaders and examples of them reversed can be found here: CB Code CD Loads and decrypts CE into ram, computes a RotSumSha1 of CE. If it matches the known hash, it decompresses the LZX compressed base kernel. It then checks for patch slots. If it finds one, it will load and decrypt the corresponding CF bootloader for that patch. It then computes a RotSumSha1 of CF and uses it to verify the CF loaders signature. If the signature is valid, CD stays in memory but jumps to CF. There can be up to 2 CF/CG pairs for patching the kernel. CF Loads CG into memory by reading the CG data in the NAND header and then reads the rest of the CG data from the CG blocks specified in CF header. It then decrypts the CG in memory using the key generated from decrypting CF. To verify it, it computes a RotSumSha1 and checks it against the known hash. If it matches, it uses LZX delta decompress to apply the patch to the base kernel in memory. Once its done, it jumps back to CD and once CD has finished up, it jumps to the reset vector in the Hypervisor . Devkit In Summary: Phat: 1BL -> SB -> SC -> SD -> HV -> Kernel -> Dashboard The devkit bootloaders are nearly identical to their retail counterparts; however instead of hardcoded hash checks, devkits verify bootloaders SD and SE by signature checks. The SC bootloader is the hardware initialization virtual machine run by SB. Because devkits do not update over the air, they use a pre-patched SE (HV + kernel) bootloader) without delta patching CF/CG pairs. Kernel Once control is handed off to the kernel, as denoted by the POST output, the kernel does the following (on development systems): Initialize memory manager Initialize stack(s) Initialize object system (?) Initialize phase 1 thread (?) Phase 1 initialization and processors initialization Initialize keyvault Initialize HAL phase 1 Initialize SFC driver (?) Initialize security (?) INIT_KEY_EX_VAULT Initialize settings (?) Initialize power mode Initialize video driver Initialize audio driver Initialize boot animation Loads bootanim.xex Initialize SATA driver Initialize Shadowboot (not on retail systems) INIT_DUMP_SYSTEM (?) (not on retail systems) INIT_SYSTEM_ROOT (?) Initialize other drivers Initialize STFS driver Initialize XAM Core OS Executables After its initialization sequence, the kernel loads the following executables (in order) xam.xex xbdm.xex xstudio.xex ximecore.xex Xam.Community.xex (from disk) huduiskin.xex xshell.xex (devkits) / dash.xex (retail) It then unloads the following: huduiskin.xex bootanim.xex By this time the console will have booted into the dashboard Category:Xbox360 System Software","title":"Boot process"},{"location":"Boot_Process/#boot-process","text":"This page details the boot process used in the Xbox 360. The process is slightly different between Devkit/Retail and certain boxes which have a secondary CB loader (trinity/some jaspers)","title":"Boot process"},{"location":"Boot_Process/#retail","text":"In Summary: Slim: 1BL -> CB_A -> CB_B -> CD -> CF -> CD -> HV -> Kernel -> Dashboard Phat (older): 1BL -> CB -> CD -> CF -> CD -> HV -> Kernel -> Dashboard Phat (newer): 1BL -> CB_A -> CB_B -> CD -> CF -> CD -> HV -> Kernel -> Dashboard","title":"Retail"},{"location":"Boot_Process/#1bl-inside-cpu","text":"Loads and decrypts CB(_A) into ram, it computes a RotSumSha1 of CB(_A) and uses it to verify its RSA signature. If the signature is valid, 1BL jumps to CB(_A). You can find reversed pseudocode of the 1bl here: 1BL Code","title":"1BL (Inside CPU)"},{"location":"Boot_Process/#cb","text":"SLIMS ONLY : CB_A loads and decrypts CB_B into ram, it computes a RotSumSha1 of CB_B and checks it against the known hash. If it matches CB_A jumps to CB_B. CB(_B) starts up a virtual machine, which does: - initializes the PCI Bridge - disables the GPU PCIE JTAG test port - initializes the serial port - talks to the SMC to clear the \"handshake\" bit - initializes memory - generates RROD if memory init fails CB(_B) loads and decrypts CD into ram, it computes a RotSumSha1 of CD and checks it against the known hash. If it matches CB(_B) jumps to CD. Methods to dump the CB bootloaders and examples of them reversed can be found here: CB Code","title":"CB"},{"location":"Boot_Process/#cd","text":"Loads and decrypts CE into ram, computes a RotSumSha1 of CE. If it matches the known hash, it decompresses the LZX compressed base kernel. It then checks for patch slots. If it finds one, it will load and decrypt the corresponding CF bootloader for that patch. It then computes a RotSumSha1 of CF and uses it to verify the CF loaders signature. If the signature is valid, CD stays in memory but jumps to CF. There can be up to 2 CF/CG pairs for patching the kernel.","title":"CD"},{"location":"Boot_Process/#cf","text":"Loads CG into memory by reading the CG data in the NAND header and then reads the rest of the CG data from the CG blocks specified in CF header. It then decrypts the CG in memory using the key generated from decrypting CF. To verify it, it computes a RotSumSha1 and checks it against the known hash. If it matches, it uses LZX delta decompress to apply the patch to the base kernel in memory. Once its done, it jumps back to CD and once CD has finished up, it jumps to the reset vector in the Hypervisor .","title":"CF"},{"location":"Boot_Process/#devkit","text":"In Summary: Phat: 1BL -> SB -> SC -> SD -> HV -> Kernel -> Dashboard The devkit bootloaders are nearly identical to their retail counterparts; however instead of hardcoded hash checks, devkits verify bootloaders SD and SE by signature checks. The SC bootloader is the hardware initialization virtual machine run by SB. Because devkits do not update over the air, they use a pre-patched SE (HV + kernel) bootloader) without delta patching CF/CG pairs.","title":"Devkit"},{"location":"Boot_Process/#kernel","text":"Once control is handed off to the kernel, as denoted by the POST output, the kernel does the following (on development systems): Initialize memory manager Initialize stack(s) Initialize object system (?) Initialize phase 1 thread (?) Phase 1 initialization and processors initialization Initialize keyvault Initialize HAL phase 1 Initialize SFC driver (?) Initialize security (?) INIT_KEY_EX_VAULT Initialize settings (?) Initialize power mode Initialize video driver Initialize audio driver Initialize boot animation Loads bootanim.xex Initialize SATA driver Initialize Shadowboot (not on retail systems) INIT_DUMP_SYSTEM (?) (not on retail systems) INIT_SYSTEM_ROOT (?) Initialize other drivers Initialize STFS driver Initialize XAM","title":"Kernel"},{"location":"Boot_Process/#core-os-executables","text":"After its initialization sequence, the kernel loads the following executables (in order) xam.xex xbdm.xex xstudio.xex ximecore.xex Xam.Community.xex (from disk) huduiskin.xex xshell.xex (devkits) / dash.xex (retail) It then unloads the following: huduiskin.xex bootanim.xex By this time the console will have booted into the dashboard Category:Xbox360 System Software","title":"Core OS Executables"},{"location":"Bootloaders/","text":"Bootloaders The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process . Header The header is at the start of the bootloader and is usually 0x20 bytes long. Offset Length Type Information 0x0 0x2 ASCII characters Loader name 0x2 0x2 unsigned short Loader build number 0x4 0x2 unsigned short Loader pairing data 0x6 0x2 unsigned short Loader flags 0x8 0x4 unsigned integer Loader entrypoint 0xC 0x4 unsigned integer Loader length (including header) 0x10 0x10 bytes HMAC salt (used for decrypting the loader)","title":"Bootloaders"},{"location":"Bootloaders/#bootloaders","text":"The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process .","title":"Bootloaders"},{"location":"Bootloaders/#header","text":"The header is at the start of the bootloader and is usually 0x20 bytes long. Offset Length Type Information 0x0 0x2 ASCII characters Loader name 0x2 0x2 unsigned short Loader build number 0x4 0x2 unsigned short Loader pairing data 0x6 0x2 unsigned short Loader flags 0x8 0x4 unsigned integer Loader entrypoint 0xC 0x4 unsigned integer Loader length (including header) 0x10 0x10 bytes HMAC salt (used for decrypting the loader)","title":"Header"},{"location":"CB_Code/","text":"CB Code Some notes on the mfg version to start with: In the mfg version of the CB_A, the cpukey is set to null and XeCryptHmacSha is given the null buffer to generate the next key Other than that there is no other change in the mfg version, boot process seems to continue as normal unless I'm overlooking a flag being set It seems the mfg version is signed, which means we should be able to flash it to consoles without an issue and then we wouldn't have to worry about cpukeys for the cb at least. xebuild doesn't do that, I wonder why CB Dump // BLKey = 1BL Key // Hvx methods are meant to be proxies to read HV memory from user mode. #define SPACE_NAND 0x80000200C8000000ULL void getCB_AKey(PBYTE Keybuf) { QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8); BYTE cbSalt[0x10]; Hvx::HvPeekBytes(cbAddy+0x10, cbSalt, 0x10); XeCryptHmacSha(BLKey, 0x10, cbSalt, 0x10, 0, 0, 0, 0, Keybuf, 0x10); } void getCB_BKey(PBYTE Keybuf) { DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs + 0xC) + 0xF) & 0xFFFFFFF0; QWORD cbbAddy = SPACE_NAND + cbbOffs; BYTE cbbSalt[0x10]; BYTE cbKey[0x10]; BYTE CPUKey[0x10]; getCB_AKey(cbKey); getCPUKey(CPUKey); Hvx::HvPeekBytes(cbbAddy+0x10, cbbSalt, 0x10); XeCryptHmacSha(cbKey, 0x10, cbbSalt, 0x10, CPUKey, 0x10, 0, 0, Keybuf, 0x10); } void DumpCB_A() { DbgOut(\"Dumping CB_A....\\n\"); QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD size = Hvx::HvPeekDWORD(cbAddy+0xC); printf(\"cbAddy: %016llX\\nSize: %X\\n\", cbAddy, size); PBYTE cb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE); Hvx::HvPeekBytes(cbAddy, cb, size); CWriteFile(\"Hdd:\\\\cb_enc.bin\", cb, size); BYTE rc4key[0x10]; getCB_AKey(rc4key); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, rc4key, 0x10); XeCryptRc4Ecb(&rc4, cb + 0x20, size - 0x20); CWriteFile(\"Hdd:\\\\cb_dec.bin\", cb, size); XPhysicalFree(cb); } void DumpCB_B() { DbgOut(\"Dumping CB_B....\\n\"); DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs+0xC) + 0xF) & 0xFFFFFFF0; QWORD cbbAddy = SPACE_NAND + cbbOffs; DWORD size = Hvx::HvPeekDWORD(cbbAddy + 0xC); printf(\"cbbOffs: 0x%08X\\ncbbAddy: 0x%016llX\\nSize: 0x%X\\n\", cbbOffs, cbbAddy, size); PBYTE cbb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE); Hvx::HvPeekBytes(cbbAddy, cbb, size); CWriteFile(\"Hdd:\\\\cbb_enc.bin\", cbb, size); BYTE cbbKey[0x10]; getCB_BKey(cbbKey); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, cbbKey, 0x10); XeCryptRc4Ecb(&rc4, cbb + 0x20, size - 0x20); CWriteFile(\"Hdd:\\\\cbb_dec.bin\", cbb, size); XPhysicalFree(cbb); } CB_A Pseudocode Version: 9188 retail // version: 0x23E4 // entry: 0x3C0 // size: 0x1AC0 // registers preset by the 1bl // r27: not used // r28: not used // r29: not used // r30: not used // r31: next bl (cbb nand offset) // CB_A nand offset + CB_A size aligned to the upper 0x10 byte (ex: size = (size+0xF) & 0xFFFFFFF0) #define STACK 0x800002000001F700 // r1 #define TOC 0x800002000001C000 // r2 #define SRAM 0x8000020000010000 #define POSTo 0x8000020000061010 #define NAND 0x80000200C8000000 #define SOC 0x8000020000020000 // an attempt to make this easier to read #define read64(addy) *(QWORD*)addy #define read32(addy) *(DWORD*)addy #define read16(addy) *(WORD*)addy #define write64(addy, data) *(QWORD*)addy = data #define write32(addy, data) *(DWORD*)addy = data #define write16(addy, data) *(WORD*)addy = data typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 QWORD Pad[4]; // 0x20 : 0x20 // not used here? XECRYPT_SIG Sig; // 0x40 : 0x100 // Header: 0x140 }BLHeader, *PBLHeader; void POST(BYTE postCode) { write64(POSTo, (postCode << 56)); } void PanicGen() { while(1) continue; } void Panic(QWORD postCode) { POST(postCode); PanicGen(); } bool VerifyOffset(DWORD offset, DWORD arg2) { if(offset != (offset + 0xF) & 0xFFFFFFF0) return false; if(offset - 0x80 > 0x7FFFF7F) return false; if(arg2 & 0xFFFFFFF0 >= offset - 0x8000000) return false; return true; } // Copies by 0x10 byte blocks // cBlocks: how many 0x10 byte blocks to copy void CopyBy128(QWORD dest, QWORD src, DWORD cBlocks) { for(int i = 0; i < cBlocks; i++) { write64(dest+(i*0x10), read64(src+(i*0x10))); write64(dest+(i*0x10)+8, read64(src+(i*0x10)+8)) } } void ZeroBy128(QWORD addy, QWORD count) { for(int i = 0; i < count; i++) { write64(addy+(i*0x10), 0ULL); write64(addy+(i*0x10)+8, 0ULL); } } QWORD getFuseline(DWORD fuse) { if ((fuse * 0x40) < 0x300) return read64(SOC + ((fuse * 0x40) << 3)); return 0; } void CBB_Jump(QWORD EntryPoint, QWORD NextBL) { // presets for the next bootloader QWORD r27 = read64(SRAM + 0x20); QWORD r28 = read64(SRAM + 0x28); QWORD r29 = read64(SRAM + 0x30); QWORD r30 = read64(SRAM + 0x38); QWORD r31 = NextBL; // nand offset of the next bl // null the beginning of the cbb ZeroBy128(SRAM + 0x20, 0x12); DWORD tSize = (read32(SRAM + 0xC) + 0xF) & 0xFFFFFFF0; if(tSize > 0xC000) Panic(0xF3); // null the area after the cbb ZeroBy128(SRAM + tSize, (0xC000 - tSize) >> 4); // Sets r0-r26 and the CTR to 0 // jump to cbb EntryPoint = (EntryPoint & 0xFFFF) + 0x2000000; goto EntryPoint; } void CBB_Load(const QWORD offCBB, QWORD destCBB) { // first null the stack for(int i = 0; i < 0xB; i++) write64(stack-0x1A8+(i*8), 0ULL); POST(0xD1); // copy fuses for CBB decryption QWORD fuses[12] = { 0 }; BYTE CPUKey[0x10] = { 0 }; // if this is the mfg cb_a or a dev cb_a then the cpukey is set to 0 #ifdef RETAIL for(int i = 0; i < 12; i++) getFuseline(i); QWORD fuse = fuses[3] | fuses[4]; // first CPUKey fuses write64(CPUKey, fuse); fuse = fuses[5] | fuses[6]; // second CPUKey fuses write64(CPUKey+8, fuse); #endif POST(0xD2); // verify CBB offset DWORD cbbOffset = offCBB & 0xFFFFFFFF; // r28 if(!VerifyOffset(cbbOffset, 0x10)) Panic(0xF0); POST(0xD3); // copy cbb header to sram QWORD cbbAddy = NAND + cbbOffset; CopyBy128(destCBB, cbbAddy, 1); POST(0xD4); // verify header PBLHeader cbbHeader = (PBLHeader)destCBB; if((cbbHeader->Size - 0x3C0) > 0xBC40 // size check || cbbHeader->Magic != read64(TOC) & 0xFFFF // magic check || cbbHeader->EntryPoint & 0x3 // alignment check || cbbHeader->EntryPoint < 0x3C0 // EntryPoint check || cbbHeader->EntryPoint >= cbbHeader->Size & 0xFFFFFFFC // entrypoint/size relation check || !VerifyOffset(cbbOffset, cbbHeader->Size)) Panic(0xF1); POST(0xD5); // copy cbb to SRAM QWORD tSize = (cbbHeader->Size + 0xF) & 0xFFFFFFF0; CopyBy128(destCBB + 0x10, cbbAddy + 0x10, ((tSize - 0x10) >> 4) & 0xFFFFFFFF); POST(0xD6); // Gen cbb key // cbb key = hmacsha of the cb_a key, cb_b salt, and CPUKey XeCryptHmacSha(TOC+0x10, 0x10, &cbbHeader->key, 0x10, CPUKey, 0x10, 0, 0, &cbbHeader->key, 0x10); POST(0xD7); // set key XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, &cbbHeader->key, 0x10); POST(0xD8); // decrypt cbb XeCryptRc4Ecb(&rc4, SRAM+0x20, tSize-0x20); POST(0xD9); // generate hash BYTE Hash[0x14] = { 0 }; XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tSize-0x140, Hash, 0x14); POST(0xDA); // verify integrity if(memcmp(Hash, TOC+0x39C, 0x14)) Panic(0xF2); POST(0xDB); // jump to cbb write16(SRAM+6, read16(SRAM+6)); // copy flags CBB_Jump(cbbHeader->EntryPoint, tSize+offCBB); return; } void CBA_Main() { // registers 27-31 are preset by the 1bl opon entry POST(0xD0); // CB_A entry, copy self to 0x800002000001C000 and continue from there DWORD size = *(QWORD*)SRAM+0xC; size = (size+0xF) >> 3; for(int i = 0; i < size; i++) write64(TOC+(i*8), read64(SRAM+(i*8))); // from now on we're executing from 0x800002000001C000 CBB_Load(r31, SRAM); }","title":"CB Code"},{"location":"CB_Code/#cb-code","text":"Some notes on the mfg version to start with: In the mfg version of the CB_A, the cpukey is set to null and XeCryptHmacSha is given the null buffer to generate the next key Other than that there is no other change in the mfg version, boot process seems to continue as normal unless I'm overlooking a flag being set It seems the mfg version is signed, which means we should be able to flash it to consoles without an issue and then we wouldn't have to worry about cpukeys for the cb at least. xebuild doesn't do that, I wonder why","title":"CB Code"},{"location":"CB_Code/#cb-dump","text":"// BLKey = 1BL Key // Hvx methods are meant to be proxies to read HV memory from user mode. #define SPACE_NAND 0x80000200C8000000ULL void getCB_AKey(PBYTE Keybuf) { QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8); BYTE cbSalt[0x10]; Hvx::HvPeekBytes(cbAddy+0x10, cbSalt, 0x10); XeCryptHmacSha(BLKey, 0x10, cbSalt, 0x10, 0, 0, 0, 0, Keybuf, 0x10); } void getCB_BKey(PBYTE Keybuf) { DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs + 0xC) + 0xF) & 0xFFFFFFF0; QWORD cbbAddy = SPACE_NAND + cbbOffs; BYTE cbbSalt[0x10]; BYTE cbKey[0x10]; BYTE CPUKey[0x10]; getCB_AKey(cbKey); getCPUKey(CPUKey); Hvx::HvPeekBytes(cbbAddy+0x10, cbbSalt, 0x10); XeCryptHmacSha(cbKey, 0x10, cbbSalt, 0x10, CPUKey, 0x10, 0, 0, Keybuf, 0x10); } void DumpCB_A() { DbgOut(\"Dumping CB_A....\\n\"); QWORD cbAddy = SPACE_NAND + Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD size = Hvx::HvPeekDWORD(cbAddy+0xC); printf(\"cbAddy: %016llX\\nSize: %X\\n\", cbAddy, size); PBYTE cb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE); Hvx::HvPeekBytes(cbAddy, cb, size); CWriteFile(\"Hdd:\\\\cb_enc.bin\", cb, size); BYTE rc4key[0x10]; getCB_AKey(rc4key); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, rc4key, 0x10); XeCryptRc4Ecb(&rc4, cb + 0x20, size - 0x20); CWriteFile(\"Hdd:\\\\cb_dec.bin\", cb, size); XPhysicalFree(cb); } void DumpCB_B() { DbgOut(\"Dumping CB_B....\\n\"); DWORD cbOffs = Hvx::HvPeekDWORD(SPACE_NAND + 8); DWORD cbbOffs = cbOffs + (Hvx::HvPeekDWORD(SPACE_NAND + cbOffs+0xC) + 0xF) & 0xFFFFFFF0; QWORD cbbAddy = SPACE_NAND + cbbOffs; DWORD size = Hvx::HvPeekDWORD(cbbAddy + 0xC); printf(\"cbbOffs: 0x%08X\\ncbbAddy: 0x%016llX\\nSize: 0x%X\\n\", cbbOffs, cbbAddy, size); PBYTE cbb = (PBYTE)XPhysicalAlloc(size, MAXULONG_PTR, NULL, PAGE_READWRITE); Hvx::HvPeekBytes(cbbAddy, cbb, size); CWriteFile(\"Hdd:\\\\cbb_enc.bin\", cbb, size); BYTE cbbKey[0x10]; getCB_BKey(cbbKey); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, cbbKey, 0x10); XeCryptRc4Ecb(&rc4, cbb + 0x20, size - 0x20); CWriteFile(\"Hdd:\\\\cbb_dec.bin\", cbb, size); XPhysicalFree(cbb); }","title":"CB Dump"},{"location":"CB_Code/#cb_a-pseudocode","text":"Version: 9188 retail // version: 0x23E4 // entry: 0x3C0 // size: 0x1AC0 // registers preset by the 1bl // r27: not used // r28: not used // r29: not used // r30: not used // r31: next bl (cbb nand offset) // CB_A nand offset + CB_A size aligned to the upper 0x10 byte (ex: size = (size+0xF) & 0xFFFFFFF0) #define STACK 0x800002000001F700 // r1 #define TOC 0x800002000001C000 // r2 #define SRAM 0x8000020000010000 #define POSTo 0x8000020000061010 #define NAND 0x80000200C8000000 #define SOC 0x8000020000020000 // an attempt to make this easier to read #define read64(addy) *(QWORD*)addy #define read32(addy) *(DWORD*)addy #define read16(addy) *(WORD*)addy #define write64(addy, data) *(QWORD*)addy = data #define write32(addy, data) *(DWORD*)addy = data #define write16(addy, data) *(WORD*)addy = data typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 QWORD Pad[4]; // 0x20 : 0x20 // not used here? XECRYPT_SIG Sig; // 0x40 : 0x100 // Header: 0x140 }BLHeader, *PBLHeader; void POST(BYTE postCode) { write64(POSTo, (postCode << 56)); } void PanicGen() { while(1) continue; } void Panic(QWORD postCode) { POST(postCode); PanicGen(); } bool VerifyOffset(DWORD offset, DWORD arg2) { if(offset != (offset + 0xF) & 0xFFFFFFF0) return false; if(offset - 0x80 > 0x7FFFF7F) return false; if(arg2 & 0xFFFFFFF0 >= offset - 0x8000000) return false; return true; } // Copies by 0x10 byte blocks // cBlocks: how many 0x10 byte blocks to copy void CopyBy128(QWORD dest, QWORD src, DWORD cBlocks) { for(int i = 0; i < cBlocks; i++) { write64(dest+(i*0x10), read64(src+(i*0x10))); write64(dest+(i*0x10)+8, read64(src+(i*0x10)+8)) } } void ZeroBy128(QWORD addy, QWORD count) { for(int i = 0; i < count; i++) { write64(addy+(i*0x10), 0ULL); write64(addy+(i*0x10)+8, 0ULL); } } QWORD getFuseline(DWORD fuse) { if ((fuse * 0x40) < 0x300) return read64(SOC + ((fuse * 0x40) << 3)); return 0; } void CBB_Jump(QWORD EntryPoint, QWORD NextBL) { // presets for the next bootloader QWORD r27 = read64(SRAM + 0x20); QWORD r28 = read64(SRAM + 0x28); QWORD r29 = read64(SRAM + 0x30); QWORD r30 = read64(SRAM + 0x38); QWORD r31 = NextBL; // nand offset of the next bl // null the beginning of the cbb ZeroBy128(SRAM + 0x20, 0x12); DWORD tSize = (read32(SRAM + 0xC) + 0xF) & 0xFFFFFFF0; if(tSize > 0xC000) Panic(0xF3); // null the area after the cbb ZeroBy128(SRAM + tSize, (0xC000 - tSize) >> 4); // Sets r0-r26 and the CTR to 0 // jump to cbb EntryPoint = (EntryPoint & 0xFFFF) + 0x2000000; goto EntryPoint; } void CBB_Load(const QWORD offCBB, QWORD destCBB) { // first null the stack for(int i = 0; i < 0xB; i++) write64(stack-0x1A8+(i*8), 0ULL); POST(0xD1); // copy fuses for CBB decryption QWORD fuses[12] = { 0 }; BYTE CPUKey[0x10] = { 0 }; // if this is the mfg cb_a or a dev cb_a then the cpukey is set to 0 #ifdef RETAIL for(int i = 0; i < 12; i++) getFuseline(i); QWORD fuse = fuses[3] | fuses[4]; // first CPUKey fuses write64(CPUKey, fuse); fuse = fuses[5] | fuses[6]; // second CPUKey fuses write64(CPUKey+8, fuse); #endif POST(0xD2); // verify CBB offset DWORD cbbOffset = offCBB & 0xFFFFFFFF; // r28 if(!VerifyOffset(cbbOffset, 0x10)) Panic(0xF0); POST(0xD3); // copy cbb header to sram QWORD cbbAddy = NAND + cbbOffset; CopyBy128(destCBB, cbbAddy, 1); POST(0xD4); // verify header PBLHeader cbbHeader = (PBLHeader)destCBB; if((cbbHeader->Size - 0x3C0) > 0xBC40 // size check || cbbHeader->Magic != read64(TOC) & 0xFFFF // magic check || cbbHeader->EntryPoint & 0x3 // alignment check || cbbHeader->EntryPoint < 0x3C0 // EntryPoint check || cbbHeader->EntryPoint >= cbbHeader->Size & 0xFFFFFFFC // entrypoint/size relation check || !VerifyOffset(cbbOffset, cbbHeader->Size)) Panic(0xF1); POST(0xD5); // copy cbb to SRAM QWORD tSize = (cbbHeader->Size + 0xF) & 0xFFFFFFF0; CopyBy128(destCBB + 0x10, cbbAddy + 0x10, ((tSize - 0x10) >> 4) & 0xFFFFFFFF); POST(0xD6); // Gen cbb key // cbb key = hmacsha of the cb_a key, cb_b salt, and CPUKey XeCryptHmacSha(TOC+0x10, 0x10, &cbbHeader->key, 0x10, CPUKey, 0x10, 0, 0, &cbbHeader->key, 0x10); POST(0xD7); // set key XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, &cbbHeader->key, 0x10); POST(0xD8); // decrypt cbb XeCryptRc4Ecb(&rc4, SRAM+0x20, tSize-0x20); POST(0xD9); // generate hash BYTE Hash[0x14] = { 0 }; XeCryptRotSumSha(SRAM, 0x10, SRAM+0x140, tSize-0x140, Hash, 0x14); POST(0xDA); // verify integrity if(memcmp(Hash, TOC+0x39C, 0x14)) Panic(0xF2); POST(0xDB); // jump to cbb write16(SRAM+6, read16(SRAM+6)); // copy flags CBB_Jump(cbbHeader->EntryPoint, tSize+offCBB); return; } void CBA_Main() { // registers 27-31 are preset by the 1bl opon entry POST(0xD0); // CB_A entry, copy self to 0x800002000001C000 and continue from there DWORD size = *(QWORD*)SRAM+0xC; size = (size+0xF) >> 3; for(int i = 0; i < size; i++) write64(TOC+(i*8), read64(SRAM+(i*8))); // from now on we're executing from 0x800002000001C000 CBB_Load(r31, SRAM); }","title":"CB_A Pseudocode"},{"location":"Case/","text":"Case The Xbox 360 Case is made of plastic and was originally made to be hard to open. However it can easy be removed : Remove the HDD Remove the Face Plate by inserting your Right thumbs into it and forcing it a bit upwards You need to remove this panel before lifting the front panel\u2022Then remove both side pannels by inserting a small iron tool into the holes, and popping out the place holders Slowly lift up the Front panel, by unlocking the 4 plastic placesholders about 4cm Then insert a small tool in each hole of the backplate and open up the back side You now can lift up the upper part of the casing To remove the border case, Remove 6 large screws from the down panel with a torx T10 screw driver. Downside of the metal casing Motherboard Category:Xbox360_Hardware","title":"Case"},{"location":"Case/#case","text":"The Xbox 360 Case is made of plastic and was originally made to be hard to open. However it can easy be removed : Remove the HDD Remove the Face Plate by inserting your Right thumbs into it and forcing it a bit upwards You need to remove this panel before lifting the front panel\u2022Then remove both side pannels by inserting a small iron tool into the holes, and popping out the place holders Slowly lift up the Front panel, by unlocking the 4 plastic placesholders about 4cm Then insert a small tool in each hole of the backplate and open up the back side You now can lift up the upper part of the casing To remove the border case, Remove 6 large screws from the down panel with a torx T10 screw driver. Downside of the metal casing Motherboard Category:Xbox360_Hardware","title":"Case"},{"location":"Category_Pages_with_missing_images/","text":"Category: Pages with missing images DVD Drive Wifi Adapter","title":"Category: Pages with missing images"},{"location":"Category_Pages_with_missing_images/#category-pages-with-missing-images","text":"DVD Drive Wifi Adapter","title":"Category: Pages with missing images"},{"location":"Category_Support/","text":"Category: Support Attack Contribute FAQ Help IRC King Kong Hack Links Run Code","title":"Support"},{"location":"Category_Support/#category-support","text":"Attack Contribute FAQ Help IRC King Kong Hack Links Run Code","title":"Category: Support"},{"location":"Category_Template_documentation/","text":"Category: Template documentation Old Main Page Other OS Loader","title":"Category: Template documentation"},{"location":"Category_Template_documentation/#category-template-documentation","text":"Old Main Page Other OS Loader","title":"Category: Template documentation"},{"location":"Category_Xbox360_Development/","text":"Category: Xbox 360 Development Cross Compiler Dumpana Finding the right timing Free60 Git Repository LibHomebrew LibXenon LibXenon Examples List of development tools Run Code Starting Homebrew Development UART Xenon Toolchain Xenos Framebuffer","title":"Development"},{"location":"Category_Xbox360_Development/#category-xbox-360-development","text":"Cross Compiler Dumpana Finding the right timing Free60 Git Repository LibHomebrew LibXenon LibXenon Examples List of development tools Run Code Starting Homebrew Development UART Xenon Toolchain Xenos Framebuffer","title":"Category: Xbox 360 Development"},{"location":"Category_Xbox360_Hardware/","text":"Category: Xbox 360 Hardware 8051 8052 Case Chatpad DVD Drive Error Codes Ethernet Falcon Fusesets GamePad HDD Headset Jasper Level Shifter Media Remote Memory Memory Unit Motherboard NAND NAND Bad Blocks Northbridge Opus Pin Headers Play and Charge Kit Pre-release differences R6T3 Reset Glitch Hack RF Module Run Code SMC SMC Hack Southbridge Stereo DAC Trinity UART USB Webcam Wifi Adapter Xbox 360 Motherboard Xenon Xenon (CPU) Xenon (Motherboard) Xenos (GPU) Zephyr","title":"Hardware"},{"location":"Category_Xbox360_Hardware/#category-xbox-360-hardware","text":"8051 8052 Case Chatpad DVD Drive Error Codes Ethernet Falcon Fusesets GamePad HDD Headset Jasper Level Shifter Media Remote Memory Memory Unit Motherboard NAND NAND Bad Blocks Northbridge Opus Pin Headers Play and Charge Kit Pre-release differences R6T3 Reset Glitch Hack RF Module Run Code SMC SMC Hack Southbridge Stereo DAC Trinity UART USB Webcam Wifi Adapter Xbox 360 Motherboard Xenon Xenon (CPU) Xenon (Motherboard) Xenos (GPU) Zephyr","title":"Category: Xbox 360 Hardware"},{"location":"Category_Xbox360_Homebrew_Software/","text":"Category: Xbox 360 Homebrew Software 360FlashTool Genesis Plus Lflash LibHomebrew LibXenon LibXenon Examples List of homebrew applications List of homebrew emulators List of homebrew games List of homebrew_loaders List of PC utilities List of system tools Mupen64-360 NandCompare NANDPro PCSXR Xenon PC Software Pong Rawflash Run Code SDLQuake Sega Genesis_Plus_GX Sega Master_System_Plus Snes9x-Gx Starting Homebrew Development Tanks 360 UART Utilities XeLL XeLL Reloaded XMENU XMPlayer ZLX Browser","title":"Homebrew Software"},{"location":"Category_Xbox360_Homebrew_Software/#category-xbox-360-homebrew-software","text":"360FlashTool Genesis Plus Lflash LibHomebrew LibXenon LibXenon Examples List of homebrew applications List of homebrew emulators List of homebrew games List of homebrew_loaders List of PC utilities List of system tools Mupen64-360 NandCompare NANDPro PCSXR Xenon PC Software Pong Rawflash Run Code SDLQuake Sega Genesis_Plus_GX Sega Master_System_Plus Snes9x-Gx Starting Homebrew Development Tanks 360 UART Utilities XeLL XeLL Reloaded XMENU XMPlayer ZLX Browser","title":"Category: Xbox 360 Homebrew Software"},{"location":"Category_Xbox360_Linux/","text":"Category: Xbox 360 Linux Debian-etch Debian-lenny Debian-squeeze Lflash Linux Distros Linux Kernel Linux Kernel Development List of Unix Distributions LiveCD Ubuntu Ubuntu 11.10 Ubuntu 7.10 Xenos Framebuffer","title":"Linux"},{"location":"Category_Xbox360_Linux/#category-xbox-360-linux","text":"Debian-etch Debian-lenny Debian-squeeze Lflash Linux Distros Linux Kernel Linux Kernel Development List of Unix Distributions LiveCD Ubuntu Ubuntu 11.10 Ubuntu 7.10 Xenos Framebuffer","title":"Category: Xbox 360 Linux"},{"location":"Category_Xbox360_System_Software/","text":"Category: Xbox 360 System Software 849x System Update Boot Process Console Security Certificate Error Codes FATX FMIM Fusesets GDFX GPD Kernel Kernel Exports NAND Bad Blocks NAND File System PEC Pre-release differences Profile Account Reset Glitch Hack SFCX Shadowboot SMC Hack SPA STFS Xbox System Software XCP XDBF XDK Kernel XEX","title":"System Software"},{"location":"Category_Xbox360_System_Software/#category-xbox-360-system-software","text":"849x System Update Boot Process Console Security Certificate Error Codes FATX FMIM Fusesets GDFX GPD Kernel Kernel Exports NAND Bad Blocks NAND File System PEC Pre-release differences Profile Account Reset Glitch Hack SFCX Shadowboot SMC Hack SPA STFS Xbox System Software XCP XDBF XDK Kernel XEX","title":"Category: Xbox 360 System Software"},{"location":"Chatpad/","text":"Chatpad The Xbox 360 Chatpad is a small keyboard designed to plug into the base of an Xbox 360 Gamepad via the headset jack. It is available in the Xbox 360 Messenger Kit . Category:Xbox360_Hardware","title":"Chatpad"},{"location":"Chatpad/#chatpad","text":"The Xbox 360 Chatpad is a small keyboard designed to plug into the base of an Xbox 360 Gamepad via the headset jack. It is available in the Xbox 360 Messenger Kit . Category:Xbox360_Hardware","title":"Chatpad"},{"location":"Console_Security_Certificate/","text":"Console Security Certificate The Console Security Certificate is used by the Xbox 360 as the format of all RSA signatures generated by it. The total length of the certificate is 552 (0x228) bytes. Structure Offset Length Type Information 0x0 0x2 bytes Public Key Certificate Size 0x2 0x5 bytes Console ID 0x7 0xB ascii string Console Part Number 0x12 0x4 int Reserved 0x16 0x2 short Privileges 0x18 0x4 int Console Type (0x02 for retail, anything different is devkit) 0x1C 0x8 ascii string Certificate Date of Generation 0x24 0x4 bytes Public Exponent 0x28 0x80 bytes Public Modulus 0xA8 0x100 bytes Certificate Signature 0x1A8 0x80 bytes Signature Notes The console type field can be very strange, especially with older pre-1888 dashboards, for example two different 1838 keyvaults identify their console type as 0x80000002. If you want to check if something is devkit or retail, I'd suggest something like: if(consoletype == 0x02) return retail; else return devkit; Category:Xbox360_System_Software","title":"Console Security Certificate"},{"location":"Console_Security_Certificate/#console-security-certificate","text":"The Console Security Certificate is used by the Xbox 360 as the format of all RSA signatures generated by it. The total length of the certificate is 552 (0x228) bytes.","title":"Console Security Certificate"},{"location":"Console_Security_Certificate/#structure","text":"Offset Length Type Information 0x0 0x2 bytes Public Key Certificate Size 0x2 0x5 bytes Console ID 0x7 0xB ascii string Console Part Number 0x12 0x4 int Reserved 0x16 0x2 short Privileges 0x18 0x4 int Console Type (0x02 for retail, anything different is devkit) 0x1C 0x8 ascii string Certificate Date of Generation 0x24 0x4 bytes Public Exponent 0x28 0x80 bytes Public Modulus 0xA8 0x100 bytes Certificate Signature 0x1A8 0x80 bytes Signature","title":"Structure"},{"location":"Console_Security_Certificate/#notes","text":"The console type field can be very strange, especially with older pre-1888 dashboards, for example two different 1838 keyvaults identify their console type as 0x80000002. If you want to check if something is devkit or retail, I'd suggest something like: if(consoletype == 0x02) return retail; else return devkit; Category:Xbox360_System_Software","title":"Notes"},{"location":"Contribute/","text":"Contribute From Free60 We really appreciate your interest in the Free60 Project, and especially your enthusiasm to want to contribute! If you haven't yet, please have a look at our Goals . Eligibility Who can't contribute Unfortunately not everyone can chip in, for example people who have signed an NDA pertaining to the hardware or software used on the Xbox 360 can't as it would break their contract. Who can contribute If you don't meet the above, congratulations! You're eligible to participate in the project. There are still quite a few areas of expertise we are interested in and need information on, so please keep reading! Areas of Opportunity These are a few areas where we can use assistance. Documentation We always need people willing to update and translate all our current documentation, as well as fill in the missing holes. For example, most of the major file systems used on the Xbox 360 have still not fully been explored here. If you want to help contribute to the advancement of Free60 please read on into the Editing the Wiki section. Donations Currently Free60 has no plans to incorporate or provide other such means for easy monetary donations to the project as a whole. If you feel like you have hardware or money that you want to contribute to the project, feel free to donate directly to developers and members. Free60 is not responsible for such donations. Check Stuff we need for a list of items developers are currently seeking. Editing The Wiki This website is a Wiki collection of web pages, whose content may be edited anonymously, over the internet. Care and Feeding Because of it's collaborative and freely-editable nature, writing, updating and maintaining documentation are the most important steps to keeping the system alive. A few guidelines to go by when editing pages on this wiki: Provide accurate information. Write an edit summary for your change. It takes the guess-work out of browsing through the changelog. Avoid duplication. New pages that duplicate already existing information are a bad idea. Work on-top of the existing content to better it instead. Upload only those images that you own. Or at least get permission from the owner to do so. Infringing on someone else's copyright does no one any good, really. Repair and Restoration As a negative side effect, wikis are also a target of and mostly vulnerable to vandalism . Spotting and reverting cases of vandalism can be anywhere from time consuming, to trivial a task. Either way, this is greatly appreciated. Category:Support","title":"Contribute"},{"location":"Contribute/#contribute","text":"","title":"Contribute"},{"location":"Contribute/#from-free60","text":"We really appreciate your interest in the Free60 Project, and especially your enthusiasm to want to contribute! If you haven't yet, please have a look at our Goals .","title":"From Free60"},{"location":"Contribute/#eligibility","text":"","title":"Eligibility"},{"location":"Contribute/#who-cant-contribute","text":"Unfortunately not everyone can chip in, for example people who have signed an NDA pertaining to the hardware or software used on the Xbox 360 can't as it would break their contract.","title":"Who can't contribute"},{"location":"Contribute/#who-can-contribute","text":"If you don't meet the above, congratulations! You're eligible to participate in the project. There are still quite a few areas of expertise we are interested in and need information on, so please keep reading!","title":"Who can contribute"},{"location":"Contribute/#areas-of-opportunity","text":"These are a few areas where we can use assistance.","title":"Areas of Opportunity"},{"location":"Contribute/#documentation","text":"We always need people willing to update and translate all our current documentation, as well as fill in the missing holes. For example, most of the major file systems used on the Xbox 360 have still not fully been explored here. If you want to help contribute to the advancement of Free60 please read on into the Editing the Wiki section.","title":"Documentation"},{"location":"Contribute/#donations","text":"Currently Free60 has no plans to incorporate or provide other such means for easy monetary donations to the project as a whole. If you feel like you have hardware or money that you want to contribute to the project, feel free to donate directly to developers and members. Free60 is not responsible for such donations. Check Stuff we need for a list of items developers are currently seeking.","title":"Donations"},{"location":"Contribute/#editing-the-wiki","text":"This website is a Wiki collection of web pages, whose content may be edited anonymously, over the internet.","title":"Editing The Wiki"},{"location":"Contribute/#care-and-feeding","text":"Because of it's collaborative and freely-editable nature, writing, updating and maintaining documentation are the most important steps to keeping the system alive. A few guidelines to go by when editing pages on this wiki: Provide accurate information. Write an edit summary for your change. It takes the guess-work out of browsing through the changelog. Avoid duplication. New pages that duplicate already existing information are a bad idea. Work on-top of the existing content to better it instead. Upload only those images that you own. Or at least get permission from the owner to do so. Infringing on someone else's copyright does no one any good, really.","title":"Care and Feeding"},{"location":"Contribute/#repair-and-restoration","text":"As a negative side effect, wikis are also a target of and mostly vulnerable to vandalism . Spotting and reverting cases of vandalism can be anywhere from time consuming, to trivial a task. Either way, this is greatly appreciated. Category:Support","title":"Repair and Restoration"},{"location":"Cross_Compiler/","text":"Cross Compiler The Xbox 360 CPU is based on IBM's Power Architecture. Unless you have a machine with PowerPC CPU and Linux running (such as an older Mac or a PS3), you need to set up a cross compiler toolchain in order to compile code like the Linux Kernel for your Xbox 360. A typical cross compiler toolchain for the GNU compiler collection usually consists of three major parts: the GNU binutils package the gcc compiler a implementation of the standard C library (can be left out if you only want to cross compile the Linux kernel) Compiling a compiler on its own platform is already a quite complex task, compiling a compiler for a different platform adds even more caveats as not all versions of binutils, gcc and glibc work together well. Using the Xenon Toolchain The easiest way to set up a complete cross compiler toolchain is the Xenon Toolchain . Its using current gcc and does not take as long as crossotool to compile. Dan Kegel's crosstool An alternative method is to use Dan Kegel's crosstool. Especially the author has already tried lots of combinations of binutils, GCC and glibc to mark the working ones. A complete documentation of crosstool can be found at the crosstool website . For a quick start, we will summarize the instructions from the crosstool-howto: Preparations : Make sure you have the following basic UNIX tools installed (with the variety of Linux distributions available, you never know...): wget tar bzip2 bison flex make gcc & friends (targeting your own platform) Download and unpack the crosstool scripts. E.g. in your home directory type: wget http://kegel.com/crosstool/crosstool-0.43.tar.gz tar -xzvf crosstool-0.43.tar.gz Create the target directories for your cross compilation tools and make them writable for your user. We are using the default which is /opt/crosstool . You will probably need to be root for that so either su before typing these commands and replace $USER with your username or use sudo like in the example: sudo mkdir /opt/crosstool sudo chown $USER /opt/crosstool Run the compilation script for the powerpc target. cd crosstool-0.43/ ./demo-powerpc-970.sh Get a drink , go for a walk or use the time to remove the resistor R6T3 from the mainboard of your Xbox 360... Compilation of your cross compiler will just take a while. When finished , you may want to add your cross compiler binaries to your PATH environment variable. export PATH=$PATH:/opt/crosstool/gcc-4.1.0-glibc-2.3.6/powerpc64-unknown-linux-gnu/bin You're done. Feel free to configure and compile your Linux Kernel . Category:Xbox360_Development","title":"Cross Compiler"},{"location":"Cross_Compiler/#cross-compiler","text":"The Xbox 360 CPU is based on IBM's Power Architecture. Unless you have a machine with PowerPC CPU and Linux running (such as an older Mac or a PS3), you need to set up a cross compiler toolchain in order to compile code like the Linux Kernel for your Xbox 360. A typical cross compiler toolchain for the GNU compiler collection usually consists of three major parts: the GNU binutils package the gcc compiler a implementation of the standard C library (can be left out if you only want to cross compile the Linux kernel) Compiling a compiler on its own platform is already a quite complex task, compiling a compiler for a different platform adds even more caveats as not all versions of binutils, gcc and glibc work together well.","title":"Cross Compiler"},{"location":"Cross_Compiler/#using-the-xenon-toolchain","text":"The easiest way to set up a complete cross compiler toolchain is the Xenon Toolchain . Its using current gcc and does not take as long as crossotool to compile.","title":"Using the Xenon Toolchain"},{"location":"Cross_Compiler/#dan-kegels-crosstool","text":"An alternative method is to use Dan Kegel's crosstool. Especially the author has already tried lots of combinations of binutils, GCC and glibc to mark the working ones. A complete documentation of crosstool can be found at the crosstool website . For a quick start, we will summarize the instructions from the crosstool-howto: Preparations : Make sure you have the following basic UNIX tools installed (with the variety of Linux distributions available, you never know...): wget tar bzip2 bison flex make gcc & friends (targeting your own platform) Download and unpack the crosstool scripts. E.g. in your home directory type: wget http://kegel.com/crosstool/crosstool-0.43.tar.gz tar -xzvf crosstool-0.43.tar.gz Create the target directories for your cross compilation tools and make them writable for your user. We are using the default which is /opt/crosstool . You will probably need to be root for that so either su before typing these commands and replace $USER with your username or use sudo like in the example: sudo mkdir /opt/crosstool sudo chown $USER /opt/crosstool Run the compilation script for the powerpc target. cd crosstool-0.43/ ./demo-powerpc-970.sh Get a drink , go for a walk or use the time to remove the resistor R6T3 from the mainboard of your Xbox 360... Compilation of your cross compiler will just take a while. When finished , you may want to add your cross compiler binaries to your PATH environment variable. export PATH=$PATH:/opt/crosstool/gcc-4.1.0-glibc-2.3.6/powerpc64-unknown-linux-gnu/bin You're done. Feel free to configure and compile your Linux Kernel . Category:Xbox360_Development","title":"Dan Kegel's crosstool"},{"location":"DVD_Drive/","text":"DVD drive The DVD Drive is used by the Xbox 360 for playing games, movies, running executables, listening to music. The firmware of most DVD Drive s can be modified to play backups, or aid in the running of unsigned code. Models There are at least four different types of DVD drives used in the 360: Hitachi-LG GDR-3120L (Multiple ROM revisions) Toshiba/Samsung TS-H943 (MS25 / MS28) BenQ VAD6038 Lite-On DG16D2S The model you get depends on where your Xbox was manufactured, when it was manufactured, what batch it was in and a lot of other factors. General Information Close-up of the custom power connector. The Xbox 360 was launched with a standard dual layer DVD-ROM drive manufactured by Hitachi-LG. The Xbox boots without any error when the DVD-ROM drive's SATA connector and power cable are not connected. However, the power light flashes rapidly, just like when the tray is ejecting. The drive uses the standard 7-pin Serial ATA connectors with a non-standard power connector (2\u00d76 pins, roughly 2mm spacing; Molex Milli-Grid look similar, and Hirose make them, too). Xbox internally calls it \\\\Device\\\\CdRom0\\\\ The raw file system ( XDVDFS ) on the disk is similar to the file system on the original Xbox disks. Multiple tools are out there that will extract raw ISOs. Modified firmware exists for every DVD Drive model, to allow playing backup games. (Unsigned code still can't be run) Two different DVD-ROM versions can be interchanged between Xbox 360s if the DVD key (stored in the drive firmware) is changed to match that of the target 360's original drive. Some Kernel versions (>= 4532?) also require the drive to report as the same model as the original drive. Confirmed Facts Close-up of DVD-Drive Motherboard The main processor of the LG DVD-ROM drive is an Panasonic MN103S94FDA Although present on the disc, The BCA is not used as a security check. The XBOX 360 discs has a fake ToC (Table of Contents), containing only the video section. However, using a hotswap method, we can read a XBOX 360 disc using regular drive. First of all, we need to put a full 8.5GB disc in the drive, then we need to hotswap it by a XBOX 360 disc (without eject, of course). With the right software, there is a way to backup XBOX 360 discs using regular DVD+R DL drive. Speculation A 12X DVD-ROM drive (DVD+R/RW) Single or dual-layer DVDs. The other supported formats are: CD-DA, CD-ROM, CD-R/RW, WMACD, MP3CD, JPEG Photo CD and original Xbox games for backwards compatibility. The DVD-ROM doesn't work on a standard PC workstation, yet. I found a very very thin ring on the underside of my DVD (PGR3). It's located at the inner part of the dvd, it's very very thin so you have to look very sharp for it! Maybe this is the reason why the DVD laser can't read the data part. It reads the video part and then can't \"jump\" over the thin ring to read the data part. On-Disc format the 2 different sections and the BCA area of the DVD-ROM are visible here.360 discs, like Xbox1 discs, have a lower number of sectors encoded in their dvd structure data. This makes it \"impossible\" to access the data after the \"leadout\" (or at least what is specified as leadout). The \"standard\" area has 0xDB0 (~7MB) sectors, and contains DVD-Video data, telling you that this is a game disc. Game data is stored at sector offset 0x1FB20 (LBA), so it's \"after the leadout\". The data itself, however, is stored dvd-compliant (standard ECC, standard seed, standard EDC, standard sector layout. How boring.). If you can get your drive to read past the specified end-of-disc, you can read the game data. A specific sector region, between the standard-data and the beginning of the game data can't be read. I guess this is the \"ring\" which is visible. It probably contains empty/weak sectors (reading really broken frames is always a bit difficult. Someone with the proper equipment might want to check this). Evidence that the BCA is not used by the Xbox 360. The tools which can be used for this are basically the same as for Xbox1, just that the data offset was different there. There are \"scene-tools\" which are of course so top secret that you never heard about them which can do this. They can be hacked for xbox360 (by just modifiying the read offset), and there you go. (Of course the \"how to get your drive's firmware to do this\" is highly off-topic here, but it usually boils down to using debug ATAPI command to write in the drive's memory, then modifiying the drive's idea of the \"end-of-disc\", then using normal read commands. Some others say just opening up the DVD-Rom drive from inside out, Inserting a large DVD, then lifting it up vertically to do not trigger the eject mode, and then inserting a Original XBOX disc will also give you access) Category:Xbox360_Hardware Category:Pages with missing images","title":"DVD drive"},{"location":"DVD_Drive/#dvd-drive","text":"The DVD Drive is used by the Xbox 360 for playing games, movies, running executables, listening to music. The firmware of most DVD Drive s can be modified to play backups, or aid in the running of unsigned code.","title":"DVD drive"},{"location":"DVD_Drive/#models","text":"There are at least four different types of DVD drives used in the 360: Hitachi-LG GDR-3120L (Multiple ROM revisions) Toshiba/Samsung TS-H943 (MS25 / MS28) BenQ VAD6038 Lite-On DG16D2S The model you get depends on where your Xbox was manufactured, when it was manufactured, what batch it was in and a lot of other factors.","title":"Models"},{"location":"DVD_Drive/#general-information","text":"Close-up of the custom power connector. The Xbox 360 was launched with a standard dual layer DVD-ROM drive manufactured by Hitachi-LG. The Xbox boots without any error when the DVD-ROM drive's SATA connector and power cable are not connected. However, the power light flashes rapidly, just like when the tray is ejecting. The drive uses the standard 7-pin Serial ATA connectors with a non-standard power connector (2\u00d76 pins, roughly 2mm spacing; Molex Milli-Grid look similar, and Hirose make them, too). Xbox internally calls it \\\\Device\\\\CdRom0\\\\ The raw file system ( XDVDFS ) on the disk is similar to the file system on the original Xbox disks. Multiple tools are out there that will extract raw ISOs. Modified firmware exists for every DVD Drive model, to allow playing backup games. (Unsigned code still can't be run) Two different DVD-ROM versions can be interchanged between Xbox 360s if the DVD key (stored in the drive firmware) is changed to match that of the target 360's original drive. Some Kernel versions (>= 4532?) also require the drive to report as the same model as the original drive.","title":"General Information"},{"location":"DVD_Drive/#confirmed-facts","text":"Close-up of DVD-Drive Motherboard The main processor of the LG DVD-ROM drive is an Panasonic MN103S94FDA Although present on the disc, The BCA is not used as a security check. The XBOX 360 discs has a fake ToC (Table of Contents), containing only the video section. However, using a hotswap method, we can read a XBOX 360 disc using regular drive. First of all, we need to put a full 8.5GB disc in the drive, then we need to hotswap it by a XBOX 360 disc (without eject, of course). With the right software, there is a way to backup XBOX 360 discs using regular DVD+R DL drive.","title":"Confirmed Facts"},{"location":"DVD_Drive/#speculation","text":"A 12X DVD-ROM drive (DVD+R/RW) Single or dual-layer DVDs. The other supported formats are: CD-DA, CD-ROM, CD-R/RW, WMACD, MP3CD, JPEG Photo CD and original Xbox games for backwards compatibility. The DVD-ROM doesn't work on a standard PC workstation, yet. I found a very very thin ring on the underside of my DVD (PGR3). It's located at the inner part of the dvd, it's very very thin so you have to look very sharp for it! Maybe this is the reason why the DVD laser can't read the data part. It reads the video part and then can't \"jump\" over the thin ring to read the data part.","title":"Speculation"},{"location":"DVD_Drive/#on-disc-format","text":"the 2 different sections and the BCA area of the DVD-ROM are visible here.360 discs, like Xbox1 discs, have a lower number of sectors encoded in their dvd structure data. This makes it \"impossible\" to access the data after the \"leadout\" (or at least what is specified as leadout). The \"standard\" area has 0xDB0 (~7MB) sectors, and contains DVD-Video data, telling you that this is a game disc. Game data is stored at sector offset 0x1FB20 (LBA), so it's \"after the leadout\". The data itself, however, is stored dvd-compliant (standard ECC, standard seed, standard EDC, standard sector layout. How boring.). If you can get your drive to read past the specified end-of-disc, you can read the game data. A specific sector region, between the standard-data and the beginning of the game data can't be read. I guess this is the \"ring\" which is visible. It probably contains empty/weak sectors (reading really broken frames is always a bit difficult. Someone with the proper equipment might want to check this). Evidence that the BCA is not used by the Xbox 360. The tools which can be used for this are basically the same as for Xbox1, just that the data offset was different there. There are \"scene-tools\" which are of course so top secret that you never heard about them which can do this. They can be hacked for xbox360 (by just modifiying the read offset), and there you go. (Of course the \"how to get your drive's firmware to do this\" is highly off-topic here, but it usually boils down to using debug ATAPI command to write in the drive's memory, then modifiying the drive's idea of the \"end-of-disc\", then using normal read commands. Some others say just opening up the DVD-Rom drive from inside out, Inserting a large DVD, then lifting it up vertically to do not trigger the eject mode, and then inserting a Original XBOX disc will also give you access) Category:Xbox360_Hardware Category:Pages with missing images","title":"On-Disc format"},{"location":"Debian-etch/","text":"Install Debian Etch from the Gentoo LiveCD Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Etch debianinstall.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script. How do I run it Click \"Application > Accessories > Terminal\" and type the following commands: Note: Do not use this, use the modified bash code posted at the bottom of this page. sudo su wget https://web.archive.org/web/20121104151039/http://home.comcast.net/~ssmurf/debianinstall.sh sh ./debianinstall.sh Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver. debianinstall.sh #!/bin/bash dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work wget --no-check-certificate https://www.securehost.com/mirror/debian/pool/main/d/debootstrap/debootstrap_0.3.3.2etch1_all.deb ar -xf debootstrap_0.3.3.2etch1_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/debian/usr/lib/debootstrap export PATH=$PATH:/mnt/debian/usr/sbin debootstrap --arch powerpc etch /mnt/debian ftp://archive.debian.org/debian/ echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb archive.debian.org/debian/ etch main contrib non-free EOF #Change root-pwd inside chroot chroot /mnt/debian echo -e \"xbox\\nxbox\" | (passwd --stdin $USER) exit cp /mnt/debian/root/.bashrc /mnt/debian/root/.bashrc.orginal cat >> /mnt/debian/root/.bashrc << EOF passwd apt-get update apt-get install ntp wget -y --force-yes apt-get install x-window-system -y --force-yes aptitude install gnome -y apt-get install build-essential firefox gftp khexedit console-tools -y --force-yes echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ rm -r -f * wget https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so cd /etc/X11/ rm -r -f xorg.conf wget https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so mkdir /lib/modules/2.6.21.1 touch /lib/modules/2.6.21.1/modules.dep echo \"\" > /etc/gdm/gdm.conf-custom sed -i '/security/ a\\AllowRoot=true' /etc/gdm/gdm.conf sed -i 's/#LEDS=+num/LEDS=+num/' /etc/console-tools/config update-rc.d -f hwclock.sh remove update-rc.d -f festival remove update-rc.d -f portmap remove update-rc.d -f cupsys remove update-rc.d -f spamassassin remove update-rc.d -f alsa-utils remove rm /root/.bashrc mv /root/.bashrc.orginal /root/.bashrc /etc/init.d/gdm start EOF echo \"Base System Install Complete!\" echo \"You may now shutdown the xbox360.\" echo \"Then continue the install by booting the Xell-Bootloader-sda2.\" Category:Xbox360_Linux","title":"Install Debian Etch from the Gentoo LiveCD"},{"location":"Debian-etch/#install-debian-etch-from-the-gentoo-livecd","text":"Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Etch debianinstall.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script.","title":"Install Debian Etch from the Gentoo LiveCD"},{"location":"Debian-etch/#how-do-i-run-it","text":"Click \"Application > Accessories > Terminal\" and type the following commands: Note: Do not use this, use the modified bash code posted at the bottom of this page. sudo su wget https://web.archive.org/web/20121104151039/http://home.comcast.net/~ssmurf/debianinstall.sh sh ./debianinstall.sh Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver.","title":"How do I run it"},{"location":"Debian-etch/#debianinstallsh","text":"#!/bin/bash dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work wget --no-check-certificate https://www.securehost.com/mirror/debian/pool/main/d/debootstrap/debootstrap_0.3.3.2etch1_all.deb ar -xf debootstrap_0.3.3.2etch1_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/debian/usr/lib/debootstrap export PATH=$PATH:/mnt/debian/usr/sbin debootstrap --arch powerpc etch /mnt/debian ftp://archive.debian.org/debian/ echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb archive.debian.org/debian/ etch main contrib non-free EOF #Change root-pwd inside chroot chroot /mnt/debian echo -e \"xbox\\nxbox\" | (passwd --stdin $USER) exit cp /mnt/debian/root/.bashrc /mnt/debian/root/.bashrc.orginal cat >> /mnt/debian/root/.bashrc << EOF passwd apt-get update apt-get install ntp wget -y --force-yes apt-get install x-window-system -y --force-yes aptitude install gnome -y apt-get install build-essential firefox gftp khexedit console-tools -y --force-yes echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ rm -r -f * wget https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so cd /etc/X11/ rm -r -f xorg.conf wget https://web.archive.org/web/20141026185511/http://home.comcast.net/~ssmurf/xenosfb_drv.so mkdir /lib/modules/2.6.21.1 touch /lib/modules/2.6.21.1/modules.dep echo \"\" > /etc/gdm/gdm.conf-custom sed -i '/security/ a\\AllowRoot=true' /etc/gdm/gdm.conf sed -i 's/#LEDS=+num/LEDS=+num/' /etc/console-tools/config update-rc.d -f hwclock.sh remove update-rc.d -f festival remove update-rc.d -f portmap remove update-rc.d -f cupsys remove update-rc.d -f spamassassin remove update-rc.d -f alsa-utils remove rm /root/.bashrc mv /root/.bashrc.orginal /root/.bashrc /etc/init.d/gdm start EOF echo \"Base System Install Complete!\" echo \"You may now shutdown the xbox360.\" echo \"Then continue the install by booting the Xell-Bootloader-sda2.\" Category:Xbox360_Linux","title":"debianinstall.sh"},{"location":"Debian-lenny/","text":"Install Debian Lenny from the Gentoo LiveCD Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Lenny lennyinstall.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script. How do I run it Click \"Application > Accessories > Terminal\" and type the following commands: sh sudo su wget https://web.archive.org/web/20141025060051/http://home.comcast.net/~ssmurf/lennyinstall.sh sh ./lennyinstall.sh Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver. Note : Currently unstable, resulted in xorg crashing and there is no network activity. Debian Etch works, same with Ubuntu 7.10. lennyinstall.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work wget `<http://ftp.us.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.23_all.deb> ar -xf debootstrap_1.0.23_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv cp /mnt/debian/usr/sbin/debootstrap /mnt/debian/usr/share/debootstrap export DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap export PATH=$PATH:/mnt/debian/usr/share/debootstrap debootstrap --arch powerpc lenny /mnt/debian `<ftp://mirrors.kernel.org/debian/> echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb `<ftp://mirrors.kernel.org/debian/>` lenny main contrib non-free EOF #Change root-pwd inside chroot chroot /mnt/debian echo -e \"xbox\\nxbox\" | (passwd --stdin $USER) exit cp /mnt/debian/root/.bashrc /mnt/debian/root/.bashrc.orginal cat >> /mnt/debian/root/.bashrc << EOF passwd apt-get update apt-get install ntp wget -y --force-yes apt-get install x-window-system -y --force-yes aptitude install gnome -y apt-get install build-essential firefox gftp khexedit console-tools -y --force-yes cd /usr/lib/xorg/modules/drivers/ rm -r -f * wget `<http://lilstevie.com/assets/xbox360/xenosfb_drv.so> cd /etc/X11/ rm -r -f xorg.conf wget `<https://web.archive.org/web/20141026190741/http://home.comcast.net/~ssmurf/xorg.conf> mkdir /lib/modules/2.6.21.1 touch /lib/modules/2.6.21.1/modules.dep echo \"\" > /etc/gdm/gdm.conf-custom sed -i '/security/ a\\AllowRoot=true' /etc/gdm/gdm.conf sed -i 's/#LEDS=+num/LEDS=+num/' /etc/console-tools/config rm /root/.bashrc mv /root/.bashrc.orginal /root/.bashrc /etc/init.d/gdm start EOF echo \"Base System Install Complete!\" echo \"You may now shutdown the xbox360.\" echo \"Then continue the install by booting the Xell-Bootloader-sda2.\" Category:Xbox360_Linux","title":"Install Debian Lenny from the Gentoo LiveCD"},{"location":"Debian-lenny/#install-debian-lenny-from-the-gentoo-livecd","text":"Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian Lenny lennyinstall.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script.","title":"Install Debian Lenny from the Gentoo LiveCD"},{"location":"Debian-lenny/#how-do-i-run-it","text":"Click \"Application > Accessories > Terminal\" and type the following commands: sh sudo su wget https://web.archive.org/web/20141025060051/http://home.comcast.net/~ssmurf/lennyinstall.sh sh ./lennyinstall.sh Reboot the 360 when you are told. Boot with http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz and login as root. You will be asked for a new password. The rest of the installation will start automatically. The download is about 600Mb. Select xenosfb when the script asks for Xserver-driver. Note : Currently unstable, resulted in xorg crashing and there is no network activity. Debian Etch works, same with Ubuntu 7.10.","title":"How do I run it"},{"location":"Debian-lenny/#lennyinstallsh","text":"#!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work wget `<http://ftp.us.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.23_all.deb> ar -xf debootstrap_1.0.23_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv cp /mnt/debian/usr/sbin/debootstrap /mnt/debian/usr/share/debootstrap export DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap export PATH=$PATH:/mnt/debian/usr/share/debootstrap debootstrap --arch powerpc lenny /mnt/debian `<ftp://mirrors.kernel.org/debian/> echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb `<ftp://mirrors.kernel.org/debian/>` lenny main contrib non-free EOF #Change root-pwd inside chroot chroot /mnt/debian echo -e \"xbox\\nxbox\" | (passwd --stdin $USER) exit cp /mnt/debian/root/.bashrc /mnt/debian/root/.bashrc.orginal cat >> /mnt/debian/root/.bashrc << EOF passwd apt-get update apt-get install ntp wget -y --force-yes apt-get install x-window-system -y --force-yes aptitude install gnome -y apt-get install build-essential firefox gftp khexedit console-tools -y --force-yes cd /usr/lib/xorg/modules/drivers/ rm -r -f * wget `<http://lilstevie.com/assets/xbox360/xenosfb_drv.so> cd /etc/X11/ rm -r -f xorg.conf wget `<https://web.archive.org/web/20141026190741/http://home.comcast.net/~ssmurf/xorg.conf> mkdir /lib/modules/2.6.21.1 touch /lib/modules/2.6.21.1/modules.dep echo \"\" > /etc/gdm/gdm.conf-custom sed -i '/security/ a\\AllowRoot=true' /etc/gdm/gdm.conf sed -i 's/#LEDS=+num/LEDS=+num/' /etc/console-tools/config rm /root/.bashrc mv /root/.bashrc.orginal /root/.bashrc /etc/init.d/gdm start EOF echo \"Base System Install Complete!\" echo \"You may now shutdown the xbox360.\" echo \"Then continue the install by booting the Xell-Bootloader-sda2.\" Category:Xbox360_Linux","title":"lennyinstall.sh"},{"location":"Debian-squeeze/","text":"Install Debian 6 \"Squeeze\" from a Linux LiveCD Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian 6 If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing. debian_squeeze.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script. How do I run it? Click \"Application > Accessories > Terminal\" and type the following commands: sh sudo su wget `<http://file.libxenon.org/free60/linux/script/debian_squeeze.sh> sh ./debian_squeeze.sh Reboot the 360 when you are told. Boot with (Linux kernel binary)[http://file.libxenon.org/latest_kern>], supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.) debootstrapping script debian_squeeze.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 # if /dev/sda is mounted then paritions get wiped by dd but sfdisk fails! swapoff /dev/sda1 umount /mnt/debian # partition and mkfs hdd (all data is lost!) dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF dd if=/dev/zero of=/dev/sda2 bs=512 count=1 mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 # setup paths mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work # download extract and run debootstrap wget http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb ar -xf debootstrap_1.0.38_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap export PATH=$PATH:/mnt/debian/usr/sbin debootstrap --arch powerpc squeeze /mnt/debian ftp://mirrors.kernel.org/debian/ # create needed files on hdd echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb ftp://mirrors.kernel.org/debian/>squeeze main contrib non-free EOF #Change root-pwd to \"xbox\" inside chroot chroot /mnt/debian echo \"root:xbox\" | chroot /mnt/debian /usr/sbin/chpasswd # Add user: xbox with password: xbox chroot /mnt/debian /usr/sbin/useradd -m -d /home/xbox -p paRRy2CC47LXY xbox # create .second_stage script on hdd cat >> /mnt/debian/root/.second_stage << EOF #!/bin/bash date -s 1/1/2009 apt-get update apt-get install ntp wget openssh-server locales -y --force-yes dpkg-reconfigure locales apt-get install gnome -y echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ wget -O xenosfb_drv.so http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_squeeze cd /etc/X11/ wget http://file.libxenon.org/free60/linux/xenosfb/xorg.conf rm -r -f /work/ echo \"Installation completed.\" echo \"To boot the system: Reboot and load the kernel with correct root= params.\" echo \"You should be greeted by a fresh install of Debian 6 Squeeze\" EOF chmod a+x /mnt/debian/root/.second_stage # Execute second part of installation in the chroot environment mount -t proc none /mnt/debian/proc mount --rbind /dev /mnt/debian/dev cp -L /etc/resolv.conf /mnt/debian/etc/resolv.conf chroot /mnt/debian /root/.second_stage umount /mnt/debian/dev /mnt/debian/proc /mnt/debian Fix possible xorg fail After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type, sudo dpkg-reconfigure xserver-xorg Then follow the instructions below. Attempt to autodetect video hardware? > No X Server Driver: Xenosfb Generic Video Card > Enter Video card\u2019s bus identifier: Press enter for default Amount of memory: Press enter for default Use kernel framebuffer device interface? > Yes Autodetect keyboard layout? > Yes Keyboard layout: us XKB rule set to use: xorg Keyboard model: choose your rule set based on the options Keyboard variant: leave blank if you\u2019re in the U.S. Keyboard options: Leave as default Mouse Protocol: ImPS/2 Emulate a 3 button mouse? > Your choice Xorg server modules: Default Write default Files section to configuration file? > Yes Attempt monitor detection? > Yes Use generic monitor if it doesn\u2019t detect it. Video modes to be used by the X server: 1280x768 (1024x768 if garbled) Method for selecting the monitor characteristics: Medium Monitors best video mode: Choose what\u2019s best for your monitor. Write monitor sync ranges to the configuration file? > Yes Desired default color depth in bits: 24. After that go back to gnome by typing Ctrl+Alt+F7 . Reboot X by typing Ctrl+Alt+Backspace . Category:Xbox360_Linux","title":"Install Debian 6 \"Squeeze\" from a Linux LiveCD"},{"location":"Debian-squeeze/#install-debian-6-squeeze-from-a-linux-livecd","text":"Warning : This script will WIPE your Xbox 360 harddisk (/dev/sda) and install Debian 6 If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing. debian_squeeze.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script.","title":"Install Debian 6 \"Squeeze\" from a Linux LiveCD"},{"location":"Debian-squeeze/#how-do-i-run-it","text":"Click \"Application > Accessories > Terminal\" and type the following commands: sh sudo su wget `<http://file.libxenon.org/free60/linux/script/debian_squeeze.sh> sh ./debian_squeeze.sh Reboot the 360 when you are told. Boot with (Linux kernel binary)[http://file.libxenon.org/latest_kern>], supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.)","title":"How do I run it?"},{"location":"Debian-squeeze/#debootstrapping-script","text":"debian_squeeze.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 # if /dev/sda is mounted then paritions get wiped by dd but sfdisk fails! swapoff /dev/sda1 umount /mnt/debian # partition and mkfs hdd (all data is lost!) dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF dd if=/dev/zero of=/dev/sda2 bs=512 count=1 mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 # setup paths mkdir /mnt/debian mount /dev/sda2 /mnt/debian cd /mnt/debian mkdir /mnt/debian/work cd /mnt/debian/work # download extract and run debootstrap wget http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb ar -xf debootstrap_1.0.38_all.deb cd /mnt/debian zcat < /mnt/debian/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/debian/usr/share/debootstrap export PATH=$PATH:/mnt/debian/usr/sbin debootstrap --arch powerpc squeeze /mnt/debian ftp://mirrors.kernel.org/debian/ # create needed files on hdd echo Xenon > /mnt/debian/etc/hostname cat > /mnt/debian/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/debian/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/debian/etc/apt/sources.list << EOF deb ftp://mirrors.kernel.org/debian/>squeeze main contrib non-free EOF #Change root-pwd to \"xbox\" inside chroot chroot /mnt/debian echo \"root:xbox\" | chroot /mnt/debian /usr/sbin/chpasswd # Add user: xbox with password: xbox chroot /mnt/debian /usr/sbin/useradd -m -d /home/xbox -p paRRy2CC47LXY xbox # create .second_stage script on hdd cat >> /mnt/debian/root/.second_stage << EOF #!/bin/bash date -s 1/1/2009 apt-get update apt-get install ntp wget openssh-server locales -y --force-yes dpkg-reconfigure locales apt-get install gnome -y echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ wget -O xenosfb_drv.so http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_squeeze cd /etc/X11/ wget http://file.libxenon.org/free60/linux/xenosfb/xorg.conf rm -r -f /work/ echo \"Installation completed.\" echo \"To boot the system: Reboot and load the kernel with correct root= params.\" echo \"You should be greeted by a fresh install of Debian 6 Squeeze\" EOF chmod a+x /mnt/debian/root/.second_stage # Execute second part of installation in the chroot environment mount -t proc none /mnt/debian/proc mount --rbind /dev /mnt/debian/dev cp -L /etc/resolv.conf /mnt/debian/etc/resolv.conf chroot /mnt/debian /root/.second_stage umount /mnt/debian/dev /mnt/debian/proc /mnt/debian","title":"debootstrapping script"},{"location":"Debian-squeeze/#fix-possible-xorg-fail","text":"After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type, sudo dpkg-reconfigure xserver-xorg Then follow the instructions below. Attempt to autodetect video hardware? > No X Server Driver: Xenosfb Generic Video Card > Enter Video card\u2019s bus identifier: Press enter for default Amount of memory: Press enter for default Use kernel framebuffer device interface? > Yes Autodetect keyboard layout? > Yes Keyboard layout: us XKB rule set to use: xorg Keyboard model: choose your rule set based on the options Keyboard variant: leave blank if you\u2019re in the U.S. Keyboard options: Leave as default Mouse Protocol: ImPS/2 Emulate a 3 button mouse? > Your choice Xorg server modules: Default Write default Files section to configuration file? > Yes Attempt monitor detection? > Yes Use generic monitor if it doesn\u2019t detect it. Video modes to be used by the X server: 1280x768 (1024x768 if garbled) Method for selecting the monitor characteristics: Medium Monitors best video mode: Choose what\u2019s best for your monitor. Write monitor sync ranges to the configuration file? > Yes Desired default color depth in bits: 24. After that go back to gnome by typing Ctrl+Alt+F7 . Reboot X by typing Ctrl+Alt+Backspace . Category:Xbox360_Linux","title":"Fix possible xorg fail"},{"location":"Dumpana/","text":"Dumpana Dumpana is a tool made by tmbinc for dumping the Xbox's ANA Chip to create new Modesetting for additional Video-Modes. It's a linux tool. Source The source is available on the free60 GIT Repository in the tools section. Category:Xbox360_Development","title":"Dumpana"},{"location":"Dumpana/#dumpana","text":"Dumpana is a tool made by tmbinc for dumping the Xbox's ANA Chip to create new Modesetting for additional Video-Modes. It's a linux tool.","title":"Dumpana"},{"location":"Dumpana/#source","text":"The source is available on the free60 GIT Repository in the tools section. Category:Xbox360_Development","title":"Source"},{"location":"Error_Codes/","text":"Error codes \"System error. Contact Xbox Customer Support.\" General Information E64: Unknown E66: The key of the DVD drive firmware doesn't match the key of the motherboard. E68: HDD Failed to initialize. E74: According to Dennis Mooney (Xbox ATG) on the 360 dev forums E 74 is HSIO Calibration failed. (HSIO is that insanely fast bus between the EDRAM and the Xenos core. It needs to be \"trained\" to be reliable.) E79: Unknown Confirmed facts When the Xbox crashes half way loading a game disc (e.g. Due to bad unreadable sectors half way) It halts itself to a freeze: The Screen which was active, remains. Eject does not do anything USB Devices are no longer working Wireless Controller does not connect Plugging in a USB Controler only lights up Left Corner, and Right Down Corner Unconnected Video Out Cable results in red flash, Reconnecting removes red light The only way to get your box back is to unplug the power cable Speculation Error 79 has been known during obvious signs of graphic corruption. (Overheating?, Power supply insufficient?) Error 79 can occur if the Xbox 360 firmware is corrupt. Error 74 can be fixed by disconnecting and reconnecting the hard drive. This would be in contrast to the Dennis-Mooney-Quote. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"Error codes"},{"location":"Error_Codes/#error-codes","text":"\"System error. Contact Xbox Customer Support.\"","title":"Error codes"},{"location":"Error_Codes/#general-information","text":"E64: Unknown E66: The key of the DVD drive firmware doesn't match the key of the motherboard. E68: HDD Failed to initialize. E74: According to Dennis Mooney (Xbox ATG) on the 360 dev forums E 74 is HSIO Calibration failed. (HSIO is that insanely fast bus between the EDRAM and the Xenos core. It needs to be \"trained\" to be reliable.) E79: Unknown","title":"General Information"},{"location":"Error_Codes/#confirmed-facts","text":"When the Xbox crashes half way loading a game disc (e.g. Due to bad unreadable sectors half way) It halts itself to a freeze: The Screen which was active, remains. Eject does not do anything USB Devices are no longer working Wireless Controller does not connect Plugging in a USB Controler only lights up Left Corner, and Right Down Corner Unconnected Video Out Cable results in red flash, Reconnecting removes red light The only way to get your box back is to unplug the power cable","title":"Confirmed facts"},{"location":"Error_Codes/#speculation","text":"Error 79 has been known during obvious signs of graphic corruption. (Overheating?, Power supply insufficient?) Error 79 can occur if the Xbox 360 firmware is corrupt. Error 74 can be fixed by disconnecting and reconnecting the hard drive. This would be in contrast to the Dennis-Mooney-Quote. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"Speculation"},{"location":"Ethernet/","text":"Ethernet interface The Xbox 360 use all the same Ethernet 10/100 network adapter. WiFi-adapter is missing, but can be purchased separately. For new revisions of consoles (Slim version) Wi-Fi-built module. Controller chip Fast Ethernet (on-board is usually referred to as U1B1 or U1B2) Ethernet Chip ICS1893BF Datasheet Comes from Integrated Circuit Systems, Inc. BCM5241 Datasheet Comes from Integrated Circuit Systems, Inc. Pinout coming soon... WLAN Chip Xbox 360 Slim - Internal Wifi module The Xbox 360 Slim family (Corona/Trinity/Winchester) comes with an internal wifi module. It is connected to the motherboard via USB protocol, it uses 3,3V VCC instead of 5V! Generic info: Wifi Chipset: Marvell 88W8786U-NAP2 Flash: Winbond W25X40BVSNIG (4Mbit / 512kB) USB IDs: 045e:0765 There are different models of this board used: Model 1400, X850272-007, U72H003 GP 800571 REV.0, FCC: C3K1400 Model 1488, X858591-002, Marvell B52 REV 3.0, FCC: C3K1488 Category:Xbox360_Hardware","title":"Ethernet interface"},{"location":"Ethernet/#ethernet-interface","text":"The Xbox 360 use all the same Ethernet 10/100 network adapter. WiFi-adapter is missing, but can be purchased separately. For new revisions of consoles (Slim version) Wi-Fi-built module. Controller chip Fast Ethernet (on-board is usually referred to as U1B1 or U1B2)","title":"Ethernet interface"},{"location":"Ethernet/#ethernet-chip","text":"","title":"Ethernet Chip"},{"location":"Ethernet/#ics1893bf","text":"Datasheet Comes from Integrated Circuit Systems, Inc.","title":"ICS1893BF"},{"location":"Ethernet/#bcm5241","text":"Datasheet Comes from Integrated Circuit Systems, Inc. Pinout coming soon...","title":"BCM5241"},{"location":"Ethernet/#wlan-chip","text":"","title":"WLAN Chip"},{"location":"Ethernet/#xbox-360-slim-internal-wifi-module","text":"The Xbox 360 Slim family (Corona/Trinity/Winchester) comes with an internal wifi module. It is connected to the motherboard via USB protocol, it uses 3,3V VCC instead of 5V! Generic info: Wifi Chipset: Marvell 88W8786U-NAP2 Flash: Winbond W25X40BVSNIG (4Mbit / 512kB) USB IDs: 045e:0765 There are different models of this board used: Model 1400, X850272-007, U72H003 GP 800571 REV.0, FCC: C3K1400 Model 1488, X858591-002, Marvell B52 REV 3.0, FCC: C3K1488 Category:Xbox360_Hardware","title":"Xbox 360 Slim - Internal Wifi module"},{"location":"FAQ/","text":"FAQ - Frequently asked questions Whats the status of the project? We can run unsigned code, Linux patches exist and a second level boot loader as well as several LiveCDs have been released. But you still need a first-level boot loader. There are two in the wild, by Crawler360 and xorloser. Both require you to patch the shaders of the Xbox 360 title King Kong. The xorloser loader is probably what you are looking for as it works without soldering a serial cable to the motherboard of your Xbox 360. Is it possible to run unsigned code on the Xbox 360? Yes. Look at Run Code . Which hack should I use for my xbox kernel version? Kernel lower than 2.0.4548: See Timing Attack Kernel up to 2.0.7371: There's a method to run unsigned code if your Dashboard-Version is not higher than 7371. Have a look at SMC Hack Kernel higher than 7371: The new Reset Glitch Hack supports many consoles with recent Kernels Where can I find the latest news? Relevant news items are posted on the front page . For what else has changed on the Wiki, see the recent changes . Will I void my warranty by taking my machine apart? Yes. There is a tamper-proof seal that must be broken to get any further than just removing the faceplate. Doing so automatically voids any warranty you might have had. How can I subscribe to the free60.org mailinglist? Sorry, Mailing Lists aren't available anymore. I have access to official documentation or official developer software/hardware. May I help? No. Contributing any such information would put you in violation of your Non-Disclosure Agreement, while tainting the project at the same time. Note, however, IANAL and TINLA. Category:Support","title":"FAQ - Frequently asked questions"},{"location":"FAQ/#faq-frequently-asked-questions","text":"Whats the status of the project? We can run unsigned code, Linux patches exist and a second level boot loader as well as several LiveCDs have been released. But you still need a first-level boot loader. There are two in the wild, by Crawler360 and xorloser. Both require you to patch the shaders of the Xbox 360 title King Kong. The xorloser loader is probably what you are looking for as it works without soldering a serial cable to the motherboard of your Xbox 360. Is it possible to run unsigned code on the Xbox 360? Yes. Look at Run Code . Which hack should I use for my xbox kernel version? Kernel lower than 2.0.4548: See Timing Attack Kernel up to 2.0.7371: There's a method to run unsigned code if your Dashboard-Version is not higher than 7371. Have a look at SMC Hack Kernel higher than 7371: The new Reset Glitch Hack supports many consoles with recent Kernels Where can I find the latest news? Relevant news items are posted on the front page . For what else has changed on the Wiki, see the recent changes . Will I void my warranty by taking my machine apart? Yes. There is a tamper-proof seal that must be broken to get any further than just removing the faceplate. Doing so automatically voids any warranty you might have had. How can I subscribe to the free60.org mailinglist? Sorry, Mailing Lists aren't available anymore. I have access to official documentation or official developer software/hardware. May I help? No. Contributing any such information would put you in violation of your Non-Disclosure Agreement, while tainting the project at the same time. Note, however, IANAL and TINLA. Category:Support","title":"FAQ - Frequently asked questions"},{"location":"FATX/","text":"FATX - Filesystem FATX is the file system used by the Xbox and the Xbox 360, it is unsupported natively by Windows but has some functionality in Linux. Sometimes called \"XTAF\" (due to its little endian header), the file system is derived from the age-old MS-DOS file system and can be considered as a cleaned-up version of it. Note that, while not part of the file system itself, the media which contain this file system do not have a master file table which describes which file system starts where. It is up to the consumer (Xbox 360, geom_xbox360 kernel module](http://www.freebsd.org/cgi/query-pr.cgi?pr=kern/107707) to know this. File System Layout The file system is divided into 4 parts: Header (the BOOT sector on FAT file systems) File allocation table (FAT) Root directory cluster/data region All multi-byte values contained in each part are 1 big-endian. Difference Between Retail and Development Kit HDD The essential difference between retail and devkit HDDs is that devkit HDDs hold a partition table (length of 0x18 bytes) at the start of the drive. The table contains sector and length information for the Content and DEVKIT Partitions (possibly Compatibility partition too). This partition table only exists on Devkit HDDs, retails have the offsets built in to the kernel. USB Drive Layout Unlike the hard disks and memory units that the Xbox 360 originally shipped with, the USB drives which can be Xbox 360-configured contain sets of files located in a hidden \"Xbox360\" folder located in the root of the device. The Data0000-Data0003 files are always present no matter what the device size. The Data0000 file houses the Cache/USB System Extended partitions, device performance information, and device geometry (mainly just the total device size). Data0001 contains the file allocation table for the Data partition, which uses the remaining files. There was some research done in hopes to remove the maximum device size of 16 GB (for Xbox 360 storage) on exploited/development consoles, but it was later discovered that anything a few GB larger than the current maximum causes the console to crash. http://www.xboxhacker.org/index.php?topic=16913.0 Configuration file The configuration is the first 2 sectors (0x400 bytes) of the Data0000 and is created when the device is configured. It contains info about the device and is secured with a signature. The layout is as follows: Type 1 (Certificate size = 0x228) Offset Length Description 0 0x1A8 Console Security Certificate 0x1A8 0x80 Signature (part of the console cert) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x228) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00) Type 2 (Certificate size = 0x100) Offset Length Description 0 0x100 Device Signature 0x100 0xA8 Padding (0x00) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x100) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00) The signature is derived from a SHA1 hash taken from the start of the device id (0x228) till the end of the config (0x1D8 bytes) and is signed with the consoles private key and the matching public parameters are present in the console certificate for verification later on. The certificate size is used to determine how to verify the configuration file when the device is mounted. If the value is 0x228 then the device was configured by an Xbox and the signature is verified using the params in the console certificate, if the value is 0x100 then the device was pre-configured by Microsoft and is verified using the SATA public key (also used for HDDSS verification). The last 2 values are written when the device is configured, it is unknown how these are used later on. Perhaps it could be used to determine what connected device would provide best performance for caching. Partition Header For each offset, add the offset of the partition. Offset Length Type Information 0x0 0x4 ascii string Partition magic (XTAF) 0x4 0x4 unsigned int Partition ID 0x8 0x4 unsigned int Sectors per Cluster 0xC 0x4 unsigned int Root directory cluster SysExt Partition The SystemUpdate with Kernel-Version 2.0.12611.0 (Kinect-Dashboard) introduced a new system to hold the Kinect-/Avatar related systemfiles. It creates a Partition named \"SysExt\" aka SystemExtended to store these files. You could call it a Sub-Partition or Hidden-Partition as it's a \"Partition inside another Partition\". Partition Locations Memory Unit Offset Length Information Format 0x0 0x7FF000 System Cache SFCX 0x7FF000 end of drive Data FATX Xbox 360 Hard Drive Offset Length Information Format 0x2000 0x204 - 0x80000 Security Sector Binary 0x80000 0x80000000 System Cache SFCX 0x80080000 0xA0E30000 Game Cache SFCX 0x10C080000 0xCE30000 SysExt FATX (\"Sub\"-Partition) 0x118EB0000 0x8000000 SysExt2 FATX (\"Sub\"-Partition) 0x120eb0000 0x10000000 Xbox 1 Backwards Compatibility FATX 0x130eb0000 end of drive Data FATX Development Kit HDD Partition Table Offset Length Information Value 0x0 0x4 HDD Header (Devkit identification) 0x00020000 0x4 0x4 ? ? 0x8 0x4 Content Volume sector 0x00633000 (Raw address: 0xC6600000 = 0x633000 * 0x200) 0xC 0x4 Content Volume length (in sectors) variable (real length = var * 0x200) 0x10 0x4 Xbox 360 Dashboard Volume sector 0x005B3000 (Raw address: 0xB6600000 = 0x5B3000 * 0x200) 0x14 0x4 Xbox 360 Dashboard Volume length (in sectors) 0x00080000 (0x10000000 = 0x80000 * 0x200) USB Drive Offset Length Information Format 0x8000400 0x12000400 System Cache FATX 0x8115200 0x8000000 SysExt (\"Sub\"-Partition) FATX 0x12000400 0xDFFFC00 SysExt2 (\"Sub\"-Partition) FATX 0x20000000 End of Files Data FATX \"Josh\" Sector The \"Josh\" Sector is located on the 4th sector (0x800). It's purpose is currently unknown. It may be used just to identify the Xbox that previously formatted it. Offset Length Type Information 0x0 0x4 ascii string \"Josh\" magic The Console Security Certificate (Inc 0x80 sig) then, Offset Length Type Information 0x22C 0x24 STFSVolumeDescriptor Cache? 0x250 0x24 STFSVolumeDescriptor Cache? 0x274 0x4 (un?)signed int Unknown 0x278 0x4 (un?)signed int Unknown 0x27C 0x4 unsigned int TitleID(for the first VolumeDescriptor) 0x280 0x4 unsigned int TitleID(for the second VolumeDescriptor) The upper 4 bits in the STFSVolumeDescriptor.Flags seem to always be set (maybe to signify it is cache) Security Sector The Security Sector is used by Microsoft to verify that the harddrive is an original Microsoft product. The Security Sector holds details such as drive sector count, drive serial number and the Microsoft logo (to stop other companies using it) It begins at the 16th sector on the drive (0x2000). Offset Length Type Information 0x0 0x14 ascii string Serial Number 0x14 0x8 ascii string Firmware Revision 0x1C 0x28 ascii string Model Number 0x44 0x14 bytes MS Logo Hash 0x58 0x4 unsigned int (LITTLE ENDIAN) Number of Sectors on drive 0x5C 0x100 bytes RSA Signature 0x200 0x4 signed int MS Logo Size 0x204 MS Logo Size image MS Logo If a Security Sector from a smaller hard drive is used on a bigger one, the Xbox will only see the number of sectors defined in the Security Sector . Chainmap and directories To find the offset of the chainmap, take the offset of the position and add 4096 (0x1000) to it. Each entry in the chainmap is either an unsigned int or a unsigned short, depending on the number of clusters inside the partition. To work out the cluster size, take the Sectors per Cluster value and multiply it by 512 (0x200). To work out the number of clusters, divide the partitions size by the cluster size and that's have the number of clusters. If the number of clusters is below 65520 (0xFFF0), then the drive uses 2-byte chainmap entries, otherwise it uses 4-byte chainmap entries. The size of the chainmap is the size of the chainmap entries multiplied by the partitions cluster count. To get a clusters offset, you need to work out the offset of the file data area. This is determined by taking the chainmap offset and adding it's size to it. You then simply times the cluster index (minus 1) by the cluster size and add it to the file data offset. To get a clusters chainmap entrys offset, times the cluster index by the chain map entry size and add that to the chainmap offset. Files The file contents is stored per cluster as indicated by the chainmap and the starting cluster (see below). If the file is larger than one cluster, it is stored in multiple clusters. If the length of the file is not a multiple of the cluster size, then the last cluster is only partially used. If the file covers more than 1 cluster, the next cluster must be determined by finding the current cluster's entry in the chainmap and using the value as the next cluster. Directories Directories are stored in a tabular format. Because directories are normal files with the \"directory\" bit set, they are allocated in the FAT and may therefore cover multiple clusters. This makes it possible to have many files in one directory. Each entry of the directory table is 64 bytes long. An entry can be set to all 0xFF bytes, which means that this entry is unused and probably marks the end of the directory contents. Used entries are filled as follows: Offset Type Size Description 0x00 byte 1 File name length, or 0xE5 for deleted files 0x01 byte 1 File Attributes 0x02 ASCII string 0x2A file name, padded with either 0x00 or 0xFF bytes 0x2C unsigned int 4 First cluster of file, null/0x00 for empty files 0x30 (un?)signed int 4 File size 0x34 (un?)signed short? 2 Creation date 0x36 (un?)signed short? 2 Creation time 0x38 (un?)signed short? 2 Last write date 0x3A (un?)signed short? 2 Last write time 0x3C (un?)signed short 2 Last access time 0x3E (un?)signed short 2 Last access time The file flags and the date and time fields are in the same format as the one used in the FAT file system. For time, bits 15-11 represent the hour, 10-5 the minutes, 4-0 the seconds. For date, bits 15-9 are the year, 8-5 are the month, 4-0 are the day. The volume bit is unused, the volume label is instead stored in a file \"name.txt\" in the root directory. The contents of this file is big-endian UTF-16 (Unicode string) starting at offset 0x2 The following characters are found in XTAF file names from actual disk images: 0x20, 0x24, 0x2e ( SPACE $ . ) 0x30-0x39 (digits 0-9) 0x41-0x5a (letters A-Z) 0x5f ( _ ) 0x61-0x7a (letters a-z) Unlike the FAT file system, XTAF has no \".\" and \"..\" entries in the directory tables. This means that it's only possible to go to the parent directory by remembering its cluster number. Limitations Attribute Limitation Maximum Filename Length 0x2A (42) Maximum Path Length 240 Characters Maximum File Size 4 GB (4294967296 bytes) Maximum File Per Directory 0x1000 (4096) File/Folder Name Characters ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 Possible cluster sizes 4 KB (0x1000 bytes, 0x8 sectors per cluster) 8 KB (0x2000, 0x10 SPC) 16 KB (0x4000, 0x20 SPC) 32 KB (0x8000, 0x40 SPC) 64 KB (0x10000, 0x80 SPC) Category:Xbox360_System_Software","title":"FATX - Filesystem"},{"location":"FATX/#fatx-filesystem","text":"FATX is the file system used by the Xbox and the Xbox 360, it is unsupported natively by Windows but has some functionality in Linux. Sometimes called \"XTAF\" (due to its little endian header), the file system is derived from the age-old MS-DOS file system and can be considered as a cleaned-up version of it. Note that, while not part of the file system itself, the media which contain this file system do not have a master file table which describes which file system starts where. It is up to the consumer (Xbox 360, geom_xbox360 kernel module](http://www.freebsd.org/cgi/query-pr.cgi?pr=kern/107707) to know this.","title":"FATX - Filesystem"},{"location":"FATX/#file-system-layout","text":"The file system is divided into 4 parts: Header (the BOOT sector on FAT file systems) File allocation table (FAT) Root directory cluster/data region All multi-byte values contained in each part are 1 big-endian.","title":"File System Layout"},{"location":"FATX/#difference-between-retail-and-development-kit-hdd","text":"The essential difference between retail and devkit HDDs is that devkit HDDs hold a partition table (length of 0x18 bytes) at the start of the drive. The table contains sector and length information for the Content and DEVKIT Partitions (possibly Compatibility partition too). This partition table only exists on Devkit HDDs, retails have the offsets built in to the kernel.","title":"Difference Between Retail and Development Kit HDD"},{"location":"FATX/#usb-drive-layout","text":"Unlike the hard disks and memory units that the Xbox 360 originally shipped with, the USB drives which can be Xbox 360-configured contain sets of files located in a hidden \"Xbox360\" folder located in the root of the device. The Data0000-Data0003 files are always present no matter what the device size. The Data0000 file houses the Cache/USB System Extended partitions, device performance information, and device geometry (mainly just the total device size). Data0001 contains the file allocation table for the Data partition, which uses the remaining files. There was some research done in hopes to remove the maximum device size of 16 GB (for Xbox 360 storage) on exploited/development consoles, but it was later discovered that anything a few GB larger than the current maximum causes the console to crash. http://www.xboxhacker.org/index.php?topic=16913.0","title":"USB Drive Layout"},{"location":"FATX/#configuration-file","text":"The configuration is the first 2 sectors (0x400 bytes) of the Data0000 and is created when the device is configured. It contains info about the device and is secured with a signature. The layout is as follows:","title":"Configuration file"},{"location":"FATX/#type-1-certificate-size-0x228","text":"Offset Length Description 0 0x1A8 Console Security Certificate 0x1A8 0x80 Signature (part of the console cert) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x228) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00)","title":"Type 1 (Certificate size = 0x228)"},{"location":"FATX/#type-2-certificate-size-0x100","text":"Offset Length Description 0 0x100 Device Signature 0x100 0xA8 Padding (0x00) 0x228 0x14 Device ID 0x23C 4 (UINT32) Certificate size (0x100) 0x240 8 (UINT64) Size of device in bytes 0x248 2 (UINT16) Read speed in KBs 0x24A 2 (UINT16) Write speed in KBs 0x24C 0x1B4 Padding (0x00) The signature is derived from a SHA1 hash taken from the start of the device id (0x228) till the end of the config (0x1D8 bytes) and is signed with the consoles private key and the matching public parameters are present in the console certificate for verification later on. The certificate size is used to determine how to verify the configuration file when the device is mounted. If the value is 0x228 then the device was configured by an Xbox and the signature is verified using the params in the console certificate, if the value is 0x100 then the device was pre-configured by Microsoft and is verified using the SATA public key (also used for HDDSS verification). The last 2 values are written when the device is configured, it is unknown how these are used later on. Perhaps it could be used to determine what connected device would provide best performance for caching.","title":"Type 2 (Certificate size = 0x100)"},{"location":"FATX/#partition-header","text":"For each offset, add the offset of the partition. Offset Length Type Information 0x0 0x4 ascii string Partition magic (XTAF) 0x4 0x4 unsigned int Partition ID 0x8 0x4 unsigned int Sectors per Cluster 0xC 0x4 unsigned int Root directory cluster","title":"Partition Header"},{"location":"FATX/#sysext-partition","text":"The SystemUpdate with Kernel-Version 2.0.12611.0 (Kinect-Dashboard) introduced a new system to hold the Kinect-/Avatar related systemfiles. It creates a Partition named \"SysExt\" aka SystemExtended to store these files. You could call it a Sub-Partition or Hidden-Partition as it's a \"Partition inside another Partition\".","title":"SysExt Partition"},{"location":"FATX/#partition-locations","text":"","title":"Partition Locations"},{"location":"FATX/#memory-unit","text":"Offset Length Information Format 0x0 0x7FF000 System Cache SFCX 0x7FF000 end of drive Data FATX","title":"Memory Unit"},{"location":"FATX/#xbox-360-hard-drive","text":"Offset Length Information Format 0x2000 0x204 - 0x80000 Security Sector Binary 0x80000 0x80000000 System Cache SFCX 0x80080000 0xA0E30000 Game Cache SFCX 0x10C080000 0xCE30000 SysExt FATX (\"Sub\"-Partition) 0x118EB0000 0x8000000 SysExt2 FATX (\"Sub\"-Partition) 0x120eb0000 0x10000000 Xbox 1 Backwards Compatibility FATX 0x130eb0000 end of drive Data FATX","title":"Xbox 360 Hard Drive"},{"location":"FATX/#development-kit-hdd-partition-table","text":"Offset Length Information Value 0x0 0x4 HDD Header (Devkit identification) 0x00020000 0x4 0x4 ? ? 0x8 0x4 Content Volume sector 0x00633000 (Raw address: 0xC6600000 = 0x633000 * 0x200) 0xC 0x4 Content Volume length (in sectors) variable (real length = var * 0x200) 0x10 0x4 Xbox 360 Dashboard Volume sector 0x005B3000 (Raw address: 0xB6600000 = 0x5B3000 * 0x200) 0x14 0x4 Xbox 360 Dashboard Volume length (in sectors) 0x00080000 (0x10000000 = 0x80000 * 0x200)","title":"Development Kit HDD Partition Table"},{"location":"FATX/#usb-drive","text":"Offset Length Information Format 0x8000400 0x12000400 System Cache FATX 0x8115200 0x8000000 SysExt (\"Sub\"-Partition) FATX 0x12000400 0xDFFFC00 SysExt2 (\"Sub\"-Partition) FATX 0x20000000 End of Files Data FATX","title":"USB Drive"},{"location":"FATX/#josh-sector","text":"The \"Josh\" Sector is located on the 4th sector (0x800). It's purpose is currently unknown. It may be used just to identify the Xbox that previously formatted it. Offset Length Type Information 0x0 0x4 ascii string \"Josh\" magic The Console Security Certificate (Inc 0x80 sig) then, Offset Length Type Information 0x22C 0x24 STFSVolumeDescriptor Cache? 0x250 0x24 STFSVolumeDescriptor Cache? 0x274 0x4 (un?)signed int Unknown 0x278 0x4 (un?)signed int Unknown 0x27C 0x4 unsigned int TitleID(for the first VolumeDescriptor) 0x280 0x4 unsigned int TitleID(for the second VolumeDescriptor) The upper 4 bits in the STFSVolumeDescriptor.Flags seem to always be set (maybe to signify it is cache)","title":"\"Josh\" Sector"},{"location":"FATX/#security-sector","text":"The Security Sector is used by Microsoft to verify that the harddrive is an original Microsoft product. The Security Sector holds details such as drive sector count, drive serial number and the Microsoft logo (to stop other companies using it) It begins at the 16th sector on the drive (0x2000). Offset Length Type Information 0x0 0x14 ascii string Serial Number 0x14 0x8 ascii string Firmware Revision 0x1C 0x28 ascii string Model Number 0x44 0x14 bytes MS Logo Hash 0x58 0x4 unsigned int (LITTLE ENDIAN) Number of Sectors on drive 0x5C 0x100 bytes RSA Signature 0x200 0x4 signed int MS Logo Size 0x204 MS Logo Size image MS Logo If a Security Sector from a smaller hard drive is used on a bigger one, the Xbox will only see the number of sectors defined in the Security Sector .","title":"Security Sector"},{"location":"FATX/#chainmap-and-directories","text":"To find the offset of the chainmap, take the offset of the position and add 4096 (0x1000) to it. Each entry in the chainmap is either an unsigned int or a unsigned short, depending on the number of clusters inside the partition. To work out the cluster size, take the Sectors per Cluster value and multiply it by 512 (0x200). To work out the number of clusters, divide the partitions size by the cluster size and that's have the number of clusters. If the number of clusters is below 65520 (0xFFF0), then the drive uses 2-byte chainmap entries, otherwise it uses 4-byte chainmap entries. The size of the chainmap is the size of the chainmap entries multiplied by the partitions cluster count. To get a clusters offset, you need to work out the offset of the file data area. This is determined by taking the chainmap offset and adding it's size to it. You then simply times the cluster index (minus 1) by the cluster size and add it to the file data offset. To get a clusters chainmap entrys offset, times the cluster index by the chain map entry size and add that to the chainmap offset.","title":"Chainmap and directories"},{"location":"FATX/#files","text":"The file contents is stored per cluster as indicated by the chainmap and the starting cluster (see below). If the file is larger than one cluster, it is stored in multiple clusters. If the length of the file is not a multiple of the cluster size, then the last cluster is only partially used. If the file covers more than 1 cluster, the next cluster must be determined by finding the current cluster's entry in the chainmap and using the value as the next cluster.","title":"Files"},{"location":"FATX/#directories","text":"Directories are stored in a tabular format. Because directories are normal files with the \"directory\" bit set, they are allocated in the FAT and may therefore cover multiple clusters. This makes it possible to have many files in one directory. Each entry of the directory table is 64 bytes long. An entry can be set to all 0xFF bytes, which means that this entry is unused and probably marks the end of the directory contents. Used entries are filled as follows: Offset Type Size Description 0x00 byte 1 File name length, or 0xE5 for deleted files 0x01 byte 1 File Attributes 0x02 ASCII string 0x2A file name, padded with either 0x00 or 0xFF bytes 0x2C unsigned int 4 First cluster of file, null/0x00 for empty files 0x30 (un?)signed int 4 File size 0x34 (un?)signed short? 2 Creation date 0x36 (un?)signed short? 2 Creation time 0x38 (un?)signed short? 2 Last write date 0x3A (un?)signed short? 2 Last write time 0x3C (un?)signed short 2 Last access time 0x3E (un?)signed short 2 Last access time The file flags and the date and time fields are in the same format as the one used in the FAT file system. For time, bits 15-11 represent the hour, 10-5 the minutes, 4-0 the seconds. For date, bits 15-9 are the year, 8-5 are the month, 4-0 are the day. The volume bit is unused, the volume label is instead stored in a file \"name.txt\" in the root directory. The contents of this file is big-endian UTF-16 (Unicode string) starting at offset 0x2 The following characters are found in XTAF file names from actual disk images: 0x20, 0x24, 0x2e ( SPACE $ . ) 0x30-0x39 (digits 0-9) 0x41-0x5a (letters A-Z) 0x5f ( _ ) 0x61-0x7a (letters a-z) Unlike the FAT file system, XTAF has no \".\" and \"..\" entries in the directory tables. This means that it's only possible to go to the parent directory by remembering its cluster number.","title":"Directories"},{"location":"FATX/#limitations","text":"Attribute Limitation Maximum Filename Length 0x2A (42) Maximum Path Length 240 Characters Maximum File Size 4 GB (4294967296 bytes) Maximum File Per Directory 0x1000 (4096) File/Folder Name Characters ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789","title":"Limitations"},{"location":"FATX/#possible-cluster-sizes","text":"4 KB (0x1000 bytes, 0x8 sectors per cluster) 8 KB (0x2000, 0x10 SPC) 16 KB (0x4000, 0x20 SPC) 32 KB (0x8000, 0x40 SPC) 64 KB (0x10000, 0x80 SPC) Category:Xbox360_System_Software","title":"Possible cluster sizes"},{"location":"FMIM/","text":"FMIM files are used by the Xbox 360 \"System Music Player\" to store music ripped from a CD. They are stereo WMA 9.1 files, with one pass CBR (constant bitrate) at 192kbps/44.1kHz. FMIM Header Offset Length Type Information 0x0 0x4 ascii string magic \"FMIM\" / 0x464D494D 0x4 0x8 bytes magic (?) unknown purpose but always 0x100010001 0xC 0x200 unicode string Track Title 0x20C 0x200 unicode string Album Name 0x40C 0x200 unicode string Artist #1 0x60C 0x200 unicode string Artist #2 (reason for duplicate unknown, locale?) 0x80C 0x200 unicode string Genre #1 0xA0C 0x200 unicode string Genre #2 (reason for duplicate unknown, locale?) 0xC0C 0x4 unsigned int Track Length (milliseconds, to nearest second) 0xC10 0x4 unsigned int Track Number on Album (starts from 0x1) 0xC14 0xF4 bytes Unknown, sometimes contains readable text 0xD08 ... (rest of the file) bytes WMA 9.1 file containing audio as described above","title":"FMIM"},{"location":"FMIM/#fmim","text":"","title":"FMIM"},{"location":"FMIM/#header","text":"Offset Length Type Information 0x0 0x4 ascii string magic \"FMIM\" / 0x464D494D 0x4 0x8 bytes magic (?) unknown purpose but always 0x100010001 0xC 0x200 unicode string Track Title 0x20C 0x200 unicode string Album Name 0x40C 0x200 unicode string Artist #1 0x60C 0x200 unicode string Artist #2 (reason for duplicate unknown, locale?) 0x80C 0x200 unicode string Genre #1 0xA0C 0x200 unicode string Genre #2 (reason for duplicate unknown, locale?) 0xC0C 0x4 unsigned int Track Length (milliseconds, to nearest second) 0xC10 0x4 unsigned int Track Number on Album (starts from 0x1) 0xC14 0xF4 bytes Unknown, sometimes contains readable text 0xD08 ... (rest of the file) bytes WMA 9.1 file containing audio as described above","title":"Header"},{"location":"Falcon/","text":"Falcon (Motherboard revision) Falcon is the codename used for the third revision to the Xbox 360's motherboard. Appearing in September 2007, this revision reduced the CPU die size from 90nm to 65nm, and the GPU's eDRAM die size from 90nm to 80nm. Consoles: Arcade, Pro/Premium 20GB & 60GB, Elite 120GB 65nm IBM CPU 90nm ATI GPU 80nm on-chip eDRAM. HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) New CPU Heat sink + the GPU heat sink with heat pipe Fewer voltage regulators, capacitors and inductors Bigger and enhanced CPU cooler RAM removed from bottom of mainboard on later models 3 pin fan connector Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive Opus Opus motherboards started to appear in July 2008, to people who had sent in their RRoD Xenon consoles. The Opus motherboard is essentially a Falcon motherboard, without the HDMI connector, so that they could fit into the original Xenon cases they were shipped in. Consoles: Core, Pro/Premium 20GB Falcon based board 65nm IBM CPU 90nm ATI GPU with 80nm on-chip eDRAM No HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) Updated Heat sinks Falcon CPU cooler Zephyr GPU cooler 3 pin fan connector Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX series DVD-Drive Opus only available from Xenon being repaired by MS Very Rare Category:Xbox360_Hardware","title":"Falcon (Motherboard revision)"},{"location":"Falcon/#falcon-motherboard-revision","text":"Falcon is the codename used for the third revision to the Xbox 360's motherboard. Appearing in September 2007, this revision reduced the CPU die size from 90nm to 65nm, and the GPU's eDRAM die size from 90nm to 80nm. Consoles: Arcade, Pro/Premium 20GB & 60GB, Elite 120GB 65nm IBM CPU 90nm ATI GPU 80nm on-chip eDRAM. HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) New CPU Heat sink + the GPU heat sink with heat pipe Fewer voltage regulators, capacitors and inductors Bigger and enhanced CPU cooler RAM removed from bottom of mainboard on later models 3 pin fan connector Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive","title":"Falcon (Motherboard revision)"},{"location":"Falcon/#opus","text":"Opus motherboards started to appear in July 2008, to people who had sent in their RRoD Xenon consoles. The Opus motherboard is essentially a Falcon motherboard, without the HDMI connector, so that they could fit into the original Xenon cases they were shipped in. Consoles: Core, Pro/Premium 20GB Falcon based board 65nm IBM CPU 90nm ATI GPU with 80nm on-chip eDRAM No HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) Updated Heat sinks Falcon CPU cooler Zephyr GPU cooler 3 pin fan connector Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX series DVD-Drive Opus only available from Xenon being repaired by MS Very Rare Category:Xbox360_Hardware","title":"Opus"},{"location":"Finding_the_right_timing/","text":"Finding the right timing for the reset glitch hack Getting memcmp POST length in ticks First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check. An ARM7 based Olimex LPC-H2148 was used for this task. It could look like that: for(;;) { post = post_read(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); while( post_read() == MEMCMP_POST ); memcmp_post_length=get_tick()-t_start; print(memcmp_post_length); } prev_post=post; } Make sure you note memcmp post length ;) Using random timing over the full POST length Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length. It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = rand() % MEMCMP_POST_LENGTH; while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly. Make sure you note the timing that glitched ;) Refining the timing, accounting for bell-like curve So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = PREV_GLITCH_TIMING - 50 + (rand() % 100); while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve. Make sure ... you got it ;) PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity. Category:Xbox360_Development","title":"Finding the right timing for the reset glitch hack"},{"location":"Finding_the_right_timing/#finding-the-right-timing-for-the-reset-glitch-hack","text":"","title":"Finding the right timing for the reset glitch hack"},{"location":"Finding_the_right_timing/#getting-memcmp-post-length-in-ticks","text":"First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check. An ARM7 based Olimex LPC-H2148 was used for this task. It could look like that: for(;;) { post = post_read(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); while( post_read() == MEMCMP_POST ); memcmp_post_length=get_tick()-t_start; print(memcmp_post_length); } prev_post=post; } Make sure you note memcmp post length ;)","title":"Getting memcmp POST length in ticks"},{"location":"Finding_the_right_timing/#using-random-timing-over-the-full-post-length","text":"Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length. It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = rand() % MEMCMP_POST_LENGTH; while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly. Make sure you note the timing that glitched ;)","title":"Using random timing over the full POST length"},{"location":"Finding_the_right_timing/#refining-the-timing-accounting-for-bell-like-curve","text":"So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = PREV_GLITCH_TIMING - 50 + (rand() % 100); while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve. Make sure ... you got it ;) PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity. Category:Xbox360_Development","title":"Refining the timing, accounting for bell-like curve"},{"location":"Free60_Git_Repository/","text":"Free60 Git repository The Free60 git repository was hosted by sourceforge - it switched to github recently. You can download the latest source with the following commands LibXenon git clone git://github.com/Free60Project/libxenon.git XeLL git clone git://github.com/Free60Project/xell.git For other repositories take a look at the webinterface of github: https://github.com/Free60Project For LibXenon projects - check out the appropriate Github organization: https://github.com/LibxenonProject Category:Xbox360_Development","title":"Free60 Git repository"},{"location":"Free60_Git_Repository/#free60-git-repository","text":"The Free60 git repository was hosted by sourceforge - it switched to github recently. You can download the latest source with the following commands LibXenon git clone git://github.com/Free60Project/libxenon.git XeLL git clone git://github.com/Free60Project/xell.git For other repositories take a look at the webinterface of github: https://github.com/Free60Project For LibXenon projects - check out the appropriate Github organization: https://github.com/LibxenonProject Category:Xbox360_Development","title":"Free60 Git repository"},{"location":"Fusesets/","text":"Understanding the Xbox 360's Fusesets The Xbox 360's Xenon CPU has 768 bits of eFUSE, a technology invented by IBM, and implemented in some of it's processors. eFUSEs are hardware fuses on the CPU, and can be \"blown\" to a binary value (1 being blown, and 0 being un-blown) in the Xbox 360, there are 768 fuses, that make up the fusesets. Though each fuseset can be blown individually, they are blown in groups of 8 to make a hexadecimal value for the CPU key, and fuseline 00, instead of a binary value, which is what XeLL will actually display. Technically, there are only 192 viewable fuses. What They Look Like Once you aquire the fusesets (From either XeLL or dump32 in Linux) they look like this: fuseset 00: C0FFFFFFFFFFFFFF fuseset 01: 0F0F0F0F0F0F0FF0 fuseset 02: 0F00000000000000 fuseset 03: 9FB0174015744DAF fuseset 04: 9FB0174015744DAF fuseset 05: D569BAD6958DAE9D fuseset 06: D569BAD6958DAE9D fuseset 07: FFFF000000000000 fuseset 08: 0000000000000000 fuseset 09: 0000000000000000 fuseset 10: 0000000000000000 fuseset 11: 0000000000000000 Their Real Binary Values If you were actually reading the fuses, they would look like this (0 being an un-burned fuse, and 1 being a burned fuse) There should be 768 ones and zeros here, hence the \"768 Bits\" of eFUSE. This doesn't mean anything, but is just to show how the eFUSE's are actually set up. Fuseset 00: 1100011111111111111 Fuseset 01: 0101010101010110 Fuseset 02: 0100000000000000 Fuseset 03: 1001111110110000000101110100000000010101011101000101000000000000 Fuseset 04: 1001111110110000000101110100000000010101011101000101000000000000 Fuseset 05: 1101010101101001101110101101011010010101100011011011000000000000 Fuseset 06: 1101010101101001101110101101011010010101100011011011000000000000 Fuseset 07: 1111000000000000 Fuseset 08: 0000000000000000 Fuseset 09: 0000000000000000 Fuseset 10: 0000000000000000 Fuseset 11: 0000000000000000 Fusesets 00 and 01 These are burned at the factory, after the console is manufactured, they show whether the console is a devkit or not. They also disable CPU JTAG after the console's flash is programed. Retail fuseset 01: 0F0F0F0F0F0F0FF0 Devkit fuseset 01: 0F0F0F0F0F0F0F0F Fuseset 02 This is the lockdown counter for the 2BL/CB (The 2nd Bootloader, stored in NAND Flash) One of these are burned everytime the console updates it's bootloader (Which isn't very often) this is the reason that there is no way to recover a JTAG that has been updated to 2.0.8***.0, even is you have the CPU key, (2BL is encrypted with the CPU/1BL key, but is signed with Microsoft's private key so you can't change the lockdown counter in the NAND. The bootloader will fail signature checks, and panic) Fusesets 03-06 These make up the CPU key. These start out as all zero's, and are burned presumably at random when the console boots for the first time, they are used to encrypt the keyvault, and the bootloader sections. The CPU key is unique to each console, and is sometimes refered to as the \"per-box key\" To find the CPU key, add fusesets 03, and 05, OR 04 and 06. For example, this console's CPU key would be 9FB0174015744DAFD569BAD6958DAE9D . Fusesets 07-11 These make up the console's \"Lockdown Counter.\" They are blown after each dashboard update starting with the update from 4532/4548 to 4598. They prevent a previous version of the dashboard from being run on an updated console. There are enough eFUSEs in this section for Microsoft to update the console roughly 80 times. The lockdown counter of this console is at FFFF00000..., this means that it has received 4 dashboard updates since 2.0.4548.0 ran on it. Microsoft originally intended to only blow an eFUSE when a system update patched a critical vulnerability (Like the Hypervisor vulnerability in 4532 and 4548) but has now decided to blow an eFUSE with every update since the update to 4598. In the NAND's 6BL(CF) section, there is another lockdown counter that should(Under normal circumstances) match the fuselines on the CPU. If it doesn't match, the console will panic on boot, and will show a RRoD. Now, here's the good part! If we know the CPU key of the console, we can decrypt the 6BL, and change the lockdown counter in the NAND to match the one on the console, and therefore run an older dashboard. Since the 6BL isn't signed with Microsoft's private key, we can edit it as we please, so long as we have our CPU key. Dumping the fusesets This is how the bootloaders do it QWORD getFuseline(DWORD fuse) { if ((fuse * 0x40) < 0x300) return *(QWORD*)0x8000020000020000ULL + ((fuse * 0x40) << 3); return 0; } void DumpFuses() { QWORD fuses[12] = { 0 }; printf(\"Fuses:\\n\"); for (int i = 0; i < 12; i++) { fuses[i] = getFuseline(i); printf(\"Fuse [%02d]: %016llX\\n\", i, fuses[i]); } } Category:Xbox360 System Software Category:Xbox360_Hardware","title":"Understanding the Xbox 360's Fusesets"},{"location":"Fusesets/#understanding-the-xbox-360s-fusesets","text":"The Xbox 360's Xenon CPU has 768 bits of eFUSE, a technology invented by IBM, and implemented in some of it's processors. eFUSEs are hardware fuses on the CPU, and can be \"blown\" to a binary value (1 being blown, and 0 being un-blown) in the Xbox 360, there are 768 fuses, that make up the fusesets. Though each fuseset can be blown individually, they are blown in groups of 8 to make a hexadecimal value for the CPU key, and fuseline 00, instead of a binary value, which is what XeLL will actually display. Technically, there are only 192 viewable fuses.","title":"Understanding the Xbox 360's Fusesets"},{"location":"Fusesets/#what-they-look-like","text":"Once you aquire the fusesets (From either XeLL or dump32 in Linux) they look like this: fuseset 00: C0FFFFFFFFFFFFFF fuseset 01: 0F0F0F0F0F0F0FF0 fuseset 02: 0F00000000000000 fuseset 03: 9FB0174015744DAF fuseset 04: 9FB0174015744DAF fuseset 05: D569BAD6958DAE9D fuseset 06: D569BAD6958DAE9D fuseset 07: FFFF000000000000 fuseset 08: 0000000000000000 fuseset 09: 0000000000000000 fuseset 10: 0000000000000000 fuseset 11: 0000000000000000","title":"What They Look Like"},{"location":"Fusesets/#their-real-binary-values","text":"If you were actually reading the fuses, they would look like this (0 being an un-burned fuse, and 1 being a burned fuse) There should be 768 ones and zeros here, hence the \"768 Bits\" of eFUSE. This doesn't mean anything, but is just to show how the eFUSE's are actually set up. Fuseset 00: 1100011111111111111 Fuseset 01: 0101010101010110 Fuseset 02: 0100000000000000 Fuseset 03: 1001111110110000000101110100000000010101011101000101000000000000 Fuseset 04: 1001111110110000000101110100000000010101011101000101000000000000 Fuseset 05: 1101010101101001101110101101011010010101100011011011000000000000 Fuseset 06: 1101010101101001101110101101011010010101100011011011000000000000 Fuseset 07: 1111000000000000 Fuseset 08: 0000000000000000 Fuseset 09: 0000000000000000 Fuseset 10: 0000000000000000 Fuseset 11: 0000000000000000","title":"Their Real Binary Values"},{"location":"Fusesets/#fusesets-00-and-01","text":"These are burned at the factory, after the console is manufactured, they show whether the console is a devkit or not. They also disable CPU JTAG after the console's flash is programed. Retail fuseset 01: 0F0F0F0F0F0F0FF0 Devkit fuseset 01: 0F0F0F0F0F0F0F0F","title":"Fusesets 00 and 01"},{"location":"Fusesets/#fuseset-02","text":"This is the lockdown counter for the 2BL/CB (The 2nd Bootloader, stored in NAND Flash) One of these are burned everytime the console updates it's bootloader (Which isn't very often) this is the reason that there is no way to recover a JTAG that has been updated to 2.0.8***.0, even is you have the CPU key, (2BL is encrypted with the CPU/1BL key, but is signed with Microsoft's private key so you can't change the lockdown counter in the NAND. The bootloader will fail signature checks, and panic)","title":"Fuseset 02"},{"location":"Fusesets/#fusesets-03-06","text":"These make up the CPU key. These start out as all zero's, and are burned presumably at random when the console boots for the first time, they are used to encrypt the keyvault, and the bootloader sections. The CPU key is unique to each console, and is sometimes refered to as the \"per-box key\" To find the CPU key, add fusesets 03, and 05, OR 04 and 06. For example, this console's CPU key would be 9FB0174015744DAFD569BAD6958DAE9D .","title":"Fusesets 03-06"},{"location":"Fusesets/#fusesets-07-11","text":"These make up the console's \"Lockdown Counter.\" They are blown after each dashboard update starting with the update from 4532/4548 to 4598. They prevent a previous version of the dashboard from being run on an updated console. There are enough eFUSEs in this section for Microsoft to update the console roughly 80 times. The lockdown counter of this console is at FFFF00000..., this means that it has received 4 dashboard updates since 2.0.4548.0 ran on it. Microsoft originally intended to only blow an eFUSE when a system update patched a critical vulnerability (Like the Hypervisor vulnerability in 4532 and 4548) but has now decided to blow an eFUSE with every update since the update to 4598. In the NAND's 6BL(CF) section, there is another lockdown counter that should(Under normal circumstances) match the fuselines on the CPU. If it doesn't match, the console will panic on boot, and will show a RRoD. Now, here's the good part! If we know the CPU key of the console, we can decrypt the 6BL, and change the lockdown counter in the NAND to match the one on the console, and therefore run an older dashboard. Since the 6BL isn't signed with Microsoft's private key, we can edit it as we please, so long as we have our CPU key.","title":"Fusesets 07-11"},{"location":"Fusesets/#dumping-the-fusesets","text":"This is how the bootloaders do it QWORD getFuseline(DWORD fuse) { if ((fuse * 0x40) < 0x300) return *(QWORD*)0x8000020000020000ULL + ((fuse * 0x40) << 3); return 0; } void DumpFuses() { QWORD fuses[12] = { 0 }; printf(\"Fuses:\\n\"); for (int i = 0; i < 12; i++) { fuses[i] = getFuseline(i); printf(\"Fuse [%02d]: %016llX\\n\", i, fuses[i]); } } Category:Xbox360 System Software Category:Xbox360_Hardware","title":"Dumping the fusesets"},{"location":"GDFX/","text":"GDFX Used in Disks and SVOD devices, except when in SVOD format it seems to have extra sectors containing a hash of 2 segments(4098 bytes). Each segment is 2048 bytes. The first segment starts with 440816472(Little endian). The 32nd segment seems to be a descriptor. Offset Length Type Information 0 20 string \"MICROSOFT*XBOX*MEDIA\" 20 4 int Root Sector 24 4 int Root Size 28 8 FileTime Creation Time Directory Offset Length Type Information 0 2 int unk 2 2 int unk 4 4 int Sector 8 4 int Size 12 1 int Flags? 13 1 int namelength 14 namelength string name Dirent Attributes Flag Bitmask READONLY 0x00000001 HIDDEN 0x00000002 SYSTEM 0x00000004 DIRECTORY 0x00000010 ARCHIVE 0x00000020 DEVICE 0x00000040 NORMAL 0x00000080 TEMPORARY 0x00000100 Category:Xbox360_System_Software","title":"GDFX"},{"location":"GDFX/#gdfx","text":"Used in Disks and SVOD devices, except when in SVOD format it seems to have extra sectors containing a hash of 2 segments(4098 bytes). Each segment is 2048 bytes. The first segment starts with 440816472(Little endian). The 32nd segment seems to be a descriptor. Offset Length Type Information 0 20 string \"MICROSOFT*XBOX*MEDIA\" 20 4 int Root Sector 24 4 int Root Size 28 8 FileTime Creation Time","title":"GDFX"},{"location":"GDFX/#directory","text":"Offset Length Type Information 0 2 int unk 2 2 int unk 4 4 int Sector 8 4 int Size 12 1 int Flags? 13 1 int namelength 14 namelength string name","title":"Directory"},{"location":"GDFX/#dirent-attributes","text":"Flag Bitmask READONLY 0x00000001 HIDDEN 0x00000002 SYSTEM 0x00000004 DIRECTORY 0x00000010 ARCHIVE 0x00000020 DEVICE 0x00000040 NORMAL 0x00000080 TEMPORARY 0x00000100 Category:Xbox360_System_Software","title":"Dirent Attributes"},{"location":"GPD/","text":"GPD (Game Profile Data) GPD ( G ame P rofile D ata) files are used by the Xbox 360 to store information inside a profile. They are based on the XDBF format. Profiles are composed of many of these files, each named under their respective titles id (e.g. 4D5307E6.gpd for Halo 3). The dashboard GPD ( FFFE07D1.gpd ) contains information and sync information about all the titles. Entry Table Entry Namespaces Value Description 1 Achievement 2 Image 3 Setting 4 Title 5 String 6 Achievement Security (created by GFWL for offline unlocked achievements?) 6 Avatar Award (360 only, this is only stored with in the [[PEC Entry IDs An ID of 0x100000000 indicates that the entry is a Sync List, an ID of 0x200000000 means its a Sync Data entry. In PEC ( P rofile E mbedded C ontent) files these are changed to 1 and 2. The Settings, Achievements, Title and Assets namespaces each have their own Sync List and Sync Data entries. An ID of 0x8000 is reserved for title information, in the string and image namespaces. For achievements and images the entry id must match the id enclosed in the entry data. Description Value Sync List 0x100000000 Sync Data 0x200000000 Sync List (PEC) PEC Sync Data (PEC) PEC Option Controller Vibration 0x10040003 Title Specific 1 0x63E83FFF Title Specific 2 0x63E83FFE Title Specific 3 0x63E83FFD Gamer Yaxis Inversion 0x10040002 Gamercard Zone 0x10040004 Gamercard Region 0x10040005 Gamercard Cred 0x10040006 Gamercard Rep 0x50040011 Option Voice Muted 0x10040012 Option Voice Thru Speakers 0x10040013 Option Voice Thru Speakers Raw 0x10040063 Option Voice Volume 0x10040014 Gamercard Titles Played 0x10040018 Gamercard Achievements Earned 0x10040019 Gamer Difficulty 0x10040021 Gamer Control Sensitivity 0x10040024 Gamer Preferred Color First 0x10040029 Gamer Preferred Color Second 0x10040030 Gamer Action Auto Aim 0x10040034 Gamer Action Auto Center 0x10040035 Gamer Action Movement Control 0x10040036 Gamer Race Transmission 0x10040038 Gamer Race Camera Location 0x10040039 Gamer Race Brake Control 0x10040040 Gamer Race Accelerator Control 0x10040041 Gamercard Title Cred Earned 0x10040056 Gamercard Title Achievements Earned 0x10040057 Avatar Metadata 0x63E80068 Gamercard Picture Key 0x4064000F Gamercard Motto 0x402C0011 Title Information 0x8000 Gamer Name 0x41040040 Gamer Location 0x40520041 Avatar Information 0x63e80044 Avatar Image 0x8007 Setting IDs are largely deterministic, based on there type max length see sample code Entry Structures Achievement Entries Offset Length Type Information 0x0 0x4 unsigned int Struct size (0x1C) 0x4 0x4 unsigned int Achievement ID 0x8 0x4 unsigned int Image ID 0xC 0x4 signed int Gamerscore 0x10 0x4 unsigned int Flags (see below) 0x14 0x8 System.DateTime(signed long) Unlock Time 0x18 null terminated unicode string Name 0x18 + Name length null terminated unicode string Unlocked Description 0x18 + Name length + Locked Description length null terminated unicode string Locked Description Flags public enum AchievementTypes : byte { Completion = 1, Leveling = 2, Unlock = 3, Event = 4, Tournament = 5, Checkpoint = 6, Other = 7, } public System.UInt32 Flags; public AchievementTypes AchievementType { get { return (AchievementTypes)(Flags & 7); } set { if ((System.Byte)value > 7) // to may bits in use :O throw new Exceptions.InvalidAchievement(new System.Exception(\"Invalid Type\")); if (value != Type) { Flags ^= 4294967288; // Null the 3 bits Flags ^= (System.Byte)Type; // set the new } } } public System.Boolean AchievementShowUnachieved // !Sectet { get { return (Flags & 8) == 8; } set { if (value != ShowUnachieved) Flags ^= 8; } } public System.Boolean AchievementEarnedOnline { get { return (Flags & 65536) == 65536; } set { if (value != AchievementEarnedOnline) Flags ^= 65536; } } public System.Boolean AchievementEarned { get { return (Flags & 131072) == 131072; } set { if (value != Achieved) Flags ^= 131072; } } public System.Boolean Edited //? { get { return (Flags & 1048576) == 1048576; } set { if (value != Edited) { Flags ^= 1048576; } } } Setting Entries Offset Length Type Information 0 4 Int32 SettingID 4 2 UInt16 DOS Time(Last edited?) 6 2 UInt16 Unknown 8 1 Byte DataType (see Below) 9 7 Byte[] Unknown (always null?) 16 *depends on DataType* *depends on DataType* Data Description Value Context 0 Int32 1 Int64 2 Double 3 (UNI)String 4 Float 5 Binary 6 DateTime 7 Null 0xFF With data type string and binary there is a leading Int32 with the length in the data blob. Image Entries Image entries are PNG images. example code: public System.Byte[] Data { get { System.Byte[] TempData; System.IO.MemoryStream TempStream = new System.IO.MemoryStream(); Img.Save(TempStream, System.Drawing.Imaging.ImageFormat.Png); TempData = TempStream.ToArray(); TempStream.Close(); return TempData; } set { System.IO.MemoryStream TempStream = new System.IO.MemoryStream(value); Img = System.Drawing.Image.FromStream(TempStream); TempStream.Close(); } } Title Entries These entries are only located in the FFFE07D1 gpd. To get to them, the id for the XDBF entry is the title ID of the game, and the XDBF entry type is String. For more information see XDBF Offset Length Type Information 0x0 0x4 unsigned int Title ID 0x4 0x4 signed int Achievement Count 0x8 0x4 signed int Achievement Unlocked Count 0xC 0x4 signed int Gamerscore Total 0x10 0x4 signed int Gamerscore Unlocked 0x14 0x1 unsigned byte Unknown 0x15 0x1 unsigned byte Achievement Unlocked Online Count 0x16 0x01 byte Avatar Assets Earned 0x17 0x01 byte Avatar Assets Max 0x18 0x01 byte Male Avatar Assets Earned 0x19 0x01 byte Male Avatar Assets Max 0x1A 0x01 byte Female Avatar Assets Earned 0x1B 0x01 byte Female Avatar Assets Max 0x1C 0x4 unsigned int Flags (see below) 0x20 0x8 signed long Last Played Time 0x28 null terminated unicode string Title Name These are not all the flags, it's just that I don't know the rest. Value Description 0x1 Achievement Unlocked Offline, needs to be synced. 0x2 Achievement Unlocked, image needs to be downloaded. 0x10 Avatar Award Unlocked, needs to be downloaded. 0x20 ? Title images are also available online: // IconURL \"http://image.xboxlive.com/global/t.\" + ID.ToString(\"x8\") + \"/icon/0/8000\" // LargeBoxArtURL \"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") + \"/en-GB/largeboxart.jpg\" // SmallBoxArtURL \"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") + \"/en-GB/smallboxart.jpg\" // BannerURL \"http://avatar.xboxlive.com/global/t.\" + ID.ToString(\"x8\") + \"/marketplace/0/1\" // MarketplaceURL \"http://marketplace.xbox.com/en-US/Title/\" + ID Avatar Award Entries The entries are only supported within the PEC version of the GPD. The images for the avatar awards, are stored in the game GPD for that game. Offset Length Type Information 0 4 int32 Struct size (0x2C) 4 16 System.Guid ID 20 4 UInt32 ImageID 24 4 UInt32 Flags(Same as achievement) 28 8 filetime Unlock Time 36 4 Int32 Subcategory 40 4 UInt32 Unknown 44 Null Terminated Unicode Name 44 + Name length Null Terminated Unicode Unlocked Description 44 + Name length + Locked Description length Null Terminated Unicode Locked Description Image The Image stored in the GPD is stored in the normal GPD however you can grab the image from the server, using the GUID. \"http://download.xboxlive.com/content/4d530914/thumbnails/\" + size + \"/\" + ID.ToString() + \".png\"); // size 64 128 300 \"http://avatar.xboxlive.com/global/t.\" + TitleID + \"/avataritem/\" + ID.ToString() + \"/\" + size // 64 or 128 String Entries String entries are simply a unicode, null terminated string the length could be derived from the entry length. Sync Lists This is a list of \"Sync Items\". You can find the total sync items by, ((SyncList.Length / 16) - 1) Sync Item Offset Length Type Information 0 8 unsigned long EntryID 8 8 unsigned long SyncID Sync Data Offset Length Type Information 0x0 0x8 unsigned long Next Sync ID 0x8 0x8 unsigned long Last Synced ID 0x10 0x8 signed long Last Synced Time IDs in Sync List between last and next are pushed //confirm? Category:Xbox360_System_Software","title":"GPD (Game Profile Data)"},{"location":"GPD/#gpd-game-profile-data","text":"GPD ( G ame P rofile D ata) files are used by the Xbox 360 to store information inside a profile. They are based on the XDBF format. Profiles are composed of many of these files, each named under their respective titles id (e.g. 4D5307E6.gpd for Halo 3). The dashboard GPD ( FFFE07D1.gpd ) contains information and sync information about all the titles.","title":"GPD (Game Profile Data)"},{"location":"GPD/#entry-table","text":"","title":"Entry Table"},{"location":"GPD/#entry-namespaces","text":"Value Description 1 Achievement 2 Image 3 Setting 4 Title 5 String 6 Achievement Security (created by GFWL for offline unlocked achievements?) 6 Avatar Award (360 only, this is only stored with in the [[PEC","title":"Entry Namespaces"},{"location":"GPD/#entry-ids","text":"An ID of 0x100000000 indicates that the entry is a Sync List, an ID of 0x200000000 means its a Sync Data entry. In PEC ( P rofile E mbedded C ontent) files these are changed to 1 and 2. The Settings, Achievements, Title and Assets namespaces each have their own Sync List and Sync Data entries. An ID of 0x8000 is reserved for title information, in the string and image namespaces. For achievements and images the entry id must match the id enclosed in the entry data. Description Value Sync List 0x100000000 Sync Data 0x200000000 Sync List (PEC) PEC Sync Data (PEC) PEC Option Controller Vibration 0x10040003 Title Specific 1 0x63E83FFF Title Specific 2 0x63E83FFE Title Specific 3 0x63E83FFD Gamer Yaxis Inversion 0x10040002 Gamercard Zone 0x10040004 Gamercard Region 0x10040005 Gamercard Cred 0x10040006 Gamercard Rep 0x50040011 Option Voice Muted 0x10040012 Option Voice Thru Speakers 0x10040013 Option Voice Thru Speakers Raw 0x10040063 Option Voice Volume 0x10040014 Gamercard Titles Played 0x10040018 Gamercard Achievements Earned 0x10040019 Gamer Difficulty 0x10040021 Gamer Control Sensitivity 0x10040024 Gamer Preferred Color First 0x10040029 Gamer Preferred Color Second 0x10040030 Gamer Action Auto Aim 0x10040034 Gamer Action Auto Center 0x10040035 Gamer Action Movement Control 0x10040036 Gamer Race Transmission 0x10040038 Gamer Race Camera Location 0x10040039 Gamer Race Brake Control 0x10040040 Gamer Race Accelerator Control 0x10040041 Gamercard Title Cred Earned 0x10040056 Gamercard Title Achievements Earned 0x10040057 Avatar Metadata 0x63E80068 Gamercard Picture Key 0x4064000F Gamercard Motto 0x402C0011 Title Information 0x8000 Gamer Name 0x41040040 Gamer Location 0x40520041 Avatar Information 0x63e80044 Avatar Image 0x8007 Setting IDs are largely deterministic, based on there type max length see sample code","title":"Entry IDs"},{"location":"GPD/#entry-structures","text":"","title":"Entry Structures"},{"location":"GPD/#achievement-entries","text":"Offset Length Type Information 0x0 0x4 unsigned int Struct size (0x1C) 0x4 0x4 unsigned int Achievement ID 0x8 0x4 unsigned int Image ID 0xC 0x4 signed int Gamerscore 0x10 0x4 unsigned int Flags (see below) 0x14 0x8 System.DateTime(signed long) Unlock Time 0x18 null terminated unicode string Name 0x18 + Name length null terminated unicode string Unlocked Description 0x18 + Name length + Locked Description length null terminated unicode string Locked Description","title":"Achievement Entries"},{"location":"GPD/#flags","text":"public enum AchievementTypes : byte { Completion = 1, Leveling = 2, Unlock = 3, Event = 4, Tournament = 5, Checkpoint = 6, Other = 7, } public System.UInt32 Flags; public AchievementTypes AchievementType { get { return (AchievementTypes)(Flags & 7); } set { if ((System.Byte)value > 7) // to may bits in use :O throw new Exceptions.InvalidAchievement(new System.Exception(\"Invalid Type\")); if (value != Type) { Flags ^= 4294967288; // Null the 3 bits Flags ^= (System.Byte)Type; // set the new } } } public System.Boolean AchievementShowUnachieved // !Sectet { get { return (Flags & 8) == 8; } set { if (value != ShowUnachieved) Flags ^= 8; } } public System.Boolean AchievementEarnedOnline { get { return (Flags & 65536) == 65536; } set { if (value != AchievementEarnedOnline) Flags ^= 65536; } } public System.Boolean AchievementEarned { get { return (Flags & 131072) == 131072; } set { if (value != Achieved) Flags ^= 131072; } } public System.Boolean Edited //? { get { return (Flags & 1048576) == 1048576; } set { if (value != Edited) { Flags ^= 1048576; } } }","title":"Flags"},{"location":"GPD/#setting-entries","text":"Offset Length Type Information 0 4 Int32 SettingID 4 2 UInt16 DOS Time(Last edited?) 6 2 UInt16 Unknown 8 1 Byte DataType (see Below) 9 7 Byte[] Unknown (always null?) 16 *depends on DataType* *depends on DataType* Data Description Value Context 0 Int32 1 Int64 2 Double 3 (UNI)String 4 Float 5 Binary 6 DateTime 7 Null 0xFF With data type string and binary there is a leading Int32 with the length in the data blob.","title":"Setting Entries"},{"location":"GPD/#image-entries","text":"Image entries are PNG images. example code: public System.Byte[] Data { get { System.Byte[] TempData; System.IO.MemoryStream TempStream = new System.IO.MemoryStream(); Img.Save(TempStream, System.Drawing.Imaging.ImageFormat.Png); TempData = TempStream.ToArray(); TempStream.Close(); return TempData; } set { System.IO.MemoryStream TempStream = new System.IO.MemoryStream(value); Img = System.Drawing.Image.FromStream(TempStream); TempStream.Close(); } }","title":"Image Entries"},{"location":"GPD/#title-entries","text":"These entries are only located in the FFFE07D1 gpd. To get to them, the id for the XDBF entry is the title ID of the game, and the XDBF entry type is String. For more information see XDBF Offset Length Type Information 0x0 0x4 unsigned int Title ID 0x4 0x4 signed int Achievement Count 0x8 0x4 signed int Achievement Unlocked Count 0xC 0x4 signed int Gamerscore Total 0x10 0x4 signed int Gamerscore Unlocked 0x14 0x1 unsigned byte Unknown 0x15 0x1 unsigned byte Achievement Unlocked Online Count 0x16 0x01 byte Avatar Assets Earned 0x17 0x01 byte Avatar Assets Max 0x18 0x01 byte Male Avatar Assets Earned 0x19 0x01 byte Male Avatar Assets Max 0x1A 0x01 byte Female Avatar Assets Earned 0x1B 0x01 byte Female Avatar Assets Max 0x1C 0x4 unsigned int Flags (see below) 0x20 0x8 signed long Last Played Time 0x28 null terminated unicode string Title Name These are not all the flags, it's just that I don't know the rest. Value Description 0x1 Achievement Unlocked Offline, needs to be synced. 0x2 Achievement Unlocked, image needs to be downloaded. 0x10 Avatar Award Unlocked, needs to be downloaded. 0x20 ? Title images are also available online: // IconURL \"http://image.xboxlive.com/global/t.\" + ID.ToString(\"x8\") + \"/icon/0/8000\" // LargeBoxArtURL \"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") + \"/en-GB/largeboxart.jpg\" // SmallBoxArtURL \"http://tiles.xbox.com/consoleAssets/\" + ID.ToString(\"x8\") + \"/en-GB/smallboxart.jpg\" // BannerURL \"http://avatar.xboxlive.com/global/t.\" + ID.ToString(\"x8\") + \"/marketplace/0/1\" // MarketplaceURL \"http://marketplace.xbox.com/en-US/Title/\" + ID","title":"Title Entries"},{"location":"GPD/#avatar-award-entries","text":"The entries are only supported within the PEC version of the GPD. The images for the avatar awards, are stored in the game GPD for that game. Offset Length Type Information 0 4 int32 Struct size (0x2C) 4 16 System.Guid ID 20 4 UInt32 ImageID 24 4 UInt32 Flags(Same as achievement) 28 8 filetime Unlock Time 36 4 Int32 Subcategory 40 4 UInt32 Unknown 44 Null Terminated Unicode Name 44 + Name length Null Terminated Unicode Unlocked Description 44 + Name length + Locked Description length Null Terminated Unicode Locked Description","title":"Avatar Award Entries"},{"location":"GPD/#image","text":"The Image stored in the GPD is stored in the normal GPD however you can grab the image from the server, using the GUID. \"http://download.xboxlive.com/content/4d530914/thumbnails/\" + size + \"/\" + ID.ToString() + \".png\"); // size 64 128 300 \"http://avatar.xboxlive.com/global/t.\" + TitleID + \"/avataritem/\" + ID.ToString() + \"/\" + size // 64 or 128","title":"Image"},{"location":"GPD/#string-entries","text":"String entries are simply a unicode, null terminated string the length could be derived from the entry length.","title":"String Entries"},{"location":"GPD/#sync-lists","text":"This is a list of \"Sync Items\". You can find the total sync items by, ((SyncList.Length / 16) - 1)","title":"Sync Lists"},{"location":"GPD/#sync-item","text":"Offset Length Type Information 0 8 unsigned long EntryID 8 8 unsigned long SyncID","title":"Sync Item"},{"location":"GPD/#sync-data","text":"Offset Length Type Information 0x0 0x8 unsigned long Next Sync ID 0x8 0x8 unsigned long Last Synced ID 0x10 0x8 signed long Last Synced Time IDs in Sync List between last and next are pushed //confirm? Category:Xbox360_System_Software","title":"Sync Data"},{"location":"GamePad/","text":"Gamepad Speculation ~~Rumors that both the wired gamepad and wireless dongle share the same interface, but probably won't have the same USB device IDs.~~ The last six bytes of the input descriptor are for analog face buttons. The information on the web is contradictory. I know that the controller did have pressure sensitive face buttons originally. Some web sites now say that it does not, so they must have been scrapped. Others say that it still does have them. If it does not the bytes are just a relic, but if the controler does have the analog buttons then there must be some form of toggle mechanism. Pinouts Headset Connector The headset connector is a usual 2.5 mm TRS-Jack and is totally compatible with the old Xbox headset. The pinout is shown below: ___ S R T | '----,-,-. | ,----'-'-' \\ / | | S (Shield): Ground, common for Speaker (-) and Microphone (-) R (Ring): Speaker (+), can be left open T (Tip): Microphone (+), feeds elctret mic, shorten to ground for muting Xbox 360 Wireless Controller Wire Connector (Play'n'Charge Cable) | LT | _______,__,______ | RT | ________ \\ ------------- / _________ LB ___,__,__,___/ RB -------- 1 2 3 4 5 6 7 --------- (View on Controller when turning 90 degrees towards user) Pin Functions: 1 GND (Ground, black wire of USB) 2 Data A (unknown function but likely paired with pin 7) 3 VCC (Supply Voltage, works good with 3.3V, see note! ) 4 Unknown (charge option?) 5 USB D+ (Data Line, greeen wire of USB) 6 USB D- (Data Line, white wire of USB) 7 Data B (unknown, see pin 2) Note: The supply voltage for Memory Units and other Accessories is always 3.3 Volts. The front side USB socket of the Xbox has a supply of 5V as required by standard USB devices like memory sticks or legacy keyboards. Experiments have proven that the Controller works good on Xbox USB port when wired up according to the pinout above and by inserting a 3.3 Volts positive regulator between VUSB (red) and VCC on (pin 3). As written inside the battery slot the Controller might be rated for 5V - if anyone has a spare trash controller he could try it without fear of frying the pad... Category:Xbox360_Hardware","title":"Gamepad"},{"location":"GamePad/#gamepad","text":"","title":"Gamepad"},{"location":"GamePad/#speculation","text":"~~Rumors that both the wired gamepad and wireless dongle share the same interface, but probably won't have the same USB device IDs.~~ The last six bytes of the input descriptor are for analog face buttons. The information on the web is contradictory. I know that the controller did have pressure sensitive face buttons originally. Some web sites now say that it does not, so they must have been scrapped. Others say that it still does have them. If it does not the bytes are just a relic, but if the controler does have the analog buttons then there must be some form of toggle mechanism.","title":"Speculation"},{"location":"GamePad/#pinouts","text":"","title":"Pinouts"},{"location":"GamePad/#headset-connector","text":"The headset connector is a usual 2.5 mm TRS-Jack and is totally compatible with the old Xbox headset. The pinout is shown below: ___ S R T | '----,-,-. | ,----'-'-' \\ / | | S (Shield): Ground, common for Speaker (-) and Microphone (-) R (Ring): Speaker (+), can be left open T (Tip): Microphone (+), feeds elctret mic, shorten to ground for muting","title":"Headset Connector"},{"location":"GamePad/#xbox-360-wireless-controller","text":"Wire Connector (Play'n'Charge Cable) | LT | _______,__,______ | RT | ________ \\ ------------- / _________ LB ___,__,__,___/ RB -------- 1 2 3 4 5 6 7 --------- (View on Controller when turning 90 degrees towards user) Pin Functions: 1 GND (Ground, black wire of USB) 2 Data A (unknown function but likely paired with pin 7) 3 VCC (Supply Voltage, works good with 3.3V, see note! ) 4 Unknown (charge option?) 5 USB D+ (Data Line, greeen wire of USB) 6 USB D- (Data Line, white wire of USB) 7 Data B (unknown, see pin 2) Note: The supply voltage for Memory Units and other Accessories is always 3.3 Volts. The front side USB socket of the Xbox has a supply of 5V as required by standard USB devices like memory sticks or legacy keyboards. Experiments have proven that the Controller works good on Xbox USB port when wired up according to the pinout above and by inserting a 3.3 Volts positive regulator between VUSB (red) and VCC on (pin 3). As written inside the battery slot the Controller might be rated for 5V - if anyone has a spare trash controller he could try it without fear of frying the pad... Category:Xbox360_Hardware","title":"Xbox 360 Wireless Controller"},{"location":"Genesis_Plus/","text":"Genesis Plus emulator General Info Source: http://www.multiupload.com/6QYQL218GB NFO Introduction: Genesis Plus is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles Changelog: v240909: First public release Sound doesn't work as it should .... It support bin and zip file but rom in smd format doesn'work UI updatted and support skinning: Background: uda:/mdbg.png File Icon: uda:/mdfile.png Folder Icon: uda:/mddir.png Contact: [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr Thanks: Tmbinc Jc Relapse And all people in #free60 Authors of Genesis Plus Wii and Dc Charles MacDonald Category:Xbox360_Homebrew_Software","title":"Genesis Plus emulator"},{"location":"Genesis_Plus/#genesis-plus-emulator","text":"","title":"Genesis Plus emulator"},{"location":"Genesis_Plus/#general-info","text":"Source: http://www.multiupload.com/6QYQL218GB","title":"General Info"},{"location":"Genesis_Plus/#nfo","text":"Introduction: Genesis Plus is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles Changelog: v240909: First public release Sound doesn't work as it should .... It support bin and zip file but rom in smd format doesn'work UI updatted and support skinning: Background: uda:/mdbg.png File Icon: uda:/mdfile.png Folder Icon: uda:/mddir.png Contact: [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr Thanks: Tmbinc Jc Relapse And all people in #free60 Authors of Genesis Plus Wii and Dc Charles MacDonald Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"HDD/","text":"General Information The Xbox 360 harddisk with case, Downside The HDD inside its case The HDD outside of its metalcasing The drive is manufactured by Samsung (Seagate Drives have been used in some systems. Unknown if contents are the same) and is required to play backward compatible Xbox games. Samsung details: Model: SAMSUNG HM020GI Revision: YU100-06 Serial Number: S0A8J20YA44356 (of course this is different for every HD) Capacity: 18.63 GB Seagate details: Model: ST920217AS Revision: 3.01/LD25.1 Capacity: 20 GB Hitachi details: Model: HTS541020G9SA00 (Travelstar) Revision: C60D Capacity: 20 GB Vendor Support URL: [1] Confirmed Facts The harddisk is not locked in any way. A completely zero drive will only be read by the Xbox 360 if the relevent headers are in place on the disk. A FATX partition exists on the drive For a drive to be considered valid it must have the 'Plain text HDD info' and MS logo PNG. If these elements do not exist then no HDD is detected. So there is no way for third parties to manufacture HDDs without a license or without infringing Microsoft's copyright. (The Gameboy used the same idea for cartridges). US courts have held (in at least four separate cases) that Copyright cannot be used to prevent interoperation. The 360's serial number is required when formatting a HDD. The drive's capacity is reported as 13GB by the 360 immediately after formatting (20Gb HDD only). Speculation There is no information at this time that leads us to believe the HDD is encrypted, there are plenty of clear text entries that can be read. The FATX partitions on the drive seem to be a Big Endian version of the 1st Generation Xbox's FATX filesystem. Work is underway to modify the Linux kernel driver to verify this. There is some initial support for this file system in [CVS]. Drive contents The Xbox uses the FATX format for its partitions. The FATX page has more information about the partition locations and the FATX format itself. Power connector Pin # Signal Name On XBOX 360 Signal Description 1 V33 Not connected 3.3V Power 2 V33 Not connected 3.3V Power 3 V33 Not connected 3.3V Power, Pre-charge, 2nd mate 4 Ground Connected 1st Mate, Pre-charge, 2nd mate 5 Ground Connected 2nd Mate 6 Ground Connected 3rd Mate 7 V5 Connected 5V Power 8 V5 Connected 5V Power 9 V5 Connected 5V Power 10 Ground Connected 2nd Mate 11 Reserved Not connected - 12 Ground Connected 1st Mate 13 12V Not connected 1st Mate, Pre-charge, 2nd mate 14 12V Not connected 2nd Mate 15 12V Not connected 3rd Mate This (probably) explains why normal 3.5\" sata drives won't even spin up (missing 12V). So if you want to use a 3.5\" drive you need to connect your own 12V. This table plus more info can be found in the electrical specification here . (Table 17, Page 117) External Links http://watertastesgood.com/xbox/delta.py Tool to help do binary diffs of HDD images, courtesy of Daeken [http://www.xbox-linux.org/wiki/Xbox_Partitioning_and_Filesystem_Details] [http://www.xbox-linux.org/wiki/Differences_between_Xbox_FATX_and_MS-DOS_FAT] Category:Xbox360_Hardware","title":"General Information"},{"location":"HDD/#general-information","text":"The Xbox 360 harddisk with case, Downside The HDD inside its case The HDD outside of its metalcasing The drive is manufactured by Samsung (Seagate Drives have been used in some systems. Unknown if contents are the same) and is required to play backward compatible Xbox games.","title":"General Information"},{"location":"HDD/#samsung-details","text":"Model: SAMSUNG HM020GI Revision: YU100-06 Serial Number: S0A8J20YA44356 (of course this is different for every HD) Capacity: 18.63 GB","title":"Samsung details:"},{"location":"HDD/#seagate-details","text":"Model: ST920217AS Revision: 3.01/LD25.1 Capacity: 20 GB","title":"Seagate details:"},{"location":"HDD/#hitachi-details","text":"Model: HTS541020G9SA00 (Travelstar) Revision: C60D Capacity: 20 GB Vendor Support URL: [1]","title":"Hitachi details:"},{"location":"HDD/#confirmed-facts","text":"The harddisk is not locked in any way. A completely zero drive will only be read by the Xbox 360 if the relevent headers are in place on the disk. A FATX partition exists on the drive For a drive to be considered valid it must have the 'Plain text HDD info' and MS logo PNG. If these elements do not exist then no HDD is detected. So there is no way for third parties to manufacture HDDs without a license or without infringing Microsoft's copyright. (The Gameboy used the same idea for cartridges). US courts have held (in at least four separate cases) that Copyright cannot be used to prevent interoperation. The 360's serial number is required when formatting a HDD. The drive's capacity is reported as 13GB by the 360 immediately after formatting (20Gb HDD only).","title":"Confirmed Facts"},{"location":"HDD/#speculation","text":"There is no information at this time that leads us to believe the HDD is encrypted, there are plenty of clear text entries that can be read. The FATX partitions on the drive seem to be a Big Endian version of the 1st Generation Xbox's FATX filesystem. Work is underway to modify the Linux kernel driver to verify this. There is some initial support for this file system in [CVS].","title":"Speculation"},{"location":"HDD/#drive-contents","text":"The Xbox uses the FATX format for its partitions. The FATX page has more information about the partition locations and the FATX format itself.","title":"Drive contents"},{"location":"HDD/#power-connector","text":"Pin # Signal Name On XBOX 360 Signal Description 1 V33 Not connected 3.3V Power 2 V33 Not connected 3.3V Power 3 V33 Not connected 3.3V Power, Pre-charge, 2nd mate 4 Ground Connected 1st Mate, Pre-charge, 2nd mate 5 Ground Connected 2nd Mate 6 Ground Connected 3rd Mate 7 V5 Connected 5V Power 8 V5 Connected 5V Power 9 V5 Connected 5V Power 10 Ground Connected 2nd Mate 11 Reserved Not connected - 12 Ground Connected 1st Mate 13 12V Not connected 1st Mate, Pre-charge, 2nd mate 14 12V Not connected 2nd Mate 15 12V Not connected 3rd Mate This (probably) explains why normal 3.5\" sata drives won't even spin up (missing 12V). So if you want to use a 3.5\" drive you need to connect your own 12V. This table plus more info can be found in the electrical specification here . (Table 17, Page 117)","title":"Power connector"},{"location":"HDD/#external-links","text":"http://watertastesgood.com/xbox/delta.py Tool to help do binary diffs of HDD images, courtesy of Daeken [http://www.xbox-linux.org/wiki/Xbox_Partitioning_and_Filesystem_Details] [http://www.xbox-linux.org/wiki/Differences_between_Xbox_FATX_and_MS-DOS_FAT] Category:Xbox360_Hardware","title":"External Links"},{"location":"Headset/","text":"Headset General Information The Xbox Live Headset Plugs Directly into Xbox 360 Controller. The headset provides for both volume control and muting of the microphone. The old Xbox Live headset will work with the Xbox 360 but volume control must then be done through the dashboard. Category:Xbox360_Hardware","title":"Headset"},{"location":"Headset/#headset","text":"","title":"Headset"},{"location":"Headset/#general-information","text":"The Xbox Live Headset Plugs Directly into Xbox 360 Controller. The headset provides for both volume control and muting of the microphone. The old Xbox Live headset will work with the Xbox 360 but volume control must then be done through the dashboard. Category:Xbox360_Hardware","title":"General Information"},{"location":"Help/","text":"IRC Server \u21d2 irc.oftc.net (irc.oftc.net) Channel \u21d2 #free60 ; #free60-chat ; #free60-dev or if theres nobody replying try: Server \u21d2 irc.efnet.nl Channel \u21d2 #libxenon \\== Want to Help? == Here is what you can do to help this project: Documentation: We need the individual bits\\&pieces, for example from xboxhacker.net, nicely assembled into wiki pages, Howtos etc. This does not require coding skills! Head over to here for a list of pages that need some work done on them. Or you can go here for a list of pages that need images uploaded. Take a look at wiibrew.org: They have nice categories for the available software, features applications etc. Tell more people about what you can do with Linux on the 360. We need more applications so people have a reason to try out free Libxenon based code and Linux on 360. Work to implement End User Requirements Test and improve the Linux live CD images Add useful ideas to this list. Seeking Information On Some documentation must already exist, though perhaps not in the wild. We are seeking: CPU instruction set reference --> See VisualStudio 2005 Reference (Exact CPU instruction set reference) Verification that the CPUs have a memory management unit (can do virtual memory) Details of Multi-processor memory coherency and synchronization requirements Documentation To Develop Some documentation will either not exist, or won't be made available Memory usage map for boot code Hypervisor details. What is checked and how it is checked Chain of trust: how execution integrity is designed to work Chinks in the armor: Holes in the chain of trust Hard drive locking (if any) and filesystem details ( Harddrive ) Wireless hardware and software protocol for controllers Xbox1 software emulation details XeLL / Libxenon [Libxenon]: Improve Libxenon and write apps. [Libxenon]/[XeLL]: Fix the usb driver so it gets proper speed and Power supply does not need to get replugged to get usb mass storage recognized DONE [Libxenon]/[XeLL]: Write a fatx/xtaf driver [XeLL]: Implement parsing of a bootconfig + passing bootarguments to the linux kernel DONE [XeLL]: Fix non-workin XeLL-XeLL implementation (chainload XeLL from a \"base XeLL\") DONE Xenon linux kernel Needs urgent fixing: Linux Kernel - a hardware CPU bug causes powerpc locking primitives to fail between hyper threads unless a special register is set properly Fix usb driver (random freez under heavy usage) Patch RTC driver for hardware clock access Xenosfb: add support for mode switching Audio driver If possible: Modify the ATI 3D driver to work with the Xenos-Chip Linux Live CD / Installer Open a Boot Menu with the following options: Load [Linux Kernel] from HDD (default, 10s timeout? auto detection of valid Linux HDD?) Load [Linux Kernel] from CD and use root filesystem on HDD Load Rescue/Installer Linux LiveCD Load Linux over TFTP (optionally configuring the network) The Menu can either be created in XeLL (requiring reading from CD, SATA, plus interactivity over serial / IR remote or USB controller), or possibly in a Linux initramfs (which is easier to implement, but locks the user in to one single kernel) Category:Support","title":"Help"},{"location":"Help/#irc","text":"Server \u21d2 irc.oftc.net (irc.oftc.net) Channel \u21d2 #free60 ; #free60-chat ; #free60-dev or if theres nobody replying try: Server \u21d2 irc.efnet.nl Channel \u21d2 #libxenon \\== Want to Help? == Here is what you can do to help this project: Documentation: We need the individual bits\\&pieces, for example from xboxhacker.net, nicely assembled into wiki pages, Howtos etc. This does not require coding skills! Head over to here for a list of pages that need some work done on them. Or you can go here for a list of pages that need images uploaded. Take a look at wiibrew.org: They have nice categories for the available software, features applications etc. Tell more people about what you can do with Linux on the 360. We need more applications so people have a reason to try out free Libxenon based code and Linux on 360. Work to implement End User Requirements Test and improve the Linux live CD images Add useful ideas to this list.","title":"IRC"},{"location":"Help/#seeking-information-on","text":"Some documentation must already exist, though perhaps not in the wild. We are seeking: CPU instruction set reference --> See VisualStudio 2005 Reference (Exact CPU instruction set reference) Verification that the CPUs have a memory management unit (can do virtual memory) Details of Multi-processor memory coherency and synchronization requirements","title":"Seeking Information On"},{"location":"Help/#documentation-to-develop","text":"Some documentation will either not exist, or won't be made available Memory usage map for boot code Hypervisor details. What is checked and how it is checked Chain of trust: how execution integrity is designed to work Chinks in the armor: Holes in the chain of trust Hard drive locking (if any) and filesystem details ( Harddrive ) Wireless hardware and software protocol for controllers Xbox1 software emulation details","title":"Documentation To Develop"},{"location":"Help/#xell-libxenon","text":"[Libxenon]: Improve Libxenon and write apps. [Libxenon]/[XeLL]: Fix the usb driver so it gets proper speed and Power supply does not need to get replugged to get usb mass storage recognized DONE [Libxenon]/[XeLL]: Write a fatx/xtaf driver [XeLL]: Implement parsing of a bootconfig + passing bootarguments to the linux kernel DONE [XeLL]: Fix non-workin XeLL-XeLL implementation (chainload XeLL from a \"base XeLL\") DONE","title":"XeLL / Libxenon"},{"location":"Help/#xenon-linux-kernel","text":"Needs urgent fixing: Linux Kernel - a hardware CPU bug causes powerpc locking primitives to fail between hyper threads unless a special register is set properly Fix usb driver (random freez under heavy usage) Patch RTC driver for hardware clock access Xenosfb: add support for mode switching Audio driver If possible: Modify the ATI 3D driver to work with the Xenos-Chip","title":"Xenon linux kernel"},{"location":"Help/#linux-live-cd-installer","text":"Open a Boot Menu with the following options: Load [Linux Kernel] from HDD (default, 10s timeout? auto detection of valid Linux HDD?) Load [Linux Kernel] from CD and use root filesystem on HDD Load Rescue/Installer Linux LiveCD Load Linux over TFTP (optionally configuring the network) The Menu can either be created in XeLL (requiring reading from CD, SATA, plus interactivity over serial / IR remote or USB controller), or possibly in a Linux initramfs (which is easier to implement, but locks the user in to one single kernel) Category:Support","title":"Linux Live CD / Installer"},{"location":"HvxExpansionInstall/","text":"HvxExpansionInstall A system call for \"installing\" code under Hypervisor context. Registers an HvxExpansion structure in the expansion table Reversed Pseudocode // r0 is 0x70 // Parameters are taken in r3 and r4, respectively // r2, r5 - r9 are 0 typedef struct _EXP_HEADER { DWORD Magic; // \"SIGM\" or \"SIGC\" DWORD Flags; // Used in verifcation Flags = 1, 2 DWORD Size; // Should be <= size used to install BYTE ShaHash[0x14]; // SHA-1 digest of everything after header BYTE AESFeed[0x10]; XECRYPT_SIG Sig; // RSA sig of the first 0x30 bytes of the header ; 0x100 length ; encrypted //DWORD ExpID; } EXP_HEADER, *PEXP_HEADER typedef struct _HV_EXPANSION_SECTION_INFO { DWORD Size1; // Length of some kind DWORD Size2; // Length of code data DWORD Size3; // Length of some kind DWORD Padding; // 0x10 Align } EXP_SECTION_INFO; typedef struct _HV_EXPANSION_INFO { DWORD ExpansionId; // Id to be used when called after install DWORD ExpansionFlags; // Compared with something in HV DWORD ExpansionVersion; // Used to lock to a hv version DWORD ExpansionVersion2; // Used to lock to a hv version QWORD Reserved; // Havent seen this used QWORD Unknown; // Compared with something in HV DWORD ExpansionDataPos1; // Position of expansion data/info DWORD ExpansionDataLen1; // Length DWORD ExpansionDataPos2; // Position of expansion data/info DWORD ExpansionDataLen2; // Length } EXP_INFO; typedef struct _HV_EXPANSION { EXP_HEADER Header; // Expansion Header EXP_INFO ExpansionInfo; // Expansion Info EXP_SECTION_INFO SectionInfo; // Sections pointed to by ExInfo DWORD ExpansionCode[1]; // 0x10 Align } EXP; QWORD HvxExpansionInstall(PVOID pExpAddy, DWORD cExpSize) { // Check 0x80 byte alignment on payload address if(pExpAddy & 0x7F) return 0xC8007000; // Check 0x80 byte alignment on payload size if(cExpSize & 0x7F) return 0xC8007001; // Unknown check, if I had to guess its checking if you requested too much memory or if the address is out of range // Similar check is found in similar operations if(((((pExpAddy + cExpSize) - 1) ^ pExpAddy) & 0xFFFF0000) != 0) return 0xC8007001; // relocates exp data to an internal location, replaces pExpAddy with new address HvpAquireSpinLock(0x200016918); pExpAddy = HvpRelocatePhysicalToProtected(pExpAddy, cExpSize, 0x3A); BYTE Hash1[0x14] = 0; PBYTE AESKey = 0; XECRYPT_RSA xRsa; PEXP_HEADER pExpHeader = (PEXP_HEADER)pExpAddy; DWORD MagicVersion = pExpHeader->Magic; // Check what type of expansion we're dealing with if(MagicVersion == 0x48585052) // \"HVPR\" { if(pExpHeader->Flags & 3) //bits 1 and 2 in flags must be cleared for this type return 0xC8007003; xRsa = *(XECRYPT_RSA*)0x0000000200016280; // public RSA key AESKey = (PBYTE)0x0000000200016270; // 1BL Key XeCryptRotSumSha(pExpAddy, 0x30, 0, 0, Hash1, 0x14); // hash the header minus the sig } else if(MagicVersion == 0x48585043) // \"HVPC\" { // RSA Key check? Data its checking is null on RGH and XDK. Possible variable key? #ifdef DEVKIT xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016A00)+0x200; #else xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016950)+0x200; #endif if(xRsa.cqw != 0x20) return 0xC8007002; if((pExpHeader->Flags & 3) != 3) // flags 1 and 2 must be set for this type return 0xC8007003; #ifdef DEVKIT if(!(pExpHeader->Flags & 2)) // if bit 2 is cleared, data is not encrypted AESKey = 0; // data is decrypted, do not decrypt else #endif AESKey = (PBYTE)0x20; // CPU Key XeCryptHmacSha(0x20, 0x10, pExpAddy, 0x30, 0, 0, 0, 0, Hash1, 0x14); } else return 0xC8007002; // invalid expansion type // check if the header has been tampered with if(!XeCryptBnQwBeSigVerify(pExpHeader->Sig, Hash1, (PBYTE)0x0000000200016664, xRsa)) return 0xC8007003; if(pExpHeader->Size > cExpSize) // size in header must be <= size requested return 0xC8007003; if(AESKey != 0) // check if the key has been set. if not, skip decryption { XECRYPT_AES_STATE aes; XeCryptAesKey(&aes, AESKey); XeCryptAesCbc(&aes, pExpAddy+0x130, (pExpHeader->Size)-0x130, pExpAddy+0x130, &(pExpHeader->AESFeed), 0); } // check if the expansion has been tampered with XeCryptSha(pExpAddy+0x130, (pExpHeader->Size)-0x130, 0, 0, 0, 0, Hash1, 0x14); if(XeCryptMemDiff(pExpHeader->ShaHash, Hash1, 0x14)) return 0xC8007003; // go to the install function QWORD ret = InstallExpansion(pExpAddy); HvpZeroCacheLines(pExpAddy, cExpSize >> 7); HvpRelocateProtectedToPhysical(pExpAddy, cExpSize, 0x3A); HvpReleaseSpinLock(0x200016918); return ret; }","title":"HvxExpansionInstall"},{"location":"HvxExpansionInstall/#hvxexpansioninstall","text":"A system call for \"installing\" code under Hypervisor context. Registers an HvxExpansion structure in the expansion table","title":"HvxExpansionInstall"},{"location":"HvxExpansionInstall/#reversed-pseudocode","text":"// r0 is 0x70 // Parameters are taken in r3 and r4, respectively // r2, r5 - r9 are 0 typedef struct _EXP_HEADER { DWORD Magic; // \"SIGM\" or \"SIGC\" DWORD Flags; // Used in verifcation Flags = 1, 2 DWORD Size; // Should be <= size used to install BYTE ShaHash[0x14]; // SHA-1 digest of everything after header BYTE AESFeed[0x10]; XECRYPT_SIG Sig; // RSA sig of the first 0x30 bytes of the header ; 0x100 length ; encrypted //DWORD ExpID; } EXP_HEADER, *PEXP_HEADER typedef struct _HV_EXPANSION_SECTION_INFO { DWORD Size1; // Length of some kind DWORD Size2; // Length of code data DWORD Size3; // Length of some kind DWORD Padding; // 0x10 Align } EXP_SECTION_INFO; typedef struct _HV_EXPANSION_INFO { DWORD ExpansionId; // Id to be used when called after install DWORD ExpansionFlags; // Compared with something in HV DWORD ExpansionVersion; // Used to lock to a hv version DWORD ExpansionVersion2; // Used to lock to a hv version QWORD Reserved; // Havent seen this used QWORD Unknown; // Compared with something in HV DWORD ExpansionDataPos1; // Position of expansion data/info DWORD ExpansionDataLen1; // Length DWORD ExpansionDataPos2; // Position of expansion data/info DWORD ExpansionDataLen2; // Length } EXP_INFO; typedef struct _HV_EXPANSION { EXP_HEADER Header; // Expansion Header EXP_INFO ExpansionInfo; // Expansion Info EXP_SECTION_INFO SectionInfo; // Sections pointed to by ExInfo DWORD ExpansionCode[1]; // 0x10 Align } EXP; QWORD HvxExpansionInstall(PVOID pExpAddy, DWORD cExpSize) { // Check 0x80 byte alignment on payload address if(pExpAddy & 0x7F) return 0xC8007000; // Check 0x80 byte alignment on payload size if(cExpSize & 0x7F) return 0xC8007001; // Unknown check, if I had to guess its checking if you requested too much memory or if the address is out of range // Similar check is found in similar operations if(((((pExpAddy + cExpSize) - 1) ^ pExpAddy) & 0xFFFF0000) != 0) return 0xC8007001; // relocates exp data to an internal location, replaces pExpAddy with new address HvpAquireSpinLock(0x200016918); pExpAddy = HvpRelocatePhysicalToProtected(pExpAddy, cExpSize, 0x3A); BYTE Hash1[0x14] = 0; PBYTE AESKey = 0; XECRYPT_RSA xRsa; PEXP_HEADER pExpHeader = (PEXP_HEADER)pExpAddy; DWORD MagicVersion = pExpHeader->Magic; // Check what type of expansion we're dealing with if(MagicVersion == 0x48585052) // \"HVPR\" { if(pExpHeader->Flags & 3) //bits 1 and 2 in flags must be cleared for this type return 0xC8007003; xRsa = *(XECRYPT_RSA*)0x0000000200016280; // public RSA key AESKey = (PBYTE)0x0000000200016270; // 1BL Key XeCryptRotSumSha(pExpAddy, 0x30, 0, 0, Hash1, 0x14); // hash the header minus the sig } else if(MagicVersion == 0x48585043) // \"HVPC\" { // RSA Key check? Data its checking is null on RGH and XDK. Possible variable key? #ifdef DEVKIT xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016A00)+0x200; #else xRsa = *(XECRYPT_RSA*)(*(QWORD*)0x0000000200016950)+0x200; #endif if(xRsa.cqw != 0x20) return 0xC8007002; if((pExpHeader->Flags & 3) != 3) // flags 1 and 2 must be set for this type return 0xC8007003; #ifdef DEVKIT if(!(pExpHeader->Flags & 2)) // if bit 2 is cleared, data is not encrypted AESKey = 0; // data is decrypted, do not decrypt else #endif AESKey = (PBYTE)0x20; // CPU Key XeCryptHmacSha(0x20, 0x10, pExpAddy, 0x30, 0, 0, 0, 0, Hash1, 0x14); } else return 0xC8007002; // invalid expansion type // check if the header has been tampered with if(!XeCryptBnQwBeSigVerify(pExpHeader->Sig, Hash1, (PBYTE)0x0000000200016664, xRsa)) return 0xC8007003; if(pExpHeader->Size > cExpSize) // size in header must be <= size requested return 0xC8007003; if(AESKey != 0) // check if the key has been set. if not, skip decryption { XECRYPT_AES_STATE aes; XeCryptAesKey(&aes, AESKey); XeCryptAesCbc(&aes, pExpAddy+0x130, (pExpHeader->Size)-0x130, pExpAddy+0x130, &(pExpHeader->AESFeed), 0); } // check if the expansion has been tampered with XeCryptSha(pExpAddy+0x130, (pExpHeader->Size)-0x130, 0, 0, 0, 0, Hash1, 0x14); if(XeCryptMemDiff(pExpHeader->ShaHash, Hash1, 0x14)) return 0xC8007003; // go to the install function QWORD ret = InstallExpansion(pExpAddy); HvpZeroCacheLines(pExpAddy, cExpSize >> 7); HvpRelocateProtectedToPhysical(pExpAddy, cExpSize, 0x3A); HvpReleaseSpinLock(0x200016918); return ret; }","title":"Reversed Pseudocode"},{"location":"HvxKeysExecute/","text":"HvxKeysExecute HvxKeysExecute is a syscall to execute a payload in privileged mode Microsoft uses it as a back door to xbox 360s On retails: Payloads must be signed On exploited consoles: Signature check must be patched Because this function has to do with online related services, I have altered some function names, with the intention to reduce abusing this for online purposes. Why is this here if it has to do with online? Because while it is used in the xbox live auth process, that does not appear to be its main function. For example I have used it many times to help debug other HV system calls. #define KEYS_PARAMETER_FAIL 0xC8000030 #define KEYS_MAGIC_FAIL 0xC8000032 #define KEYS_HVMAGIC_FAIL 0xC8000033 #define KEYS_HEADER_FAIL 0xC8000034 #define KEYS_ENTRYPOINT_FAIL 0xC8000035 #define KEYS_CRYPT_FAIL 0xC8000036 // similar header to a bootloader, without the presets (probably because presets are passed as arguments) typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 XECRYPT_SIG Sig; // 0x20 : 0x100 // Header: 0x120 }BLHeader, *PBLHeader; BYTE BLKey[0x10] = { <redacted> }; BYTE ExSalt[0xA] = <redacted>; // NOTE: They use the same RSA key and BLKey as 1bl but different signature salt XECRYPT_RSAPUB_2048 xRSA; xRSA = <redacted> typedef QWORD PayloadJump(PBYTE pbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4); QWORD HvxKeysExecute(PBYTE pbPayload, DWORD cbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4) { if(pbPayload & 0x7F // 0x80 byte alignment check || cbPayload & 0x7F // 0x80 byte alignment check || cbPayload > 0x10000 // size check || (((pbPayload + cbPayload) - 1) ^ pbPayload) & 0xFFFF0000) return KEYS_PARAMETER_FAIL; HvpAquireSpinLock(0x200016460); // our payload will be executed in realmode, to maintain security make sure it will be in a secure area DWORD origPayload = pbPayload; pbPayload = HvpRelocatePhysicalToInternal(pbPayload, cbPayload, 0x3E); // from now on if something fails, we need to invalidate the block in protected memory QWORD ret = 0; PBLHeader phPayload = (PBLHeader)pbPayload; if(phPayload->Magic & 0xF0F == 0xD0D) // Payload Magic check { if((*(WORD*)0 ^ phPayload->Magic) & 0xF000 == 0) // HV & Payload magic check { if(phPayload->Size >= 0x120 // sanity check || (phPayload->Size + 0xF) & 0xFFFFFFF0 >= phPayload->Size // ? dont see the point...? || (phPayload->Size + 0xF) & 0xFFFFFFF0 <= cbPayload) // sanity check { if(!phPayload->EntryPoint & 3 // 4 byte alignment check || phPayload->EntryPoint >= 0x120 // sanity check || phPayload->EntryPoint <= phPayload->Size & 0xFFFFFFFC) // sanity check { BYTE rc4Key[0x10]; XeCryptHmacSha(BLKey, 0x10, &phPayload->key, 0x10, 0, 0, 0, 0, rc4Key, 0x10); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, rc4Key, 0x10); XeCryptRc4Ecb(&rc4, pbPayload+0x20, phPayload->Size - 0x20); BYTE Hash[0x14]; XeCryptRotSumSha(pbPayload, 0x10, pbPayload+0x120, phPayload->Size - 0x120, Hash, 0x14); if(XeCryptBnQwBeSigVerify(phPayload->Sig, Hash, ExSalt, &xRSA)) { // key and sig will not be used anymore, null them *(QWORD*)pbPayload+0x10 = 0ull; *(QWORD*)pbPayload+0x18 = 0ull; memset(&phPayload->Sig, 0, 0x100); if(phPayload->Size < cbPayload) memset((pbPayload + phPayload->Size), 0, (cbPayload - phPayload->Size)); // jump to our payload PayloadJump* pfPayload = (PayloadJump*)(pbPayload + phPayload->EntryPoint); ret = pfPayload(pbPayload, Arg1, Arg2, Arg3, Arg4); } else ret = KEYS_CRYPT_FAIL; } else ret = KEYS_ENTRYPOINT_FAIL; } else ret = KEYS_HEADER_FAIL; } else ret = KEYS_HVMAGIC_FAIL; } else ret = KEYS_MAGIC_FAIL; BYTE retBuf[0x100]; if(ret == 0) // assumed as success (payload return can change this) memcpy(retBuf, pbPayload+0x20, 0x100); else // assumed something failed, null retBuf (NOTE: if you want to use retBuf as a return buffer, payload must return 0) for(int i = 0;i < 0x20;i++) retBuf[i*8] = 0ull; // clean up HvpInvalidateCachelines(pbPayload, cbPayload); pbPayload = HvpPhysicalToReal(origPayload, cbPayload); HvpZeroCacheLines(pbPayload, cbPayload >> 7); memcpy(pbPayload + 0x20, retBuf, 0x100); HvpReleaseSpinLock(0x200016460); return ret; }","title":"HvxKeysExecute"},{"location":"HvxKeysExecute/#hvxkeysexecute","text":"HvxKeysExecute is a syscall to execute a payload in privileged mode Microsoft uses it as a back door to xbox 360s On retails: Payloads must be signed On exploited consoles: Signature check must be patched Because this function has to do with online related services, I have altered some function names, with the intention to reduce abusing this for online purposes. Why is this here if it has to do with online? Because while it is used in the xbox live auth process, that does not appear to be its main function. For example I have used it many times to help debug other HV system calls. #define KEYS_PARAMETER_FAIL 0xC8000030 #define KEYS_MAGIC_FAIL 0xC8000032 #define KEYS_HVMAGIC_FAIL 0xC8000033 #define KEYS_HEADER_FAIL 0xC8000034 #define KEYS_ENTRYPOINT_FAIL 0xC8000035 #define KEYS_CRYPT_FAIL 0xC8000036 // similar header to a bootloader, without the presets (probably because presets are passed as arguments) typedef struct _BLHeader { WORD Magic; // 0 : 2 WORD Version; // 2 : 2 DWORD Flags; // 4 : 4 DWORD EntryPoint; // 8 : 4 DWORD Size; // 0xC : 4 BYTE key[0x10]; // 0x10 : 0x10 XECRYPT_SIG Sig; // 0x20 : 0x100 // Header: 0x120 }BLHeader, *PBLHeader; BYTE BLKey[0x10] = { <redacted> }; BYTE ExSalt[0xA] = <redacted>; // NOTE: They use the same RSA key and BLKey as 1bl but different signature salt XECRYPT_RSAPUB_2048 xRSA; xRSA = <redacted> typedef QWORD PayloadJump(PBYTE pbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4); QWORD HvxKeysExecute(PBYTE pbPayload, DWORD cbPayload, QWORD Arg1, QWORD Arg2, QWORD Arg3, QWORD Arg4) { if(pbPayload & 0x7F // 0x80 byte alignment check || cbPayload & 0x7F // 0x80 byte alignment check || cbPayload > 0x10000 // size check || (((pbPayload + cbPayload) - 1) ^ pbPayload) & 0xFFFF0000) return KEYS_PARAMETER_FAIL; HvpAquireSpinLock(0x200016460); // our payload will be executed in realmode, to maintain security make sure it will be in a secure area DWORD origPayload = pbPayload; pbPayload = HvpRelocatePhysicalToInternal(pbPayload, cbPayload, 0x3E); // from now on if something fails, we need to invalidate the block in protected memory QWORD ret = 0; PBLHeader phPayload = (PBLHeader)pbPayload; if(phPayload->Magic & 0xF0F == 0xD0D) // Payload Magic check { if((*(WORD*)0 ^ phPayload->Magic) & 0xF000 == 0) // HV & Payload magic check { if(phPayload->Size >= 0x120 // sanity check || (phPayload->Size + 0xF) & 0xFFFFFFF0 >= phPayload->Size // ? dont see the point...? || (phPayload->Size + 0xF) & 0xFFFFFFF0 <= cbPayload) // sanity check { if(!phPayload->EntryPoint & 3 // 4 byte alignment check || phPayload->EntryPoint >= 0x120 // sanity check || phPayload->EntryPoint <= phPayload->Size & 0xFFFFFFFC) // sanity check { BYTE rc4Key[0x10]; XeCryptHmacSha(BLKey, 0x10, &phPayload->key, 0x10, 0, 0, 0, 0, rc4Key, 0x10); XECRYPT_RC4_STATE rc4; XeCryptRc4Key(&rc4, rc4Key, 0x10); XeCryptRc4Ecb(&rc4, pbPayload+0x20, phPayload->Size - 0x20); BYTE Hash[0x14]; XeCryptRotSumSha(pbPayload, 0x10, pbPayload+0x120, phPayload->Size - 0x120, Hash, 0x14); if(XeCryptBnQwBeSigVerify(phPayload->Sig, Hash, ExSalt, &xRSA)) { // key and sig will not be used anymore, null them *(QWORD*)pbPayload+0x10 = 0ull; *(QWORD*)pbPayload+0x18 = 0ull; memset(&phPayload->Sig, 0, 0x100); if(phPayload->Size < cbPayload) memset((pbPayload + phPayload->Size), 0, (cbPayload - phPayload->Size)); // jump to our payload PayloadJump* pfPayload = (PayloadJump*)(pbPayload + phPayload->EntryPoint); ret = pfPayload(pbPayload, Arg1, Arg2, Arg3, Arg4); } else ret = KEYS_CRYPT_FAIL; } else ret = KEYS_ENTRYPOINT_FAIL; } else ret = KEYS_HEADER_FAIL; } else ret = KEYS_HVMAGIC_FAIL; } else ret = KEYS_MAGIC_FAIL; BYTE retBuf[0x100]; if(ret == 0) // assumed as success (payload return can change this) memcpy(retBuf, pbPayload+0x20, 0x100); else // assumed something failed, null retBuf (NOTE: if you want to use retBuf as a return buffer, payload must return 0) for(int i = 0;i < 0x20;i++) retBuf[i*8] = 0ull; // clean up HvpInvalidateCachelines(pbPayload, cbPayload); pbPayload = HvpPhysicalToReal(origPayload, cbPayload); HvpZeroCacheLines(pbPayload, cbPayload >> 7); memcpy(pbPayload + 0x20, retBuf, 0x100); HvpReleaseSpinLock(0x200016460); return ret; }","title":"HvxKeysExecute"},{"location":"HvxPostOutput/","text":"HvxPostOutput static QWORD _declspec(naked) HvxPostOutput(BYTE code) { __asm { li r0, 0xD sc blr } } HvxPostOutput(0xFF); Returns 0","title":"HvxPostOutput"},{"location":"HvxPostOutput/#hvxpostoutput","text":"static QWORD _declspec(naked) HvxPostOutput(BYTE code) { __asm { li r0, 0xD sc blr } } HvxPostOutput(0xFF); Returns 0","title":"HvxPostOutput"},{"location":"Hypervisor/","text":"Hypervisor Note Old notes on the Xbox 360 Hypervisor can be found here: Hypervisor (Old Notes) What is a Hypervisor? Like in the PS3, Microsoft protects the integrity of its system with a Hypervisor . Using the virtualization technologies of today's processors, a hypervisor can act as a small piece of code with even higher privileges than the more complex operating system. In theory, even potential flaws in the operating system cannot be exploited since the hypervisor puts up additional restrictions. In case of the Xbox 360, the hypervisor is responsible for encryption, decryption and the enforcement of access restrictions on memory. Thanks to the work of an anonymous hacker, a flaw in the hypervisor has been discovered on certain versions of the Xbox 360 kernel , allowing the injection of code, which has not been cryptographically signed by Microsoft. How It Works The Hypervisor (HV) is primarily made up of a series of interrupt vectors and system calls that are accompanied by a few cryptography related helper sub-routines. On the 360, the main job of the HV is to manage the security of the system and handle encryption/crypto-signatures of files that will be run. Because of this, the HV is only executed in Real-Mode, with the highest privileges. Memory paging is disabled and the HV can access any memory space on the system, including memory mapped devices, however code run from user-mode (normal mode) cannot read or write to HV space. It is essential to understand how the HV works to understand the lower level of software on the xbox 360. When an interrupt is generated by the CPU, it jumps to the corresponding handler. When this occurs, the address of the instruction that generated the interrupt is stored in SRR0 and the MSR before the interrupt occurred is stored in SRR1 with bits 33-36 and bits 42-47 loaded with data specific to the interrupt. For every interrupt, the CPU is sent into Real Mode/privileged state, interrupts are the entrance to the HV. Instruction and data relocation is disabled at this time. When a return from interrupt (rfid) instruction occurs, it copies SRR1 to the MSR, synchronizes context, and jumps to the address stored in SRR0. Unless the Interrupt modified the contents of SRR1, the program will exit privileged state after the MSR is set. All interrupts are ordered meaning while one is being handled, the CPU will wait until it is finished before handling another. The exception to this is the RESET and MACHINE_CHECK interrupts, these are unorded and can take place at any time. If they occur while another interrupt is being handled, SRR0 and SRR1 will be overwritten by the new handler and context synchronization will be lost. During normal operation of the Xbox 360, the RESET interrupt does not occur and the MACHINE_CHECK interrupt is not recoverable. Interrupt Vectors Vectors Offset 0x00000100 0x00000200 0x00000218 0x00000300 0x00000380 0x00000400 0x00000480 0x00000500 0x00000600 0x00000700 0x00000800 0x00000900 0x00000980 0x00000B9C 0x00000C00 0x00000D00 0x00000A5C 0x00000F20 0x00001600 0x00001700 0x00001800 Cryptography Retail 17511 - These offsets are subject to change! Cryptography Functions Offset 0x00020300 0x00023500 0x000226F0 0x00022738 0x00020520 0x0000A880 0x0000AD20 0x00022DB8 0x00022BD0 0x00022CF0 0x00023170 0x00023218 0x00020578 0x00020F00 0x00021210 0x00020EC8 0x000244D8 0x00024560 0x000211F0 0x00024AF0 0x00024A40 0x00024A98 0x000247D0 0x00020910 0x00024C68 0x00023108 0x00022E98 0x00023010 0x00023060 0x000200F8 0x00023008 0x00021128 0x00020D28 0x000211A8 0x00021240 0x00021840 0x00021BC8 0x000217C0 0x00021968 0x00021710 0x00021270 0x00021C08 0x00023278 0x00023330 0x00020550 0x00020250 0x00020468 0x000203A8 0x00024420 0x00020680 0x00000E14 Utility Functions Utility Functions Offset 0x00000384 0x00000398 0x000003C4 0x00000484 0x000004A8 0x000004D8 0x0000068C 0x000006A0 0x000006B4 0x000006CC 0x00000E14 0x00000EE4 0x00001804 0x000029E0 0x00003358 0x000033D8 0x00003620 0x00000000 Invoking The Hypervisor User-mode code can invoke the Hypervisor at any time through what is called a system call(syscall). System calls are functions set up by the Hypervisor that can preform various tasks on the system, for example getting the value of a special cpu register or printing to the console's post bus. When a system call is preformed, the cpu generates a syscall interrupt and jumps to the appropriate handler. System calls are described more here: System Calls","title":"Hypervisor"},{"location":"Hypervisor/#hypervisor","text":"","title":"Hypervisor"},{"location":"Hypervisor/#note","text":"Old notes on the Xbox 360 Hypervisor can be found here: Hypervisor (Old Notes)","title":"Note"},{"location":"Hypervisor/#what-is-a-hypervisor","text":"Like in the PS3, Microsoft protects the integrity of its system with a Hypervisor . Using the virtualization technologies of today's processors, a hypervisor can act as a small piece of code with even higher privileges than the more complex operating system. In theory, even potential flaws in the operating system cannot be exploited since the hypervisor puts up additional restrictions. In case of the Xbox 360, the hypervisor is responsible for encryption, decryption and the enforcement of access restrictions on memory. Thanks to the work of an anonymous hacker, a flaw in the hypervisor has been discovered on certain versions of the Xbox 360 kernel , allowing the injection of code, which has not been cryptographically signed by Microsoft.","title":"What is a Hypervisor?"},{"location":"Hypervisor/#how-it-works","text":"The Hypervisor (HV) is primarily made up of a series of interrupt vectors and system calls that are accompanied by a few cryptography related helper sub-routines. On the 360, the main job of the HV is to manage the security of the system and handle encryption/crypto-signatures of files that will be run. Because of this, the HV is only executed in Real-Mode, with the highest privileges. Memory paging is disabled and the HV can access any memory space on the system, including memory mapped devices, however code run from user-mode (normal mode) cannot read or write to HV space. It is essential to understand how the HV works to understand the lower level of software on the xbox 360. When an interrupt is generated by the CPU, it jumps to the corresponding handler. When this occurs, the address of the instruction that generated the interrupt is stored in SRR0 and the MSR before the interrupt occurred is stored in SRR1 with bits 33-36 and bits 42-47 loaded with data specific to the interrupt. For every interrupt, the CPU is sent into Real Mode/privileged state, interrupts are the entrance to the HV. Instruction and data relocation is disabled at this time. When a return from interrupt (rfid) instruction occurs, it copies SRR1 to the MSR, synchronizes context, and jumps to the address stored in SRR0. Unless the Interrupt modified the contents of SRR1, the program will exit privileged state after the MSR is set. All interrupts are ordered meaning while one is being handled, the CPU will wait until it is finished before handling another. The exception to this is the RESET and MACHINE_CHECK interrupts, these are unorded and can take place at any time. If they occur while another interrupt is being handled, SRR0 and SRR1 will be overwritten by the new handler and context synchronization will be lost. During normal operation of the Xbox 360, the RESET interrupt does not occur and the MACHINE_CHECK interrupt is not recoverable.","title":"How It Works"},{"location":"Hypervisor/#interrupt-vectors","text":"Vectors Offset 0x00000100 0x00000200 0x00000218 0x00000300 0x00000380 0x00000400 0x00000480 0x00000500 0x00000600 0x00000700 0x00000800 0x00000900 0x00000980 0x00000B9C 0x00000C00 0x00000D00 0x00000A5C 0x00000F20 0x00001600 0x00001700 0x00001800","title":"Interrupt Vectors"},{"location":"Hypervisor/#cryptography","text":"Retail 17511 - These offsets are subject to change! Cryptography Functions Offset 0x00020300 0x00023500 0x000226F0 0x00022738 0x00020520 0x0000A880 0x0000AD20 0x00022DB8 0x00022BD0 0x00022CF0 0x00023170 0x00023218 0x00020578 0x00020F00 0x00021210 0x00020EC8 0x000244D8 0x00024560 0x000211F0 0x00024AF0 0x00024A40 0x00024A98 0x000247D0 0x00020910 0x00024C68 0x00023108 0x00022E98 0x00023010 0x00023060 0x000200F8 0x00023008 0x00021128 0x00020D28 0x000211A8 0x00021240 0x00021840 0x00021BC8 0x000217C0 0x00021968 0x00021710 0x00021270 0x00021C08 0x00023278 0x00023330 0x00020550 0x00020250 0x00020468 0x000203A8 0x00024420 0x00020680 0x00000E14","title":"Cryptography"},{"location":"Hypervisor/#utility-functions","text":"Utility Functions Offset 0x00000384 0x00000398 0x000003C4 0x00000484 0x000004A8 0x000004D8 0x0000068C 0x000006A0 0x000006B4 0x000006CC 0x00000E14 0x00000EE4 0x00001804 0x000029E0 0x00003358 0x000033D8 0x00003620 0x00000000","title":"Utility Functions"},{"location":"Hypervisor/#invoking-the-hypervisor","text":"User-mode code can invoke the Hypervisor at any time through what is called a system call(syscall). System calls are functions set up by the Hypervisor that can preform various tasks on the system, for example getting the value of a special cpu register or printing to the console's post bus. When a system call is preformed, the cpu generates a syscall interrupt and jumps to the appropriate handler. System calls are described more here: System Calls","title":"Invoking The Hypervisor"},{"location":"Hypervisor_%28Old_Notes%29/","text":"Hypervisor (old notes) no booting details known changes between beta hardware and final: alpha hardware = macintosh beta = ? looks like retail, but no encryption second beta =! retail tried to dump RAM could only dump virtual memory ram is at 8000_0000 southbridge: pci config space, mapped to VM, accessible by user apps memory at bottom looks random/encrypted, might be hypervisor 256 KB 8040_0000 xbox kernel starts, MZ header read memory using debug interface: everything is in plaintext, you can read kernel + app (dashboard etc.), i.e. virtual memory is not encrypted kernel interesting to disassemble communication with hypervisor using syscalls hypervisor does interrupts/exceptions Syscalls final: SC 00: GetVersionCode (e.g. r3=072F8002) SC 01: KeStartupProcessors SC 02: unknown KiQuiesce SC 03: KeFlushEntireTb SC 04: called in FlushMultipleTb SC 05: ?? SC 06: KeGetSpecialPurposeRegister (r3=0x3F5) SC 07: KeSetSpecialPurposeRegister SC 08: KeGetSocRegister(r3=???)/KeGetPWMRegister(r3=60000)/ KeGetPRVRegister(r3=61000) SC 09: KeSetSocRegister SC 0A: KeStartupProcessors SC 0B: called in ReserveKernelPtes SC 0C: called from MmAllocatePhysicalMemoryEx SC 0D: setAD16 SC 0E: KeEnablePPUPerformanceMonitor SC 0F: called from MmGetPhysicalAddress SC 10: called from MmDbgReleaseAddress SC 11: XexpLoadFile calls it, seems to get privkey r4 = phys addr (of header?) offset: +8 r5 = region r6 = ?? offset: +4 r7 = ?? size? SC 12: called from MmAllocateImageMemory SC 13: called from MmAllocateImageMemory SC 14: called in XexpLoadFile SC 15: called in XexpLoadFile SC 16: called in XexpCompleteImageLoad SC 17: called in XexpCompleteImageLoad SC 18: called in XexpLoadFile, XexpCompleteImageLoad SC 19: unload? SC 1A: unload? SC 1B: unload? SC 1c: called on XexpTitleTerminateNotification SC 1d: KeCreateUserMode SC 1e: KeDeleteUserMode SC 1f: Flush TLB SC 20: set power SC 21: shadow boot SC 22: Burn fuses SC 23: FSB interrupt related SC 24: KeLockL2 SC 25: SC 26 SC 27 SC 28 SC 29 SC 2A SC 2B SC 2C: SataCdRomHvVerifyLBA SC 2D SC 2E: XeKeysInitialize (r3, r4 = address) SC 2F: XeKeysGetKeyProperties SC 30: XeKeysGetStatus SC 31: XeKeysGenerateRandomKey SC 32: XeKeysGetFactoryChallenge SC 33: XeKeysSetFactoryResponse SC 34: XeKeysSaveBootLoader SC 35: XeKeysSaveKeyVault SC 36: XeKeysSetKey SC 37: XeKeysGetKey SC 38: XeKeysGetDigest SC 39: XeKeysQwNeRsaPrvCrypt SC 3D: XeKeysDesCbc. r6: address, r5: context SC 3F: XeKeysSaveSystemUpdate SC 40: XeKeysExecute SC 22 (Burn fuses) tested on 2 kernels first: SC \"access fuses\" second: \"burn fuses\" (rumour has it that this is used to make retail boxes out of debug boxes) memory management 0F/10: perhaps page table access code in hypervisor, all high level code in kernel you can't map memory as you like network adapter in the southbridge debug code dumps registers with names it is possible to dump physical memory using network adapter DMA accesses not perfect dump reading physical memory = encrypted data segments are not encrypted, but nearly all code segments older recovery cd (early 2005), worked on first beta developer kits, without security enabled: cd included kernel which included stuff that is encrypted in retail version includes hypervisor code! it is old, but... getspr: SC 6 setspr: SC 7 -> possible to see implementation of basic syscall handling function in hypervisor to chain-run a new kernel from the old kernel hypervisor: sign with private key etc. hypervisor can only do physical memory hashing: load into register base address, length, destination of hash buffer, call syscode, hypervisor will hash -> attack: hash 1 byte, *itself*, -> hangs hypervisor lies at 0 in VM and physical mem","title":"Hypervisor (old notes)"},{"location":"Hypervisor_%28Old_Notes%29/#hypervisor-old-notes","text":"no booting details known changes between beta hardware and final: alpha hardware = macintosh beta = ? looks like retail, but no encryption second beta =! retail tried to dump RAM could only dump virtual memory ram is at 8000_0000 southbridge: pci config space, mapped to VM, accessible by user apps memory at bottom looks random/encrypted, might be hypervisor 256 KB 8040_0000 xbox kernel starts, MZ header read memory using debug interface: everything is in plaintext, you can read kernel + app (dashboard etc.), i.e. virtual memory is not encrypted kernel interesting to disassemble communication with hypervisor using syscalls hypervisor does interrupts/exceptions","title":"Hypervisor (old notes)"},{"location":"Hypervisor_%28Old_Notes%29/#syscalls","text":"final: SC 00: GetVersionCode (e.g. r3=072F8002) SC 01: KeStartupProcessors SC 02: unknown KiQuiesce SC 03: KeFlushEntireTb SC 04: called in FlushMultipleTb SC 05: ?? SC 06: KeGetSpecialPurposeRegister (r3=0x3F5) SC 07: KeSetSpecialPurposeRegister SC 08: KeGetSocRegister(r3=???)/KeGetPWMRegister(r3=60000)/ KeGetPRVRegister(r3=61000) SC 09: KeSetSocRegister SC 0A: KeStartupProcessors SC 0B: called in ReserveKernelPtes SC 0C: called from MmAllocatePhysicalMemoryEx SC 0D: setAD16 SC 0E: KeEnablePPUPerformanceMonitor SC 0F: called from MmGetPhysicalAddress SC 10: called from MmDbgReleaseAddress SC 11: XexpLoadFile calls it, seems to get privkey r4 = phys addr (of header?) offset: +8 r5 = region r6 = ?? offset: +4 r7 = ?? size? SC 12: called from MmAllocateImageMemory SC 13: called from MmAllocateImageMemory SC 14: called in XexpLoadFile SC 15: called in XexpLoadFile SC 16: called in XexpCompleteImageLoad SC 17: called in XexpCompleteImageLoad SC 18: called in XexpLoadFile, XexpCompleteImageLoad SC 19: unload? SC 1A: unload? SC 1B: unload? SC 1c: called on XexpTitleTerminateNotification SC 1d: KeCreateUserMode SC 1e: KeDeleteUserMode SC 1f: Flush TLB SC 20: set power SC 21: shadow boot SC 22: Burn fuses SC 23: FSB interrupt related SC 24: KeLockL2 SC 25: SC 26 SC 27 SC 28 SC 29 SC 2A SC 2B SC 2C: SataCdRomHvVerifyLBA SC 2D SC 2E: XeKeysInitialize (r3, r4 = address) SC 2F: XeKeysGetKeyProperties SC 30: XeKeysGetStatus SC 31: XeKeysGenerateRandomKey SC 32: XeKeysGetFactoryChallenge SC 33: XeKeysSetFactoryResponse SC 34: XeKeysSaveBootLoader SC 35: XeKeysSaveKeyVault SC 36: XeKeysSetKey SC 37: XeKeysGetKey SC 38: XeKeysGetDigest SC 39: XeKeysQwNeRsaPrvCrypt SC 3D: XeKeysDesCbc. r6: address, r5: context SC 3F: XeKeysSaveSystemUpdate SC 40: XeKeysExecute","title":"Syscalls"},{"location":"Hypervisor_%28Old_Notes%29/#sc-22-burn-fuses","text":"tested on 2 kernels first: SC \"access fuses\" second: \"burn fuses\" (rumour has it that this is used to make retail boxes out of debug boxes) memory management 0F/10: perhaps page table access code in hypervisor, all high level code in kernel you can't map memory as you like network adapter in the southbridge debug code dumps registers with names it is possible to dump physical memory using network adapter DMA accesses not perfect dump reading physical memory = encrypted data segments are not encrypted, but nearly all code segments older recovery cd (early 2005), worked on first beta developer kits, without security enabled: cd included kernel which included stuff that is encrypted in retail version includes hypervisor code! it is old, but... getspr: SC 6 setspr: SC 7 -> possible to see implementation of basic syscall handling function in hypervisor to chain-run a new kernel from the old kernel hypervisor: sign with private key etc. hypervisor can only do physical memory hashing: load into register base address, length, destination of hash buffer, call syscode, hypervisor will hash -> attack: hash 1 byte, *itself*, -> hangs hypervisor lies at 0 in VM and physical mem","title":"SC 22 (Burn fuses)"},{"location":"IRC/","text":"Join us on the Free60 IRC channel at (server irc.oftc.net, channel #free60-chat ) To contribute new information and speak with devs, come to (server irc.oftc.net, channel #free60 ) There's also a channel for the guys on EFNET which is currently the most active channel of all three. Catch us in #libxenon on EFnet! Free60 and oftc.net are happy to facilitate the means for information gathering and dissemination. But, we have some basic guidelines we need you to follow. Guidelines We're not trying to be dictators, we just want everyone to get along. OFTC is a civil network and we'd like to keep it that way. Basic Guidelines Be polite. Flaming others and the like is considered bad netiquette, and is frowned upon. This will more than likely result in you and any participating parties being banned from the channel. Be on-topic. Off-topic discussion is considered noise and should be directed elsewhere. Do not /msg people with on-topic discussion. Rather, discuss that in-channel. Do not overly repeat yourself. We heard you the first time. Please don't run any bots without prior permission from an op. Channel opertator status is not a privilege, but rather a responsibilty. Asking for such will more than likely get you banned. #free60 is NOT a distribution point for pirated/illegal material, be it software or even documentation. We have zero-tolerance towards any related discussion. That also goes for use of\u00c2 !list or other such commands. You have been warned. Asking Questions Before Asking Search the wiki for an answer. Search the mailing list. While Asking Be polite. Be patient. Be pertinent -- that is make sure your question has something to do with the channel you're in. After Asking If your question was answered and can't be found on the wiki please post that info. Stick around to help others after you. Use the right channel There are two channels in OFTC currently for public use: #free60 is for technical and development discussion, for idle chat seek #free60-chat. #free60-chat is for general discussion on or off topic for free60 and is loosely controlled. And one public channel on EFNET #libxenon for everything from LibXenon and Linux till XeLL Currently neither channel is moderated ( m) though if conversations get out of hand or anything of that nature we reserve the right to place higher restrictions. Both channels will receive the same updates about important information. You can hang out in both, but make sure you questions are for the right channel. Conclusion Thank you for your interest in Free60, enjoy your stay! Category:Support","title":"IRC"},{"location":"IRC/#guidelines","text":"We're not trying to be dictators, we just want everyone to get along. OFTC is a civil network and we'd like to keep it that way.","title":"Guidelines"},{"location":"IRC/#basic-guidelines","text":"Be polite. Flaming others and the like is considered bad netiquette, and is frowned upon. This will more than likely result in you and any participating parties being banned from the channel. Be on-topic. Off-topic discussion is considered noise and should be directed elsewhere. Do not /msg people with on-topic discussion. Rather, discuss that in-channel. Do not overly repeat yourself. We heard you the first time. Please don't run any bots without prior permission from an op. Channel opertator status is not a privilege, but rather a responsibilty. Asking for such will more than likely get you banned. #free60 is NOT a distribution point for pirated/illegal material, be it software or even documentation. We have zero-tolerance towards any related discussion. That also goes for use of\u00c2 !list or other such commands. You have been warned.","title":"Basic Guidelines"},{"location":"IRC/#asking-questions","text":"","title":"Asking Questions"},{"location":"IRC/#before-asking","text":"Search the wiki for an answer. Search the mailing list.","title":"Before Asking"},{"location":"IRC/#while-asking","text":"Be polite. Be patient. Be pertinent -- that is make sure your question has something to do with the channel you're in.","title":"While Asking"},{"location":"IRC/#after-asking","text":"If your question was answered and can't be found on the wiki please post that info. Stick around to help others after you.","title":"After Asking"},{"location":"IRC/#use-the-right-channel","text":"There are two channels in OFTC currently for public use: #free60 is for technical and development discussion, for idle chat seek #free60-chat. #free60-chat is for general discussion on or off topic for free60 and is loosely controlled. And one public channel on EFNET #libxenon for everything from LibXenon and Linux till XeLL Currently neither channel is moderated ( m) though if conversations get out of hand or anything of that nature we reserve the right to place higher restrictions. Both channels will receive the same updates about important information. You can hang out in both, but make sure you questions are for the right channel.","title":"Use the right channel"},{"location":"IRC/#conclusion","text":"Thank you for your interest in Free60, enjoy your stay! Category:Support","title":"Conclusion"},{"location":"Jasper/","text":"Jasper Jasper is the codename of the fifth motherboard revision for the Xbox 360. On Jasper motherboards found within Arcade SKUs, this Xbox 360 Motherboard revision features an onboard memory unit to facilitate the NXE Dashboard . The connections required to dump/flash the NAND are the same as all previous models. Performing the SMC Hack requires the same wiring as Zephyr, Opus, and Falcon mainboards. This is a slightly different set of connections than those required for the Xenon mainboard. Jasper (V4.0) Consoles: Arcade 256MB & 512MB, Pro/Premium 60GB, Elite 120GB & 250GB and Resident Evil 5 console 65nm IBM CPU 65nm ATI GPU with 80nm on-chip eDRAM 150 Watt PSU (12V rated for 12.1A, new connector) Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B on-board flash, up from 16MB HY27US08281A flash, to accommodate the NXE update. New Southbridge chipset Ram removed from bottom of mainboard New style CPU Heat sink + the GPU heat sink with heat pipe 3 pin fan connector. New Warranty Sticker. Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers. Least likely to red ring of death (RRoD) due to the less heat being outputted by the chips Jasper (V4.1) Same as Jasper (V4) other than some minor changes. Consoles: Arcade 512MB, Elite 120GB & 250GB, Modern Warfare 2 consoles and Final Fantasy 13 consoles 65nm eDRAM (?) New Southbridge chipset Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE (Removes 256MB Memory Card) Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers. JTAG Hack / SMC patched on CB level Xenon style GPU heat sink with Falcon style CPU heat sink Special edition consoles: Modern Warfare 2 Consoles Last of the original style 360 systems Category:Xbox360_Hardware","title":"Jasper"},{"location":"Jasper/#jasper","text":"Jasper is the codename of the fifth motherboard revision for the Xbox 360. On Jasper motherboards found within Arcade SKUs, this Xbox 360 Motherboard revision features an onboard memory unit to facilitate the NXE Dashboard . The connections required to dump/flash the NAND are the same as all previous models. Performing the SMC Hack requires the same wiring as Zephyr, Opus, and Falcon mainboards. This is a slightly different set of connections than those required for the Xenon mainboard.","title":"Jasper"},{"location":"Jasper/#jasper-v40","text":"Consoles: Arcade 256MB & 512MB, Pro/Premium 60GB, Elite 120GB & 250GB and Resident Evil 5 console 65nm IBM CPU 65nm ATI GPU with 80nm on-chip eDRAM 150 Watt PSU (12V rated for 12.1A, new connector) Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B on-board flash, up from 16MB HY27US08281A flash, to accommodate the NXE update. New Southbridge chipset Ram removed from bottom of mainboard New style CPU Heat sink + the GPU heat sink with heat pipe 3 pin fan connector. New Warranty Sticker. Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers. Least likely to red ring of death (RRoD) due to the less heat being outputted by the chips","title":"Jasper (V4.0)"},{"location":"Jasper/#jasper-v41","text":"Same as Jasper (V4) other than some minor changes. Consoles: Arcade 512MB, Elite 120GB & 250GB, Modern Warfare 2 consoles and Final Fantasy 13 consoles 65nm eDRAM (?) New Southbridge chipset Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE (Removes 256MB Memory Card) Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers. JTAG Hack / SMC patched on CB level Xenon style GPU heat sink with Falcon style CPU heat sink Special edition consoles: Modern Warfare 2 Consoles Last of the original style 360 systems Category:Xbox360_Hardware","title":"Jasper (V4.1)"},{"location":"Kernel/","text":"Kernel Version 2.0.13146.0 is currently the latest public version. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.XXXX.0, where XXXX is your kernel version. Version Release Date Comment 2.0.1888.0 November 22, 2005 Original shipped version 2.0.2241.0 November 22, 2005 Update available at product launch 2.0.2255.0 January 30, 2006 Blocklist for certain .xex file 2.0.2258.0 March 2, 2006 2.0.2858.0 June 05, 2006 2.0.4532.0 October 31, 2006 New identifier X with value 2BB7-8E09-0188-D795 2.0.4548.0 November 30, 2006 2.0.4552.0 January 9, 2007 Fix unsigned code vulnerability 2.0.5759.0 May 9, 2007 Added Instant Messaging 2.0.5766.0 August 7, 2007 Wireless guitars Yet unknown fixes 2.0.6683.0 December 4, 2007 Fall Update. Timing attack works (dependant on CB). 2.0.6717.0 August 6, 2008 Scalability Updates 2.0.7357.0 November 19, 2008 New dashboard (\"NXE\") 2.0.7363.0 February 3, 2009 HDMI audio fix 2.0.7371.0 April 2, 2009 Fixes Xbox Live issues 2.0.8495.0 July, 2009 Update preview 2.0.8496.0 July 31, 2009 Update preview (second) 2.0.8498.0 August 11, 2009 Public Dashboard Released 2.0.8507.0 September 23, 2009 Preparation for newer dash 2.0.8955.0 October 28, 2009 Blocking 3rd party storage devices, adding WPA2 support for wireless adapters 2.0.9199.0 April 6, 2010 USB storage support added 2.0.12611.0 November 1, 2010 GUI upgrade for Kinect release, ESPN on Xbox LIVE released 2.0.12625.0 January 19, 2011 Adds further anti-piracy 2.5 scheme to more popular games Halo: Reach, Call of Duty: Black Ops and Call of Duty: Modern Warfare 2. Fixes \u2018Boot to Disc\u2019 option. 2.0.13146.0 May 19, 2011 Reflashes the DVD drives to support XGD3 Media : PLDS DG-16D4S, PBDS VAD6038 and PLDS DG-16D2S, to a new stock firmware : 0272, 04421C, 02510C. Also patches Samsung MS25 & MS28 Anti-Piracy 2.5 scheme updated. Support for the new XGD3 disk format for games, adds 1GB of usable disk space and extra anti-piracy features to new games Adds a new 1 hour Auto-Off setting in addition to the 6 hour Auto-Off setting previously available. Adds PayPal support as a payment option for all Xbox Live users. Minor bugfix. Please note: In order to use the SMC Hack , you must not have installed any of the 849x kernel updates. Category:Xbox360 System Software","title":"Kernel"},{"location":"Kernel/#kernel","text":"Version 2.0.13146.0 is currently the latest public version. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.XXXX.0, where XXXX is your kernel version. Version Release Date Comment 2.0.1888.0 November 22, 2005 Original shipped version 2.0.2241.0 November 22, 2005 Update available at product launch 2.0.2255.0 January 30, 2006 Blocklist for certain .xex file 2.0.2258.0 March 2, 2006 2.0.2858.0 June 05, 2006 2.0.4532.0 October 31, 2006 New identifier X with value 2BB7-8E09-0188-D795 2.0.4548.0 November 30, 2006 2.0.4552.0 January 9, 2007 Fix unsigned code vulnerability 2.0.5759.0 May 9, 2007 Added Instant Messaging 2.0.5766.0 August 7, 2007 Wireless guitars Yet unknown fixes 2.0.6683.0 December 4, 2007 Fall Update. Timing attack works (dependant on CB). 2.0.6717.0 August 6, 2008 Scalability Updates 2.0.7357.0 November 19, 2008 New dashboard (\"NXE\") 2.0.7363.0 February 3, 2009 HDMI audio fix 2.0.7371.0 April 2, 2009 Fixes Xbox Live issues 2.0.8495.0 July, 2009 Update preview 2.0.8496.0 July 31, 2009 Update preview (second) 2.0.8498.0 August 11, 2009 Public Dashboard Released 2.0.8507.0 September 23, 2009 Preparation for newer dash 2.0.8955.0 October 28, 2009 Blocking 3rd party storage devices, adding WPA2 support for wireless adapters 2.0.9199.0 April 6, 2010 USB storage support added 2.0.12611.0 November 1, 2010 GUI upgrade for Kinect release, ESPN on Xbox LIVE released 2.0.12625.0 January 19, 2011 Adds further anti-piracy 2.5 scheme to more popular games Halo: Reach, Call of Duty: Black Ops and Call of Duty: Modern Warfare 2. Fixes \u2018Boot to Disc\u2019 option. 2.0.13146.0 May 19, 2011 Reflashes the DVD drives to support XGD3 Media : PLDS DG-16D4S, PBDS VAD6038 and PLDS DG-16D2S, to a new stock firmware : 0272, 04421C, 02510C. Also patches Samsung MS25 & MS28 Anti-Piracy 2.5 scheme updated. Support for the new XGD3 disk format for games, adds 1GB of usable disk space and extra anti-piracy features to new games Adds a new 1 hour Auto-Off setting in addition to the 6 hour Auto-Off setting previously available. Adds PayPal support as a payment option for all Xbox Live users. Minor bugfix. Please note: In order to use the SMC Hack , you must not have installed any of the 849x kernel updates. Category:Xbox360 System Software","title":"Kernel"},{"location":"Kernel_Exports/","text":"Kernel exports RtlInitAnsiString Parameters : OUT PANSI_STRING OutputString, IN LPCSTR String Returns : OutputString as an ANSI equivalent of String Prototype : void RtlInitAnsiString( PANSI_STRING, LPCSTR ); Example : ANSI_STRING DeviceName; RtlInitAnsiString(&DeviceName, \"\\\\Device\\\\Harddisk0\\\\Partition1\"); ObCreateSymbolicLink Parameters : IN PANSI_STRING SymbolicLinkName, IN PANSI_STRING DeviceName Returns : 0 if success Prototype : int ObCreateSymbolicLink( PANSI_STRING, PANSI_STRING ); Example : int result = ObCreateSymbolicLink( \"\\\\??\\\\hdd:\", \"\\\\Device\\\\Harddisk0\\\\Partition1\" ); (wont actually work) Both strings have to be ANSI, use RtlInitAnsiString to make them ObDeleteSymbolicLink Parameters : IN PANSI_STRING SymbolicLinkName Returns : 0 if success Prototype : int ObDeleteSymbolicLink( PANSI_STRING ); Example : int result = ObDeleteSymbolicLink( \"\\\\??\\\\hdd:\" ); (wont actually work) As above, use RtlInitAnsiString to make the string Category:Xbox360 System Software","title":"Kernel exports"},{"location":"Kernel_Exports/#kernel-exports","text":"","title":"Kernel exports"},{"location":"Kernel_Exports/#rtlinitansistring","text":"Parameters : OUT PANSI_STRING OutputString, IN LPCSTR String Returns : OutputString as an ANSI equivalent of String Prototype : void RtlInitAnsiString( PANSI_STRING, LPCSTR ); Example : ANSI_STRING DeviceName; RtlInitAnsiString(&DeviceName, \"\\\\Device\\\\Harddisk0\\\\Partition1\");","title":"RtlInitAnsiString"},{"location":"Kernel_Exports/#obcreatesymboliclink","text":"Parameters : IN PANSI_STRING SymbolicLinkName, IN PANSI_STRING DeviceName Returns : 0 if success Prototype : int ObCreateSymbolicLink( PANSI_STRING, PANSI_STRING ); Example : int result = ObCreateSymbolicLink( \"\\\\??\\\\hdd:\", \"\\\\Device\\\\Harddisk0\\\\Partition1\" ); (wont actually work) Both strings have to be ANSI, use RtlInitAnsiString to make them","title":"ObCreateSymbolicLink"},{"location":"Kernel_Exports/#obdeletesymboliclink","text":"Parameters : IN PANSI_STRING SymbolicLinkName Returns : 0 if success Prototype : int ObDeleteSymbolicLink( PANSI_STRING ); Example : int result = ObDeleteSymbolicLink( \"\\\\??\\\\hdd:\" ); (wont actually work) As above, use RtlInitAnsiString to make the string Category:Xbox360 System Software","title":"ObDeleteSymbolicLink"},{"location":"King_Kong_Hack/","text":"King Kong Hack (outdated) 1. You need an Xbox with a kernel version of 4532 or 4548 You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version. The kernel version can be older (lower number) than 4532 or 4548, but not newer (higher number). If you already have a newer version, there is nothing you can do right now. If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it. Note, I have just got a new UK core pack with a MFG date of 19th June 2007, with all the new heatsink inside and the kernel version was one of the 2000 ones, so very old kernel on brand new xbox 360s. Note, I have just bought a premium pack with a MFG date of 16th May 2006, and the kernel version was 5759, so a new kernel on a 2006's Xbox 360. Source: Run_Code 2. Upgrading the kernel to 4532 If your kernel version is older than 4532 or 4548, you can update to one of these versions. Do not update to a version newer than 4598! You won't be able to downgrade! If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. IMPORTANT: If you use a HDD and previously canceled a XBOX Live Update request, then you must remove the HDD to prevent the Kernel updater using the cached Kernel Updater, which is newer then the Kernel 4532! If you don't remove the HDD, then the Kernel Updater will use the cached Kernel Updater from the HDD and not from the CD! Source: Run_Code Download: Here 3. Flashing the DVD-ROM Drive Different tactics depending on the DVD model in your box. There are some excellent Firmware Flashing Tutorials on the net, which we won't link here for site policy reasons. This does mean opening your Xbox 360 as such warranty is void, Microsoft are known to be working on a way of checking this and banning any flashed Xbox 360's from Xbox Live. 4. Buy King Kong and make an image There are two versions of King Kong available. The patcher currently does not work with the newer \"classics\" version of \"King Kong\". If in doubt, buy the oldest version you can get. Backing up won't be covered here for site policy reasons, but the net is your friend again. 5. Patch your King Kong image There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable . There is a newer patch in the wild by xorloser, which allows booting directly from CDROM. Patch your King Kong ISO with either the windows exe or compile the source for Linux. If you're using the windows patch, you will need to download cygwin1.dll and put it into your windows/system32 folder. Then make sure shader.bin, the exe, and your King Kong ISO are in the same folder and run: win_patch.exe or ./linux_patch After your ISO is patched, burn it like a normal game. Source: Included readme Download: Here 6. Get Linux \u201dThis LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB.\u201d Use the BETA v2 release or later in case you have a Samsung drive. Hitachi drive users do not need to care. You may use re-writeable medias for the distributions as they may improve now in short distances... :-) Source: LiveCD Download: Here 7. Get it started Switch on your Xbox 360, and load up the patched King Kong, and press start on the title screen. Wait until the tray opens. Insert the Linux CD. Close the tray. A few second later, you should be greeted by some penguins. 8. Install it to Harddisk (optional) Guide: [Here](https://web.archive.org/web/20100315185435/http://forums.xbox-scene.com/index.php?showtopic=595543 Debian etch install Script (Recommended) Ubuntu 7.10 install Script Category:Support","title":"King Kong Hack (outdated)"},{"location":"King_Kong_Hack/#king-kong-hack-outdated","text":"","title":"King Kong Hack (outdated)"},{"location":"King_Kong_Hack/#1-you-need-an-xbox-with-a-kernel-version-of-4532-or-4548","text":"You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version. The kernel version can be older (lower number) than 4532 or 4548, but not newer (higher number). If you already have a newer version, there is nothing you can do right now. If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it. Note, I have just got a new UK core pack with a MFG date of 19th June 2007, with all the new heatsink inside and the kernel version was one of the 2000 ones, so very old kernel on brand new xbox 360s. Note, I have just bought a premium pack with a MFG date of 16th May 2006, and the kernel version was 5759, so a new kernel on a 2006's Xbox 360. Source: Run_Code","title":"1. You need an Xbox with a kernel version of 4532 or 4548"},{"location":"King_Kong_Hack/#2-upgrading-the-kernel-to-4532","text":"If your kernel version is older than 4532 or 4548, you can update to one of these versions. Do not update to a version newer than 4598! You won't be able to downgrade! If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. IMPORTANT: If you use a HDD and previously canceled a XBOX Live Update request, then you must remove the HDD to prevent the Kernel updater using the cached Kernel Updater, which is newer then the Kernel 4532! If you don't remove the HDD, then the Kernel Updater will use the cached Kernel Updater from the HDD and not from the CD! Source: Run_Code Download: Here","title":"2. Upgrading the kernel to 4532"},{"location":"King_Kong_Hack/#3-flashing-the-dvd-rom-drive","text":"Different tactics depending on the DVD model in your box. There are some excellent Firmware Flashing Tutorials on the net, which we won't link here for site policy reasons. This does mean opening your Xbox 360 as such warranty is void, Microsoft are known to be working on a way of checking this and banning any flashed Xbox 360's from Xbox Live.","title":"3. Flashing the DVD-ROM Drive"},{"location":"King_Kong_Hack/#4-buy-king-kong-and-make-an-image","text":"There are two versions of King Kong available. The patcher currently does not work with the newer \"classics\" version of \"King Kong\". If in doubt, buy the oldest version you can get. Backing up won't be covered here for site policy reasons, but the net is your friend again.","title":"4. Buy King Kong and make an image"},{"location":"King_Kong_Hack/#5-patch-your-king-kong-image","text":"There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable . There is a newer patch in the wild by xorloser, which allows booting directly from CDROM. Patch your King Kong ISO with either the windows exe or compile the source for Linux. If you're using the windows patch, you will need to download cygwin1.dll and put it into your windows/system32 folder. Then make sure shader.bin, the exe, and your King Kong ISO are in the same folder and run: win_patch.exe or ./linux_patch After your ISO is patched, burn it like a normal game. Source: Included readme Download: Here","title":"5. Patch your King Kong image"},{"location":"King_Kong_Hack/#6-get-linux","text":"\u201dThis LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB.\u201d Use the BETA v2 release or later in case you have a Samsung drive. Hitachi drive users do not need to care. You may use re-writeable medias for the distributions as they may improve now in short distances... :-) Source: LiveCD Download: Here","title":"6. Get Linux"},{"location":"King_Kong_Hack/#7-get-it-started","text":"Switch on your Xbox 360, and load up the patched King Kong, and press start on the title screen. Wait until the tray opens. Insert the Linux CD. Close the tray. A few second later, you should be greeted by some penguins.","title":"7. Get it started"},{"location":"King_Kong_Hack/#8-install-it-to-harddisk-optional","text":"Guide: [Here](https://web.archive.org/web/20100315185435/http://forums.xbox-scene.com/index.php?showtopic=595543 Debian etch install Script (Recommended) Ubuntu 7.10 install Script Category:Support","title":"8. Install it to Harddisk (optional)"},{"location":"Level_Shifter/","text":"Level shifter Build your own To be able to debug LibXenon / XeLL stuff you want most likely a LVTTL, here is how you build one: You need: 1x MAX3232 IC 5x 0,1uF Caps 1x 9-pin D-Sub Port Solder all according to this picture. Now you just hook it up like on the diagram showed on this page: Serial Console Category:Xbox360_Hardware","title":"Level shifter"},{"location":"Level_Shifter/#level-shifter","text":"","title":"Level shifter"},{"location":"Level_Shifter/#build-your-own","text":"To be able to debug LibXenon / XeLL stuff you want most likely a LVTTL, here is how you build one: You need: 1x MAX3232 IC 5x 0,1uF Caps 1x 9-pin D-Sub Port Solder all according to this picture. Now you just hook it up like on the diagram showed on this page: Serial Console Category:Xbox360_Hardware","title":"Build your own"},{"location":"Lflash/","text":"LFlash lflash is a program released into the public domain by Felix Domke. It is able to both read and write the flash if used under linux on the 360. Currently do not attempt to read / write to large block nands found in new arcade versions (256/512 MB internal memory), as it will corrupt your file/nand. Source The source is available on the free60 GIT Repository in the tools section. Category:Xbox360_Homebrew_Software Category:Xbox360_Linux","title":"LFlash"},{"location":"Lflash/#lflash","text":"lflash is a program released into the public domain by Felix Domke. It is able to both read and write the flash if used under linux on the 360. Currently do not attempt to read / write to large block nands found in new arcade versions (256/512 MB internal memory), as it will corrupt your file/nand.","title":"LFlash"},{"location":"Lflash/#source","text":"The source is available on the free60 GIT Repository in the tools section. Category:Xbox360_Homebrew_Software Category:Xbox360_Linux","title":"Source"},{"location":"LibHomebrew/","text":"LibHomebrew libhomebrew is the idea to create an abstract homebrew library, unifying access to different hardware, making it easy to port homebrew from one console to another. Please help making this idea real! (Some more background about the idea can be found here ) libhomebrew: Basic Idea For every (hacked) hardware, there is a homebrew lib / toolchain: Libxenon for guess what ;) libogc for Wii, GameCube OpenXDK for Xbox 1 devkitPro is a toolchain for GameBoy Advance, GP32, Playstation Portable and GameCube. SDL is not technically a homebrew lib, but has been ported to many many platforms. many others I forgot here The point is: Every community is hacking their own homebrew library, reinventing/forking functionality for libc, peripherals (USB, SD/SDHC, NAND, ..), functionality (libz, libmad, ..), storage (FAT32), networking (lwip, TCP/IP, DHCP, ...), etc. It would be really great to have a generic homebrew lib! Such a lib would contain backends / modules / hardware abstraction layers, which are specific to the hardware you want to deploy, and plentiful functionality on top of these modules. All it would take to support homebrew on a new device would be writing some HAL code, et voila: all the homebrew apps based on libhomebrew run on your new shiny device. Scope Homebrew libraries tend to cover these common areas: Input (joystick, buttons) Graphics (2d, 3d -- framebuffer?) Sound -- waveform, synthesized, mp3/ogg, etc Storage -- FAT, SD Networking -- TCP/IP, UDP USB? These would be good areas to start with. What has to be done? First, we need some coders from different homebrew scenes to sit together and find similarities in their projects. Then we need them to write the code ;-) Ok ok, all that needs to be done is an abstract interface on top of the existing homebrew libraries . Thats not so much to do after all. Then we can merge the different forks of generic functionality code together and remove it from the backends. Easy, eh? Why not taking Linux? That might actually be an option, however the Linux kernel is rather bloated with its lengthy boot-up times, drivers for things you don't quite need for homebrew and other aspects. Plus, sometimes you want a base which is not locking you in on GPL. However, you could add Linux as a HAL backend to libhomebrew instead! Linux advantage is there is already a lot of software available. So getting the little stuff missing in Linux working -decent video driver to get HDMI output and 1920x1080 support, initializing CPUs to fullspeed, perhaps a nice, easy installer- will be a nice middle step while we get better homebrew. XBox 360 Linux XMBC DVBT HD Tuner can be a sexy combination that will take too much effort doing from scratch, for example. Why not taking L4? It has been suggested to use the L4 Microkernel for aspects like multi-threading / scheduling / task switching. It has to be evaluated if it is possible to add L4 as a library without building the whole system on top of it. Why not taking Libpayload? Libpayload is part of the coreboot project. It is an abstraction library meant for easy deployment of code in boot-loader-comparable environments. It is focused mainly on x86, but looks like a promising ground. It contains its own libc implementation, whereas most homebrew projects are using newlib instead. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"LibHomebrew"},{"location":"LibHomebrew/#libhomebrew","text":"libhomebrew is the idea to create an abstract homebrew library, unifying access to different hardware, making it easy to port homebrew from one console to another. Please help making this idea real! (Some more background about the idea can be found here )","title":"LibHomebrew"},{"location":"LibHomebrew/#libhomebrew-basic-idea","text":"For every (hacked) hardware, there is a homebrew lib / toolchain: Libxenon for guess what ;) libogc for Wii, GameCube OpenXDK for Xbox 1 devkitPro is a toolchain for GameBoy Advance, GP32, Playstation Portable and GameCube. SDL is not technically a homebrew lib, but has been ported to many many platforms. many others I forgot here The point is: Every community is hacking their own homebrew library, reinventing/forking functionality for libc, peripherals (USB, SD/SDHC, NAND, ..), functionality (libz, libmad, ..), storage (FAT32), networking (lwip, TCP/IP, DHCP, ...), etc. It would be really great to have a generic homebrew lib! Such a lib would contain backends / modules / hardware abstraction layers, which are specific to the hardware you want to deploy, and plentiful functionality on top of these modules. All it would take to support homebrew on a new device would be writing some HAL code, et voila: all the homebrew apps based on libhomebrew run on your new shiny device.","title":"libhomebrew: Basic Idea"},{"location":"LibHomebrew/#scope","text":"Homebrew libraries tend to cover these common areas: Input (joystick, buttons) Graphics (2d, 3d -- framebuffer?) Sound -- waveform, synthesized, mp3/ogg, etc Storage -- FAT, SD Networking -- TCP/IP, UDP USB? These would be good areas to start with.","title":"Scope"},{"location":"LibHomebrew/#what-has-to-be-done","text":"First, we need some coders from different homebrew scenes to sit together and find similarities in their projects. Then we need them to write the code ;-) Ok ok, all that needs to be done is an abstract interface on top of the existing homebrew libraries . Thats not so much to do after all. Then we can merge the different forks of generic functionality code together and remove it from the backends. Easy, eh?","title":"What has to be done?"},{"location":"LibHomebrew/#why-not-taking-linux","text":"That might actually be an option, however the Linux kernel is rather bloated with its lengthy boot-up times, drivers for things you don't quite need for homebrew and other aspects. Plus, sometimes you want a base which is not locking you in on GPL. However, you could add Linux as a HAL backend to libhomebrew instead! Linux advantage is there is already a lot of software available. So getting the little stuff missing in Linux working -decent video driver to get HDMI output and 1920x1080 support, initializing CPUs to fullspeed, perhaps a nice, easy installer- will be a nice middle step while we get better homebrew. XBox 360 Linux XMBC DVBT HD Tuner can be a sexy combination that will take too much effort doing from scratch, for example.","title":"Why not taking Linux?"},{"location":"LibHomebrew/#why-not-taking-l4","text":"It has been suggested to use the L4 Microkernel for aspects like multi-threading / scheduling / task switching. It has to be evaluated if it is possible to add L4 as a library without building the whole system on top of it.","title":"Why not taking L4?"},{"location":"LibHomebrew/#why-not-taking-libpayload","text":"Libpayload is part of the coreboot project. It is an abstraction library meant for easy deployment of code in boot-loader-comparable environments. It is focused mainly on x86, but looks like a promising ground. It contains its own libc implementation, whereas most homebrew projects are using newlib instead. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"Why not taking Libpayload?"},{"location":"LibXenon/","text":"LibXenon Summary libXenon is a library for writing programs for the Xbox 360, without using any existing code as a basis. That means that the resulting binaries should be free code, and don't contain stuff which would be illegal to distribute. This also means that you don't have to rely on Linux, which gives some advantages regarding system utilization. Getting libXenon libXenon is work-in-progress, and is available from Free60 Git Repository You can check out the source code using git with the following command: git clone git://github.com/Free60Project/libxenon.git (Windows users may want to try TortoiseGit) Installing libXenon To use libXenon you need a proper isntallation of Xenon Toolchain first. You just go into the toolchain-directory which holds build-xenon-toolchain and execute: ./build-xenon-toolchain libxenon This will download and install a fresh copy of libXenon Libraries to the $DEVKITXENON -path (Which should be defined in your ~/.bashrc already! - See bottom of Xenon Toolchain -page if it isn't!) Support libXenon (or devkitxenon ) stuff is best discussed in #free60-noos on the OFTC IRC network , or in #libXenon on EFnet IRC, Sample Code Example code illustrating libXenon use can be found on the LibXenon Examples page. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"LibXenon"},{"location":"LibXenon/#libxenon","text":"","title":"LibXenon"},{"location":"LibXenon/#summary","text":"libXenon is a library for writing programs for the Xbox 360, without using any existing code as a basis. That means that the resulting binaries should be free code, and don't contain stuff which would be illegal to distribute. This also means that you don't have to rely on Linux, which gives some advantages regarding system utilization.","title":"Summary"},{"location":"LibXenon/#getting-libxenon","text":"libXenon is work-in-progress, and is available from Free60 Git Repository You can check out the source code using git with the following command: git clone git://github.com/Free60Project/libxenon.git (Windows users may want to try TortoiseGit)","title":"Getting libXenon"},{"location":"LibXenon/#installing-libxenon","text":"To use libXenon you need a proper isntallation of Xenon Toolchain first. You just go into the toolchain-directory which holds build-xenon-toolchain and execute: ./build-xenon-toolchain libxenon This will download and install a fresh copy of libXenon Libraries to the $DEVKITXENON -path (Which should be defined in your ~/.bashrc already! - See bottom of Xenon Toolchain -page if it isn't!)","title":"Installing libXenon"},{"location":"LibXenon/#support","text":"libXenon (or devkitxenon ) stuff is best discussed in #free60-noos on the OFTC IRC network , or in #libXenon on EFnet IRC,","title":"Support"},{"location":"LibXenon/#sample-code","text":"Example code illustrating libXenon use can be found on the LibXenon Examples page. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"Sample Code"},{"location":"LibXenon_Examples/","text":"LibXenon examples XMENU source code by cpasjuste Download: libxenon.org Genesis Plus + SMS Plus source code by ced2911 Genesis Plus: http://www.multiupload.com/6QYQL218GB SMS Plus: http://www.multiupload.com/62T7RVYB5A Controller Button test code by ced2911 Source Code (incl. Makefile): Download #include <stdio.h> #include <stdlib.h> #include <input/input.h> #include <xenos/xenos.h> #include <console/console.h> void mainInit() { //init xenos_init(); console_init(); kmem_init(); usb_init(); usb_do_poll(); } int main() { mainInit(); printf(\"Test\\n\"); struct controller_data_s oldc; while(1) { struct controller_data_s c; if (get_controller_data(&c, 0)) { if((c.a)&&(!oldc.a)) { printf(\"a pushed\\n\"); } if((!c.a)&&(oldc.a)) { printf(\"a released\\n\"); } oldc=c; } usb_do_poll(); } return 0; } Compiling LibXenon Code All of these samples/programs include a Makefile, so its easy to compile them with the Toolchain . cd into_the_directory make CROSS_COMPILE=xenon- When you are writing your own programs you can just take the Makefile from this HelloWorld application, put it in your sourcecode-folder and move all the sourcecode-files of your project into a folder \"source\" so the Makefile can find them. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"LibXenon examples"},{"location":"LibXenon_Examples/#libxenon-examples","text":"","title":"LibXenon examples"},{"location":"LibXenon_Examples/#xmenu-source-code-by-cpasjuste","text":"Download: libxenon.org","title":"XMENU source code by cpasjuste"},{"location":"LibXenon_Examples/#genesis-plus-sms-plus-source-code-by-ced2911","text":"Genesis Plus: http://www.multiupload.com/6QYQL218GB SMS Plus: http://www.multiupload.com/62T7RVYB5A","title":"Genesis Plus + SMS Plus source code by ced2911"},{"location":"LibXenon_Examples/#controller-button-test-code-by-ced2911","text":"Source Code (incl. Makefile): Download #include <stdio.h> #include <stdlib.h> #include <input/input.h> #include <xenos/xenos.h> #include <console/console.h> void mainInit() { //init xenos_init(); console_init(); kmem_init(); usb_init(); usb_do_poll(); } int main() { mainInit(); printf(\"Test\\n\"); struct controller_data_s oldc; while(1) { struct controller_data_s c; if (get_controller_data(&c, 0)) { if((c.a)&&(!oldc.a)) { printf(\"a pushed\\n\"); } if((!c.a)&&(oldc.a)) { printf(\"a released\\n\"); } oldc=c; } usb_do_poll(); } return 0; }","title":"Controller Button test code by ced2911"},{"location":"LibXenon_Examples/#compiling-libxenon-code","text":"All of these samples/programs include a Makefile, so its easy to compile them with the Toolchain . cd into_the_directory make CROSS_COMPILE=xenon- When you are writing your own programs you can just take the Makefile from this HelloWorld application, put it in your sourcecode-folder and move all the sourcecode-files of your project into a folder \"source\" so the Makefile can find them. Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"Compiling LibXenon Code"},{"location":"Links/","text":"Links Modding Community Xbox Hacker (archive.org) Xbox-Scene (mirror) Xbox Dream (archive.org) Coding Guides Unsigned Xbox 360 Developer Best Practice at xbox.com (archive.org) Articles of Note Xbox 360 Fact Sheet at xbox.com (archiv.org) Inside Microsoft's Xbox 360 at anandtech.com Inside the Xbox 360, Part I at arstechnica.com Inside the Xbox 360, Part II: the Xenon CPU at arstechnica.com [The scoop on the Xbox 360's embedded OS]https://web.archive.org/web/20090506110028/http://www.windowsfordevices.com/news/NS3988467635.html) at windowsfordevices.com (archive.org) Chipworks First Inside Microsoft's Xbox 360 Silicon (archive.org) IBMs Hypervisor project or archive.org mirror Media Center Extender Hardware Requirements Photos More 360 pictures (somewhere in .eu?) High resolution motherboard pic, with heatsinks (from informit.com article) Lot of pictures , archive.org mirror Disassembly How to Disassemble the \"Screwless\" Xbox 360 at digg.com (archiv.org) Xbox 360 Exposed Category:Support","title":"Links"},{"location":"Links/#links","text":"","title":"Links"},{"location":"Links/#modding-community","text":"Xbox Hacker (archive.org) Xbox-Scene (mirror) Xbox Dream (archive.org)","title":"Modding Community"},{"location":"Links/#coding-guides","text":"Unsigned Xbox 360 Developer Best Practice at xbox.com (archive.org)","title":"Coding Guides"},{"location":"Links/#articles-of-note","text":"Xbox 360 Fact Sheet at xbox.com (archiv.org) Inside Microsoft's Xbox 360 at anandtech.com Inside the Xbox 360, Part I at arstechnica.com Inside the Xbox 360, Part II: the Xenon CPU at arstechnica.com [The scoop on the Xbox 360's embedded OS]https://web.archive.org/web/20090506110028/http://www.windowsfordevices.com/news/NS3988467635.html) at windowsfordevices.com (archive.org) Chipworks First Inside Microsoft's Xbox 360 Silicon (archive.org) IBMs Hypervisor project or archive.org mirror Media Center Extender Hardware Requirements","title":"Articles of Note"},{"location":"Links/#photos","text":"More 360 pictures (somewhere in .eu?) High resolution motherboard pic, with heatsinks (from informit.com article) Lot of pictures , archive.org mirror","title":"Photos"},{"location":"Links/#disassembly","text":"How to Disassemble the \"Screwless\" Xbox 360 at digg.com (archiv.org) Xbox 360 Exposed Category:Support","title":"Disassembly"},{"location":"Linux_Distros/","text":"Linux distributions LiveCD Ubuntu7.10 Debian-etch Debian-lenny Debian-squeeze Category:Xbox360_Linux","title":"Linux distributions"},{"location":"Linux_Distros/#linux-distributions","text":"LiveCD Ubuntu7.10 Debian-etch Debian-lenny Debian-squeeze Category:Xbox360_Linux","title":"Linux distributions"},{"location":"Linux_Kernel/","text":"Linux Kernel There is a set of 7 patches available sent to the linuxppc mailing list on 08 March 2007, which have to be applied to Linux 2.6.20. If you're interested in kernel development and/or adding new features, please take a look at Linux Kernel Development . (patch 1/7) xenon: add PCI Vendor ID: Microsoft (patch 2/7) xenon: add platform support (patch 3/7) xenon: udbg support (ugly) (patch 4/7) xenon: add southbridge ethernet support (patch 5/7) xenon: add SATA support (patch 6/7) xenon: add SMC support (patch 7/7) xenon: add framebuffer support (ugly) To run linux, you need to use XeLL Bootloader available right now. To compile the kernel, you need to set up a Cross compiler toolchain (unless you already have another PowerPC Linux machine). Prerequisites The minimal requirements for successfully cross compiling the Linux Kernel for your Xbox are (unverified): A machine running a Linux based OS (most likely your PC) Sources for the Linux Kernel The Xenon patch or patchset Binutils (targeting the powerpc architecture) GCC (targeting the powerpc architecture) Configuring and Compiling the Kernel Get the source for the Kernel from kernel.org and unpack it. cd /usr/src wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.tar.bz2 tar -xvjf linux-2.6.21.tar.bz2 Download and apply the Xenon patch/patchset matching your kernel. cd linux-2.6.21/ for patch in pci_ids.h.diff linux-2.6.21-xenon-cpu.diff linux-2.6.21-xenon.diff \\ linux-2.6.21-xenon-enet.diff linux-2.6.21-xenon-platform.diff \\ linux-2.6.21-xenon-sata.diff linux-2.6.21-xenon-smc.diff \\ linux-2.6.21-xenon-ugly-fb.diff linux-2.6.21-xenon-ugly-udbg.diff \\ interlace.diff ; do wget http://op-co.de/xbox360/2.6.21/$patch patch -p1 < $patch done Configure the Kernel. You can manually fetch a configuration file from the internet (e.g. here) and type: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- oldconfig Of course, you can fine-tune your Kernel configuration to fit your needs using make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- menuconfig Build the Kernel by typing: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- all If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by XeLL . Configuring and Compiling the 2.6.38.8 Kernel (experimental) Patches for recent kernels are available now, but considered highly experimental. Get the source for the Linux 2.6.38.8 Kernel from kernel.org and unpack it. wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.38.8.tar.bz2 tar -xvjf linux-2.6.38.8.tar.bz2 Download and apply the experimental Xenon patch & kernel config. wget -O xenon_config http://sourceforge.net/projects/free60/files/Linux%20Kernel/xenon_config/download wget -O patch-2.6.38.8-xbox0.11.1.diff http://sourceforge.net/projects/free60/files/Linux%20Kernel/v2.6.38/patch-2.6.38.8-xbox0.11.1.diff/download cd linux-2.6.38.8/ patch -p1 < ../patch-2.6.38.8-xbox0.11.1.diff cp ../xenon_config .config Configure the Kernel. make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- menuconfig Build the Kernel by typing: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- all If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by the XeLL. Remember, these patches are Experimental! Rootfilesystem via NFS Configure the kernel (CONFIG_CMDLINE in .config) for NFS (see NFS-Tutorial for details) to match your local setup. Example: CONFIG_CMDLINE=\"root=nfs video=xenonfb console=tty0 nfsroot=192.168.1.1:/mnt/nfsroot/xbox rw ip=dhcp\" 2. Make sure that the IP Plug and Play ( CONFIG_IP_PNP* in .config) options match your ip setup method. Pre-compiled Kernels http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz (archive.org) Category:Xbox360_Linux","title":"Linux Kernel"},{"location":"Linux_Kernel/#linux-kernel","text":"There is a set of 7 patches available sent to the linuxppc mailing list on 08 March 2007, which have to be applied to Linux 2.6.20. If you're interested in kernel development and/or adding new features, please take a look at Linux Kernel Development . (patch 1/7) xenon: add PCI Vendor ID: Microsoft (patch 2/7) xenon: add platform support (patch 3/7) xenon: udbg support (ugly) (patch 4/7) xenon: add southbridge ethernet support (patch 5/7) xenon: add SATA support (patch 6/7) xenon: add SMC support (patch 7/7) xenon: add framebuffer support (ugly) To run linux, you need to use XeLL Bootloader available right now. To compile the kernel, you need to set up a Cross compiler toolchain (unless you already have another PowerPC Linux machine).","title":"Linux Kernel"},{"location":"Linux_Kernel/#prerequisites","text":"The minimal requirements for successfully cross compiling the Linux Kernel for your Xbox are (unverified): A machine running a Linux based OS (most likely your PC) Sources for the Linux Kernel The Xenon patch or patchset Binutils (targeting the powerpc architecture) GCC (targeting the powerpc architecture)","title":"Prerequisites"},{"location":"Linux_Kernel/#configuring-and-compiling-the-kernel","text":"Get the source for the Kernel from kernel.org and unpack it. cd /usr/src wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.21.tar.bz2 tar -xvjf linux-2.6.21.tar.bz2 Download and apply the Xenon patch/patchset matching your kernel. cd linux-2.6.21/ for patch in pci_ids.h.diff linux-2.6.21-xenon-cpu.diff linux-2.6.21-xenon.diff \\ linux-2.6.21-xenon-enet.diff linux-2.6.21-xenon-platform.diff \\ linux-2.6.21-xenon-sata.diff linux-2.6.21-xenon-smc.diff \\ linux-2.6.21-xenon-ugly-fb.diff linux-2.6.21-xenon-ugly-udbg.diff \\ interlace.diff ; do wget http://op-co.de/xbox360/2.6.21/$patch patch -p1 < $patch done Configure the Kernel. You can manually fetch a configuration file from the internet (e.g. here) and type: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- oldconfig Of course, you can fine-tune your Kernel configuration to fit your needs using make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- menuconfig Build the Kernel by typing: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- all If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by XeLL .","title":"Configuring and Compiling the Kernel"},{"location":"Linux_Kernel/#configuring-and-compiling-the-26388-kernel-experimental","text":"Patches for recent kernels are available now, but considered highly experimental. Get the source for the Linux 2.6.38.8 Kernel from kernel.org and unpack it. wget http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.38.8.tar.bz2 tar -xvjf linux-2.6.38.8.tar.bz2 Download and apply the experimental Xenon patch & kernel config. wget -O xenon_config http://sourceforge.net/projects/free60/files/Linux%20Kernel/xenon_config/download wget -O patch-2.6.38.8-xbox0.11.1.diff http://sourceforge.net/projects/free60/files/Linux%20Kernel/v2.6.38/patch-2.6.38.8-xbox0.11.1.diff/download cd linux-2.6.38.8/ patch -p1 < ../patch-2.6.38.8-xbox0.11.1.diff cp ../xenon_config .config Configure the Kernel. make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- menuconfig Build the Kernel by typing: make ARCH=powerpc CROSS_COMPILE=powerpc64-unknown-linux-gnu- all If everything goes well, you will end up with a file arch/powerpc/boot/zImage.xenon containing the kernel which can be loaded by the XeLL. Remember, these patches are Experimental!","title":"Configuring and Compiling the 2.6.38.8 Kernel (experimental)"},{"location":"Linux_Kernel/#rootfilesystem-via-nfs","text":"Configure the kernel (CONFIG_CMDLINE in .config) for NFS (see NFS-Tutorial for details) to match your local setup. Example: CONFIG_CMDLINE=\"root=nfs video=xenonfb console=tty0 nfsroot=192.168.1.1:/mnt/nfsroot/xbox rw ip=dhcp\" 2. Make sure that the IP Plug and Play ( CONFIG_IP_PNP* in .config) options match your ip setup method.","title":"Rootfilesystem via NFS"},{"location":"Linux_Kernel/#pre-compiled-kernels","text":"http://home.comcast.net/~ssmurf/XeLL-Bootloader-sda2-v2.6.24.3.tar.gz (archive.org) Category:Xbox360_Linux","title":"Pre-compiled Kernels"},{"location":"Linux_Kernel_Development/","text":"Linux kernel development Currently we have the following patches working against 2.6.33 kernel: PCI: adding PCI_VENDOR_ID_MICROSOFT (trivial) Xenon CPU: adding Xenon into cputable Xenon Platform: adding Interrupt controller, SMP support, setup Xenon SATA: adding the sata_xenon libata driver Xenon SMC: adding support for the SMC , including RTC and communication with Ana. Xenon FB (ugly): adding support for tiled framebuffer Sound Support Pad Support User:Bertl is currently working on them. Please contact him you want to help on the IRC . Currently missing are: A sane way for framebuffer support. Better graphics support (changing resolutions etc.). We need to add the GPU to the Xell OF tree so Linux detects it correctly. We can probably reuse great part of the ATI/AMD open source drivers available. IR remote support Category:Xbox360_Linux","title":"Linux kernel development"},{"location":"Linux_Kernel_Development/#linux-kernel-development","text":"Currently we have the following patches working against 2.6.33 kernel: PCI: adding PCI_VENDOR_ID_MICROSOFT (trivial) Xenon CPU: adding Xenon into cputable Xenon Platform: adding Interrupt controller, SMP support, setup Xenon SATA: adding the sata_xenon libata driver Xenon SMC: adding support for the SMC , including RTC and communication with Ana. Xenon FB (ugly): adding support for tiled framebuffer Sound Support Pad Support User:Bertl is currently working on them. Please contact him you want to help on the IRC . Currently missing are: A sane way for framebuffer support. Better graphics support (changing resolutions etc.). We need to add the GPU to the Xell OF tree so Linux detects it correctly. We can probably reuse great part of the ATI/AMD open source drivers available. IR remote support Category:Xbox360_Linux","title":"Linux kernel development"},{"location":"List_of_PC_utilities/","text":"List of PC utilities PC Utilities Title Description NandCompare Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. NANDPro Read/write NAND dumps and repair the spare bytes / ECC sections. It can also flash CPLDs or log POST-Codes. 360FlashTool Display, Decrypt and extract various parts of an Xbox NAND dump. Category:Xbox360_Homebrew_Software","title":"List of PC utilities"},{"location":"List_of_PC_utilities/#list-of-pc-utilities","text":"","title":"List of PC utilities"},{"location":"List_of_PC_utilities/#pc-utilities","text":"Title Description NandCompare Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. NANDPro Read/write NAND dumps and repair the spare bytes / ECC sections. It can also flash CPLDs or log POST-Codes. 360FlashTool Display, Decrypt and extract various parts of an Xbox NAND dump. Category:Xbox360_Homebrew_Software","title":"PC Utilities"},{"location":"List_of_Unix_Distributions/","text":"List of Unix distributions Live CDs Title Description LiveCD Linux Live-CDs Install Scripts Title Description Ubuntu7.10 Linux Deboostrap-script for Ubuntu 7.10 \"Gutsy\" Ubuntu11.10 Linux Deboostrap-script for Ubuntu 11.10 \"Oneiric\" Debian-etch Linux Deboostrap-script for Debian 4 \"etch\" Debian-lenny Linux Deboostrap-script for Debian 5 \"lenny\" Debian-squeeze Linux Deboostrap-script for Debian 6 \"squeeze\" Category:Xbox360_Linux","title":"List of Unix distributions"},{"location":"List_of_Unix_Distributions/#list-of-unix-distributions","text":"","title":"List of Unix distributions"},{"location":"List_of_Unix_Distributions/#live-cds","text":"Title Description LiveCD Linux Live-CDs","title":"Live CDs"},{"location":"List_of_Unix_Distributions/#install-scripts","text":"Title Description Ubuntu7.10 Linux Deboostrap-script for Ubuntu 7.10 \"Gutsy\" Ubuntu11.10 Linux Deboostrap-script for Ubuntu 11.10 \"Oneiric\" Debian-etch Linux Deboostrap-script for Debian 4 \"etch\" Debian-lenny Linux Deboostrap-script for Debian 5 \"lenny\" Debian-squeeze Linux Deboostrap-script for Debian 6 \"squeeze\" Category:Xbox360_Linux","title":"Install Scripts"},{"location":"List_of_development_tools/","text":"List of development tools These Development Tools can help you develop legal homebrew applications and games for the Xbox 360. The most important tool for Xbox 360 development is Xenon Toolchain , a port of the GCC toolchain along with supporting system libraries. The development tools listed below make development easier or to add additional functionality. Core development Title Description Xenon_Toolchain GCC Cross Compiler and associated utilities LibXenon Library to interact with xbox360 specific Hardware Framework libraries Title Description Author Placeholder Placeholder Description Placeholder Libraries Title Description Author Placeholder Placeholder Description Placeholder Ported Libraries Title Description Ported by libext2fs Ext2FS driver (ported from libext2fs-wii) Ced2911 libntfs NTFS driver using NTFS-3G (ported from libntfs-wii) Ced2911 libfat FAT filesystem driver Ced2911 Resources Title Description Author Placeholder Placeholder Description Placeholder Category:Xbox360_Development","title":"List of development tools"},{"location":"List_of_development_tools/#list-of-development-tools","text":"These Development Tools can help you develop legal homebrew applications and games for the Xbox 360. The most important tool for Xbox 360 development is Xenon Toolchain , a port of the GCC toolchain along with supporting system libraries. The development tools listed below make development easier or to add additional functionality.","title":"List of development tools"},{"location":"List_of_development_tools/#core-development","text":"Title Description Xenon_Toolchain GCC Cross Compiler and associated utilities LibXenon Library to interact with xbox360 specific Hardware","title":"Core development"},{"location":"List_of_development_tools/#framework-libraries","text":"Title Description Author Placeholder Placeholder Description Placeholder","title":"Framework libraries"},{"location":"List_of_development_tools/#libraries","text":"Title Description Author Placeholder Placeholder Description Placeholder","title":"Libraries"},{"location":"List_of_development_tools/#ported-libraries","text":"Title Description Ported by libext2fs Ext2FS driver (ported from libext2fs-wii) Ced2911 libntfs NTFS driver using NTFS-3G (ported from libntfs-wii) Ced2911 libfat FAT filesystem driver Ced2911","title":"Ported Libraries"},{"location":"List_of_development_tools/#resources","text":"Title Description Author Placeholder Placeholder Description Placeholder Category:Xbox360_Development","title":"Resources"},{"location":"List_of_homebrew_applications/","text":"List of homebrew applications Applications Title Description Author XMENU A .elf launcher with customizable backgrounds. Created legally using LibXenon cpasjuste ZLX_Browser A nice-looking filemanager based on the ZLX_Library ced2911 XMPlayer A media player ported to the xbox 360 using LibXenon. ced2911 Category:Xbox360_Homebrew_Software","title":"List of homebrew applications"},{"location":"List_of_homebrew_applications/#list-of-homebrew-applications","text":"","title":"List of homebrew applications"},{"location":"List_of_homebrew_applications/#applications","text":"Title Description Author XMENU A .elf launcher with customizable backgrounds. Created legally using LibXenon cpasjuste ZLX_Browser A nice-looking filemanager based on the ZLX_Library ced2911 XMPlayer A media player ported to the xbox 360 using LibXenon. ced2911 Category:Xbox360_Homebrew_Software","title":"Applications"},{"location":"List_of_homebrew_emulators/","text":"List of homebrew emulators Emulators Title Description Mupen64-360 Mupen64-360 is a Nintendo64 emulator, it's a port of Wii64 (which itself was a port of Mupen64). PCSXR-Xenon Pcsxr-xenon is a Sony playstation 1 emulator, based on lastest PCSX-Reloaded source code Sega_Genesis_Plus_GX Sega Genesis Plus GX is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles. Sega_Master_System_Plus Sega Master Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles. Snes9x-Gx The first SNES emulator to run natively on the xbox 360 created using LibXenon Category:Xbox360_Homebrew_Software","title":"List of homebrew emulators"},{"location":"List_of_homebrew_emulators/#list-of-homebrew-emulators","text":"","title":"List of homebrew emulators"},{"location":"List_of_homebrew_emulators/#emulators","text":"Title Description Mupen64-360 Mupen64-360 is a Nintendo64 emulator, it's a port of Wii64 (which itself was a port of Mupen64). PCSXR-Xenon Pcsxr-xenon is a Sony playstation 1 emulator, based on lastest PCSX-Reloaded source code Sega_Genesis_Plus_GX Sega Genesis Plus GX is a freeware, open-source, portable emulator for the Genesis and MegaDrive consoles. Sega_Master_System_Plus Sega Master Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles. Snes9x-Gx The first SNES emulator to run natively on the xbox 360 created using LibXenon Category:Xbox360_Homebrew_Software","title":"Emulators"},{"location":"List_of_homebrew_games/","text":"List of homebrew games Games Title Description Pong The game of the year : PONG Tanks_360 A game with shooting tanks SDLQuake The famous FPS Quake, built via SDL Category:Xbox360_Homebrew_Software","title":"List of homebrew games"},{"location":"List_of_homebrew_games/#list-of-homebrew-games","text":"","title":"List of homebrew games"},{"location":"List_of_homebrew_games/#games","text":"Title Description Pong The game of the year : PONG Tanks_360 A game with shooting tanks SDLQuake The famous FPS Quake, built via SDL Category:Xbox360_Homebrew_Software","title":"Games"},{"location":"List_of_homebrew_loaders/","text":"List of homebrew loaders Homebrew Loaders Title Description XeLL The original Xenon Linux Loader. Doesn't work on Reset_Glitch_Hack XeLLous Xenon Linux Loader modification by Redline99. Doesn't work on Reset_Glitch_Hack XeLL_Reloaded Xenon Linux Loader RELOADED . Consists of 2 stages, works on both, JTAG and RGH Category:Xbox360_Homebrew_Software","title":"List of homebrew loaders"},{"location":"List_of_homebrew_loaders/#list-of-homebrew-loaders","text":"","title":"List of homebrew loaders"},{"location":"List_of_homebrew_loaders/#homebrew-loaders","text":"Title Description XeLL The original Xenon Linux Loader. Doesn't work on Reset_Glitch_Hack XeLLous Xenon Linux Loader modification by Redline99. Doesn't work on Reset_Glitch_Hack XeLL_Reloaded Xenon Linux Loader RELOADED . Consists of 2 stages, works on both, JTAG and RGH Category:Xbox360_Homebrew_Software","title":"Homebrew Loaders"},{"location":"List_of_system_tools/","text":"List of system tools System Tools Title Description Lflash A NAND Flasher for xbox360, currently only working with 16MB NAND. For use with Linux. Dumpana Tool for dumping ANA (Graphic Scaler Chip) registers. For use with Linux. Rawflash A tool for flashing rawimages (already properly remapped) to NAND, directly via LibXenon application. Category:Xbox360_Homebrew_Software","title":"List of system tools"},{"location":"List_of_system_tools/#list-of-system-tools","text":"","title":"List of system tools"},{"location":"List_of_system_tools/#system-tools","text":"Title Description Lflash A NAND Flasher for xbox360, currently only working with 16MB NAND. For use with Linux. Dumpana Tool for dumping ANA (Graphic Scaler Chip) registers. For use with Linux. Rawflash A tool for flashing rawimages (already properly remapped) to NAND, directly via LibXenon application. Category:Xbox360_Homebrew_Software","title":"System Tools"},{"location":"LiveCD/","text":"Live CDs Thanks to Cpasjuste and stonersmurf, we now have three Live-CDs! See First Steps for a step-by-step tutorial on running them. Note: Samsung drives are supported on the Gentoo LiveCD BETA v2, only. Gentoo Minimal 2006.1 Get it from here! https://downloads.sourceforge.net/free60/gentoo-xenon-minimal-2006.1.tar.bz2 This LiveCD is based on the minimal Gentoo Live-CD, so it doesn't offer X. But download size is reasonable at around 90MB. Gentoo LiveCD BETA Get it from here! http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta.tar.bz2 This LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB. Gentoo LiveCD BETA v2 Get it from here! http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta-v2.iso md5 sum Release Notes It is the second revision of the Gentoo LiveCD BETA including the latest kernel updates for the Xbox 360. Download size is around 621MB. Category:Xbox360_Linux","title":"Live CDs"},{"location":"LiveCD/#live-cds","text":"Thanks to Cpasjuste and stonersmurf, we now have three Live-CDs! See First Steps for a step-by-step tutorial on running them. Note: Samsung drives are supported on the Gentoo LiveCD BETA v2, only. Gentoo Minimal 2006.1 Get it from here! https://downloads.sourceforge.net/free60/gentoo-xenon-minimal-2006.1.tar.bz2 This LiveCD is based on the minimal Gentoo Live-CD, so it doesn't offer X. But download size is reasonable at around 90MB. Gentoo LiveCD BETA Get it from here! http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta.tar.bz2 This LiveCD is based on the BETA Gentoo LiveCD. It includes our X.org framebuffer driver and a Gnome Desktop environment. Download size is around 600MB. Gentoo LiveCD BETA v2 Get it from here! http://downloads.sourceforge.net/free60/gentoo-livecd-xenon-beta-v2.iso md5 sum Release Notes It is the second revision of the Gentoo LiveCD BETA including the latest kernel updates for the Xbox 360. Download size is around 621MB. Category:Xbox360_Linux","title":"Live CDs"},{"location":"Media_Remote/","text":"Media remote General Information Standard Media Remote\u2022The standard remote (as opposed to the Universal Media Remote) was only released in limited quantities with Xbox 360 premium packages at launch. The difference between the Universal Media Remote and the Standard Remote appears to just be the button additions. The remote uses the IR port located on the front of the Xbox 360. Some Windows Media Center Edition computers recognize this remote as a normal Media Center remote. Confirmed Facts All Windows Media Center remotes are recognized by the Xbox 360. Linux Facts Big remote Big remote IRCODE , Function {'26','Button Y'}, {'25','Button B'}, {'24','DVD menu'}, {'23','BACK'}, {'22','OK'}, {'20','Button left'}, {'21','Button right'}, {'19','Stop button'}, {'18','Pause button'}, {'17','Rec button'}, {'16','Play button'}, {'15','Fast rewind \\<\\<'}, {'14','fast foward >>'}, {'11','Volume down'}, {'10','Volume up'}, {'09','Button 9 on ke*ypad part'}, {'08','Button 8 on ke*ypad part'}, {'07','Button 7 on ke*ypad part'}, {'06','Button 6 on ke*ypad part'}, {'05','Button 5 on ke*ypad part'}, {'04','Button 4 on keypad part'}, {'03','Button 3 on keypad part'}, {'02','Button 2 on keypad part'}, {'01','Button 1 on keypad part'}, {'00','Button 0 on keypad part'}, {'1a','Go to ending >|'}, {'1b','Go to beginning |\\<'}, {'1c','Unknown'}, {'1d','100 on remote'}, {'1e','Button up'}, {'1f','Button down'}, {'0a','Clear'}, {'0b','ENTER'}, {'0c','Unknown'}, {'0d','Windows Media Start'}, {'0e','Mute'}, {'0f','Info'}, {'4f','Display'}, {'51','Title'}, {'64','Big X button on top, use as alternative 'on'?'}, {'68','Button X'}, {'66','Button A '}, {'6c','Channel up'}, {'6d','Channel down'}; the small remote 'image insert here' IRCODE , Function {'64','guide'}, {'19','stop'}, {'18','pause'}, {'16','play'}, {'15','rewind'}, {'14','fast forward'}, {'1A','chapter next'}, {'1B','chapter prev'}, {'4F','display'}, {'51','title'}, {'24','dvd menu'}, {'23','back'}, {'0F','info'}, {'1E','up'}, {'1F','down'}, {'20','left'}, {'21','right'}, {'22','ok'}, {'12','A'}, {'25','B'}, {'13','X'}, {'26','Y'}, {'0D','windows'}, {'17','record'}; Proof of concept code by Icekiller /* * Example code of how to use the build in IR of the xbox 360 * Code rewritten based on tmbinc's smc.c * free to use under GPL * * 20 januari 2008 by Icekiller */ #include <stdio.h> #include <stdlib.h> #include <fcntl.h> #include <getopt.h> #include <string.h> #include <time.h> #define SMC_FILENAME \"/dev/smc\" int smc_fd; void wait(int seconds) { clock_t endwait; endwait = clock() + seconds * CLOCKS_PER_SEC; while (clock() < endwait) { } } int main(int argc, char **argv) { int first = 1; /* try open SMC. if this doesn't work, bail out. */ smc_fd = open(SMC_FILENAME, O_RDWR); if (smc_fd < 0) { perror(SMC_FILENAME); return 1; } while (1) { unsigned char msg[16]; int option_index = 0, c; msg[0] = 0x16; /* prepare message */ memset(msg, 0, 16); if (c != 'w') { msg[0] = 0x16; int i; if (write(smc_fd, msg, 16) != 16) { perror(\"write\"); break; } } if ((c == 'w') || (msg[0] < 0x80)) { int wait_for = msg[0]; while (1) { msg[0] = 0x16; if (read(smc_fd, msg, 16) != 16) perror(\"read\"); int valueread; valueread = msg[3]; if (msg[0] != 0x16) switch (valueread) { case 0x26: printf(\"Button Y\"); break; case 0x25: printf(\"Button B\"); break; case 0x24: printf(\"DVD menu\"); break; case 0x23: printf(\"Back\"); break; case 0x22: printf(\"OK\"); break; case 0x21: printf(\"Button left\"); break; case 0x20: printf(\"Button right\"); break; case 0x19: printf(\"Stop button\"); break; case 0x18: printf(\"Pause button\"); break; case 0x17: printf(\"Rec button\"); break; case 0x16: printf(\">\"); break; case 0x15: printf(\"<<\"); break; case 0x14: printf(\">>\"); break; case 0x13: printf(\"Button X\"); break; case 0x12: printf(\"Button A\"); break; case 0x11: printf(\"Volume down\"); break; case 0x10: printf(\"Volume up\"); break; case 0x09: printf(\"Button 9\"); break; case 0x08: printf(\"Button 8\"); break; case 0x07: printf(\"Button 7\"); break; case 0x06: printf(\"Button 6\"); break; case 0x05: printf(\"Button 5\"); break; case 0x04: printf(\"Button 4\"); break; case 0x03: printf(\"Button 3\"); break; case 0x02: printf(\"Button 2\"); break; case 0x01: printf(\"Button 1\"); break; case 0x00: printf(\"Button 0\"); break; case 0x1a: printf(\">|\"); break; case 0x1b: printf(\"<\"); break; case 0x1c: printf(\"Unknown\"); break; case 0x1d: printf(\"Unknown\"); break; case 0x1e: printf(\"Button up\"); break; case 0x1f: printf(\"Button down\"); break; case 0x0a: printf(\"Clear\"); break; case 0x0b: printf(\"ENTER\"); break; case 0x0c: printf(\"Unknown\"); break; case 0x0d: printf(\"WMS\"); break; case 0x0e: printf(\"Mute\"); break; case 0x0f: printf(\"Info\"); break; case 0x4f: printf(\"Display\"); break; case 0x51: printf(\"Title\"); break; case 0x64: printf(\"Guide\"); break; case 0x68: printf(\"Button X\"); break; case 0x66: printf(\"Button A\"); break; } printf(\"\\n\", valueread); if (msg[0] == wait_for) break; } } wait(1); } } The remote control works as a lowbase of the xbox360, so the power on and off still work in Linux, also you can get all the IR codes into linux. So 'if' a Mediacenter is ever ported to Xbox 360 Linux, you could use the official remote. (IR codes and info retrieved by Icekiller, with SMC.C from tmbinc, small remote by kwkward) Category:Xbox360_Hardware","title":"Media remote"},{"location":"Media_Remote/#media-remote","text":"","title":"Media remote"},{"location":"Media_Remote/#general-information","text":"Standard Media Remote\u2022The standard remote (as opposed to the Universal Media Remote) was only released in limited quantities with Xbox 360 premium packages at launch. The difference between the Universal Media Remote and the Standard Remote appears to just be the button additions. The remote uses the IR port located on the front of the Xbox 360. Some Windows Media Center Edition computers recognize this remote as a normal Media Center remote.","title":"General Information"},{"location":"Media_Remote/#confirmed-facts","text":"All Windows Media Center remotes are recognized by the Xbox 360.","title":"Confirmed Facts"},{"location":"Media_Remote/#linux-facts","text":"Big remote Big remote IRCODE , Function {'26','Button Y'}, {'25','Button B'}, {'24','DVD menu'}, {'23','BACK'}, {'22','OK'}, {'20','Button left'}, {'21','Button right'}, {'19','Stop button'}, {'18','Pause button'}, {'17','Rec button'}, {'16','Play button'}, {'15','Fast rewind \\<\\<'}, {'14','fast foward >>'}, {'11','Volume down'}, {'10','Volume up'}, {'09','Button 9 on ke*ypad part'}, {'08','Button 8 on ke*ypad part'}, {'07','Button 7 on ke*ypad part'}, {'06','Button 6 on ke*ypad part'}, {'05','Button 5 on ke*ypad part'}, {'04','Button 4 on keypad part'}, {'03','Button 3 on keypad part'}, {'02','Button 2 on keypad part'}, {'01','Button 1 on keypad part'}, {'00','Button 0 on keypad part'}, {'1a','Go to ending >|'}, {'1b','Go to beginning |\\<'}, {'1c','Unknown'}, {'1d','100 on remote'}, {'1e','Button up'}, {'1f','Button down'}, {'0a','Clear'}, {'0b','ENTER'}, {'0c','Unknown'}, {'0d','Windows Media Start'}, {'0e','Mute'}, {'0f','Info'}, {'4f','Display'}, {'51','Title'}, {'64','Big X button on top, use as alternative 'on'?'}, {'68','Button X'}, {'66','Button A '}, {'6c','Channel up'}, {'6d','Channel down'}; the small remote 'image insert here' IRCODE , Function {'64','guide'}, {'19','stop'}, {'18','pause'}, {'16','play'}, {'15','rewind'}, {'14','fast forward'}, {'1A','chapter next'}, {'1B','chapter prev'}, {'4F','display'}, {'51','title'}, {'24','dvd menu'}, {'23','back'}, {'0F','info'}, {'1E','up'}, {'1F','down'}, {'20','left'}, {'21','right'}, {'22','ok'}, {'12','A'}, {'25','B'}, {'13','X'}, {'26','Y'}, {'0D','windows'}, {'17','record'};","title":"Linux Facts"},{"location":"Media_Remote/#proof-of-concept-code-by-icekiller","text":"/* * Example code of how to use the build in IR of the xbox 360 * Code rewritten based on tmbinc's smc.c * free to use under GPL * * 20 januari 2008 by Icekiller */ #include <stdio.h> #include <stdlib.h> #include <fcntl.h> #include <getopt.h> #include <string.h> #include <time.h> #define SMC_FILENAME \"/dev/smc\" int smc_fd; void wait(int seconds) { clock_t endwait; endwait = clock() + seconds * CLOCKS_PER_SEC; while (clock() < endwait) { } } int main(int argc, char **argv) { int first = 1; /* try open SMC. if this doesn't work, bail out. */ smc_fd = open(SMC_FILENAME, O_RDWR); if (smc_fd < 0) { perror(SMC_FILENAME); return 1; } while (1) { unsigned char msg[16]; int option_index = 0, c; msg[0] = 0x16; /* prepare message */ memset(msg, 0, 16); if (c != 'w') { msg[0] = 0x16; int i; if (write(smc_fd, msg, 16) != 16) { perror(\"write\"); break; } } if ((c == 'w') || (msg[0] < 0x80)) { int wait_for = msg[0]; while (1) { msg[0] = 0x16; if (read(smc_fd, msg, 16) != 16) perror(\"read\"); int valueread; valueread = msg[3]; if (msg[0] != 0x16) switch (valueread) { case 0x26: printf(\"Button Y\"); break; case 0x25: printf(\"Button B\"); break; case 0x24: printf(\"DVD menu\"); break; case 0x23: printf(\"Back\"); break; case 0x22: printf(\"OK\"); break; case 0x21: printf(\"Button left\"); break; case 0x20: printf(\"Button right\"); break; case 0x19: printf(\"Stop button\"); break; case 0x18: printf(\"Pause button\"); break; case 0x17: printf(\"Rec button\"); break; case 0x16: printf(\">\"); break; case 0x15: printf(\"<<\"); break; case 0x14: printf(\">>\"); break; case 0x13: printf(\"Button X\"); break; case 0x12: printf(\"Button A\"); break; case 0x11: printf(\"Volume down\"); break; case 0x10: printf(\"Volume up\"); break; case 0x09: printf(\"Button 9\"); break; case 0x08: printf(\"Button 8\"); break; case 0x07: printf(\"Button 7\"); break; case 0x06: printf(\"Button 6\"); break; case 0x05: printf(\"Button 5\"); break; case 0x04: printf(\"Button 4\"); break; case 0x03: printf(\"Button 3\"); break; case 0x02: printf(\"Button 2\"); break; case 0x01: printf(\"Button 1\"); break; case 0x00: printf(\"Button 0\"); break; case 0x1a: printf(\">|\"); break; case 0x1b: printf(\"<\"); break; case 0x1c: printf(\"Unknown\"); break; case 0x1d: printf(\"Unknown\"); break; case 0x1e: printf(\"Button up\"); break; case 0x1f: printf(\"Button down\"); break; case 0x0a: printf(\"Clear\"); break; case 0x0b: printf(\"ENTER\"); break; case 0x0c: printf(\"Unknown\"); break; case 0x0d: printf(\"WMS\"); break; case 0x0e: printf(\"Mute\"); break; case 0x0f: printf(\"Info\"); break; case 0x4f: printf(\"Display\"); break; case 0x51: printf(\"Title\"); break; case 0x64: printf(\"Guide\"); break; case 0x68: printf(\"Button X\"); break; case 0x66: printf(\"Button A\"); break; } printf(\"\\n\", valueread); if (msg[0] == wait_for) break; } } wait(1); } } The remote control works as a lowbase of the xbox360, so the power on and off still work in Linux, also you can get all the IR codes into linux. So 'if' a Mediacenter is ever ported to Xbox 360 Linux, you could use the official remote. (IR codes and info retrieved by Icekiller, with SMC.C from tmbinc, small remote by kwkward) Category:Xbox360_Hardware","title":"Proof of concept code by Icekiller"},{"location":"Memory/","text":"Memory System Memory - Mainboard & GPU 512 MB of Unified GDDR3 RAM Unified Memory Architecture Reduces cost and complexity of the motherboard design 700 MHz DDR Effective transmission rate of 1.4 GHz on the 128-bit bus Unified Memory Architecture (GPU & CPU Access) GPU 10MB eDRAM 128-bit interface to ATI's memory controller Memory Bandwidth 32 GB/s GPU to eDRAM bandwidth 2 GHz @ 2 accesses per clock cycle on a 64 bit DDR bus 22.4 GB/s memory interface bus bandwidth (low latency path to CPU cores) 700 MHz @ 2 accesses per clock cycle (one per edge) on a 128 bit bus 256 GB/s memory bandwidth to eDRAM 21.6 GB/s front-side bus Southbridge bandwidth of 500 MB/s. Category:Xbox360_Hardware","title":"Memory"},{"location":"Memory/#memory","text":"","title":"Memory"},{"location":"Memory/#system-memory-mainboard-gpu","text":"512 MB of Unified GDDR3 RAM Unified Memory Architecture Reduces cost and complexity of the motherboard design 700 MHz DDR Effective transmission rate of 1.4 GHz on the 128-bit bus Unified Memory Architecture (GPU & CPU Access) GPU 10MB eDRAM 128-bit interface to ATI's memory controller","title":"System Memory - Mainboard &amp; GPU"},{"location":"Memory/#memory-bandwidth","text":"32 GB/s GPU to eDRAM bandwidth 2 GHz @ 2 accesses per clock cycle on a 64 bit DDR bus 22.4 GB/s memory interface bus bandwidth (low latency path to CPU cores) 700 MHz @ 2 accesses per clock cycle (one per edge) on a 128 bit bus 256 GB/s memory bandwidth to eDRAM 21.6 GB/s front-side bus Southbridge bandwidth of 500 MB/s. Category:Xbox360_Hardware","title":"Memory Bandwidth"},{"location":"Memory_MAP/","text":"Memory map Physical Mapping Address Size Description c000xxxx 0x10000 Initial \"Kernel\" (bootloader, not real kernel), mapped L2-Cache? c8xxxxxx 0x1000000 memory mapped NAND flash (RO, 1:1, no OoB(ECC)) c9xxxxxx 0x1000000 ??? d0xxxxxx 0x1000000 PCI config space. Device number etc. is encoded in address, as usual e0000000 ??? Host-Bridge e1000000 ??? BIU ea000000 0x10000 PCI Bridge ec800000 0x10000 GPU PCI/Device Mapping Address Size Description 0x(200)ea001000 0x100 System Management Controller 0x(200)ea001200 0x30 SATA Controller CDRom 0x(200)ea001300 0x30 SATA Controller HDD 0x(200)ea001400 0x80 Fast Ethernet Adapter 0x(200)ea001600 0x40 Audio Controller 0x(200)ea001800 0x400 XMA Decoder 0x(200)ea002000 0x1000 OHCI Controller 0 0x(200)ea003000 0x1000 EHCI Controller 0 0x(200)ea004000 0x1000 OHCI Controller 1 0x(200)ea005000 0x1000 EHCI Controller 1 0x(200)ea00c000 0x400 Secure Flash Controller SMC Area Address Size Description 0x(200)ea001000 0x10 Bus Control 0x(200)ea001010 0x10 UART 0x(200)ea001020 0x10 GPIO Port ?? 0x(200)ea001030 0x10 GPIO Port ?? 0x(200)ea001040 0x10 GPIO Port ?? 0x(200)ea001050 0x10 SMI ??? Encryption Dumps of physical memory Changed 1 byte in software, dumped again, 16 bytes changed again. Might be ~1 cache line (0, 1, 2, ...) log: f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 6e bb c5 d1 62 9e 29 8f e9 3a 6b 7b 4d d0 44 24 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 03 58 f6 c0 f0 13 d5 02 4f 57 a1 d0 50 d3 46 6a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 1b d6 a6 3b 3c 6e 68 4f da 75 7f a7 8a 02 e4 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 38 03 ff f0 61 99 e6 8c b0 3b 2f bb b6 70 06 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 0f 55 01 b1 61 9b 35 34 4d ce f4 e8 bb eb cc 4a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 fc ce 87 2c 30 c0 1c 4f e7 65 da d4 e4 df f6 2b 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 e5 5d f3 38 d9 05 c0 8e 7a a9 b5 a2 fe 11 4c b3 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 84 83 5d 34 55 9b e4 06 26 03 1b f3 0b e9 0f b8 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 ba 4d 72 2b cd 0b e9 0c 2b aa ed 53 ea b0 63 49 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e","title":"Memory map"},{"location":"Memory_MAP/#memory-map","text":"","title":"Memory map"},{"location":"Memory_MAP/#physical-mapping","text":"Address Size Description c000xxxx 0x10000 Initial \"Kernel\" (bootloader, not real kernel), mapped L2-Cache? c8xxxxxx 0x1000000 memory mapped NAND flash (RO, 1:1, no OoB(ECC)) c9xxxxxx 0x1000000 ??? d0xxxxxx 0x1000000 PCI config space. Device number etc. is encoded in address, as usual e0000000 ??? Host-Bridge e1000000 ??? BIU ea000000 0x10000 PCI Bridge ec800000 0x10000 GPU","title":"Physical Mapping"},{"location":"Memory_MAP/#pcidevice-mapping","text":"Address Size Description 0x(200)ea001000 0x100 System Management Controller 0x(200)ea001200 0x30 SATA Controller CDRom 0x(200)ea001300 0x30 SATA Controller HDD 0x(200)ea001400 0x80 Fast Ethernet Adapter 0x(200)ea001600 0x40 Audio Controller 0x(200)ea001800 0x400 XMA Decoder 0x(200)ea002000 0x1000 OHCI Controller 0 0x(200)ea003000 0x1000 EHCI Controller 0 0x(200)ea004000 0x1000 OHCI Controller 1 0x(200)ea005000 0x1000 EHCI Controller 1 0x(200)ea00c000 0x400 Secure Flash Controller","title":"PCI/Device Mapping"},{"location":"Memory_MAP/#smc-area","text":"Address Size Description 0x(200)ea001000 0x10 Bus Control 0x(200)ea001010 0x10 UART 0x(200)ea001020 0x10 GPIO Port ?? 0x(200)ea001030 0x10 GPIO Port ?? 0x(200)ea001040 0x10 GPIO Port ?? 0x(200)ea001050 0x10 SMI ???","title":"SMC Area"},{"location":"Memory_MAP/#encryption","text":"Dumps of physical memory Changed 1 byte in software, dumped again, 16 bytes changed again. Might be ~1 cache line (0, 1, 2, ...) log: f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 6e bb c5 d1 62 9e 29 8f e9 3a 6b 7b 4d d0 44 24 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 03 58 f6 c0 f0 13 d5 02 4f 57 a1 d0 50 d3 46 6a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 1b d6 a6 3b 3c 6e 68 4f da 75 7f a7 8a 02 e4 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 38 03 ff f0 61 99 e6 8c b0 3b 2f bb b6 70 06 53 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 0f 55 01 b1 61 9b 35 34 4d ce f4 e8 bb eb cc 4a 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 fc ce 87 2c 30 c0 1c 4f e7 65 da d4 e4 df f6 2b 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 e5 5d f3 38 d9 05 c0 8e 7a a9 b5 a2 fe 11 4c b3 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 84 83 5d 34 55 9b e4 06 26 03 1b f3 0b e9 0f b8 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e f0 35 64 03 de 02 5b 09 b5 7b 81 49 21 e9 d9 77 ba 4d 72 2b cd 0b e9 0c 2b aa ed 53 ea b0 63 49 15 d4 61 28 e0 e2 ea da e3 b8 34 2e cf bb af 0e","title":"Encryption"},{"location":"Memory_Unit/","text":"Memory unit General Information Memory Units (64 MB) require no setup or configuration. (Plug & Play) Xbox 360 accepts two Memory Units. Each unit contains three IC's: Custom Microsoft ASIC (marked as X805867-002) Samsung NAND flash memory (IC model depends on memory size i.e. K9F1208U) Perhaps an IC EEPROM memory (marked as X803122) Known Facts The Memory card is required in absence of hard drive to play on Xbox Live and to save game progress. The memory cards are USB devices, albeit with custom connectors and with 3.3V power (not 5V). Pinout Inside the memory unit Flash Contents Address Length (bytes) Contains 0x00000 16 Text String \"DUMBO FIL format\" 0x0020B 5 5 byte value 0x04200 32 MS text string 0x04220 15 Ascii serial nr of MU 0x0440B 5 5 byte value 0x10800 ~ Data start FATX Partition Locations Address Type 0x00 Partition 1 0x7ff000 Partition 2 Speculation The connections of the small 8-pin IC: Pin# Description Characteristic 1 GND A0 2 NC A1 3 NC A2 4 NC GND 5 to pin 22 of ASIC SDA 6 to pins 20 and 21 of ASIC SCL 7 to pin 3 of ASIC WP 8 VCC VCC (3.3V) At the bottom side of this chip is written: PHILK2B EL526 901IA2 Most plausible theory is that the IC is an IC EEPROM memory. I've added in brackets possible 24CXXX family pin names. GND could be A0 because in most cases adress lines (A0-A2) are connected to ground. Other theory (less plausible) is that it might be a NXP (Philips) P89LPC901FD microcontroller with its die upside down? archive.org mirror: here When supplying 3.3 volts to the Memory Unit: Measurements at pins 5, 6, and 7 show that there is a clock signal of 5Mhz present on pin 7 (in burst of 16 cycles). Every 16 cycles, one bit is transferred on pin 6. 3ms after powerup data communication ends. Note: This looks like SPI, pin 7 - SCK, Pin 6 - /SS, Pin 5 - MODI. But SPI needs four wires. It's more like I 2 C which needs only two lines (SDA, SCL) and optionally WP (Write Protect). Category:Xbox360_Hardware","title":"Memory unit"},{"location":"Memory_Unit/#memory-unit","text":"","title":"Memory unit"},{"location":"Memory_Unit/#general-information","text":"Memory Units (64 MB) require no setup or configuration. (Plug & Play) Xbox 360 accepts two Memory Units. Each unit contains three IC's: Custom Microsoft ASIC (marked as X805867-002) Samsung NAND flash memory (IC model depends on memory size i.e. K9F1208U) Perhaps an IC EEPROM memory (marked as X803122)","title":"General Information"},{"location":"Memory_Unit/#known-facts","text":"The Memory card is required in absence of hard drive to play on Xbox Live and to save game progress. The memory cards are USB devices, albeit with custom connectors and with 3.3V power (not 5V).","title":"Known Facts"},{"location":"Memory_Unit/#pinout","text":"","title":"Pinout"},{"location":"Memory_Unit/#inside-the-memory-unit","text":"","title":"Inside the memory unit"},{"location":"Memory_Unit/#flash-contents","text":"Address Length (bytes) Contains 0x00000 16 Text String \"DUMBO FIL format\" 0x0020B 5 5 byte value 0x04200 32 MS text string 0x04220 15 Ascii serial nr of MU 0x0440B 5 5 byte value 0x10800 ~ Data start","title":"Flash Contents"},{"location":"Memory_Unit/#fatx-partition-locations","text":"Address Type 0x00 Partition 1 0x7ff000 Partition 2","title":"FATX Partition Locations"},{"location":"Memory_Unit/#speculation","text":"The connections of the small 8-pin IC: Pin# Description Characteristic 1 GND A0 2 NC A1 3 NC A2 4 NC GND 5 to pin 22 of ASIC SDA 6 to pins 20 and 21 of ASIC SCL 7 to pin 3 of ASIC WP 8 VCC VCC (3.3V) At the bottom side of this chip is written: PHILK2B EL526 901IA2 Most plausible theory is that the IC is an IC EEPROM memory. I've added in brackets possible 24CXXX family pin names. GND could be A0 because in most cases adress lines (A0-A2) are connected to ground. Other theory (less plausible) is that it might be a NXP (Philips) P89LPC901FD microcontroller with its die upside down? archive.org mirror: here When supplying 3.3 volts to the Memory Unit: Measurements at pins 5, 6, and 7 show that there is a clock signal of 5Mhz present on pin 7 (in burst of 16 cycles). Every 16 cycles, one bit is transferred on pin 6. 3ms after powerup data communication ends. Note: This looks like SPI, pin 7 - SCK, Pin 6 - /SS, Pin 5 - MODI. But SPI needs four wires. It's more like I 2 C which needs only two lines (SDA, SCL) and optionally WP (Write Protect). Category:Xbox360_Hardware","title":"Speculation"},{"location":"Modesetting/","text":"Modesetting We know libxenon sets graphics modes by writing a complete Ana dump to Ana memory and writing some values to the GPU registers. The registers affected and the information that gets written is the following: total_width, hsync_offset, real_active_width, total_height, vsync_offset, active_height, width, height, is_progressive = 0 for non progressive modes, 1 for progressive modes. rgb = 1, only declared on the modes used through VGA. composite_sync=1, only declared on the PAL/NTSC non progressive modes. interlace_factor is set to 1 when mode is progressive and 2 when it is not. FB_BASE is a constant for the framebuffer base address on libxenon, but we get different addresses on the GPU dumps. These are the addresses that get that variables written at some stage of the initialization, in the order libxenon write them. I have take out the addresses that get fixed values written. As you can see, some addresses get written more than one time on the initialization process. Following are the values of the GPU dumps we currently own. We need to find a way to know if these dumps are valid as some values differ drastically from what we can read on libxenon's xenos.c and, if they are valid, why the are not the values expected. 0x6000, mode->total_width - 1 1024x768: 0x0000053f 1280x1024: 0x00000697 1280x720: 0x00000671 1920x1080: 0x0000081f 0x6010, mode->total_height - 1 1024x768: 0x00000325 1280x1024: 0x00000429 1280x720: 0x000002ed 1920x1080: 0x00000456 0x6004, (mode->hsync_offset << 16) | (mode->real_active_width + mode->hsync_offset) 1024x768: 0x00eb04eb 1280x1024: 0x01250625 1280x720: 0x00c705c7 1920x1080: 0x002d07ad 0x6014, (mode->vsync_offset << 16) | (mode->active_height * interlace_factor + mode->vsync_offset) 1024x768: 0x00230323 1280x1024: 0x00290429 1280x720: 0x001902e9 1920x1080: 0x001c0454 0x6030, mode->is_progressive ? 0 : 1 It is 0x00000000 on all the dumps. 0x6120, mode->width This address gets rewritten later. 0x6134, mode->width 1024x768: 0x000003c0 1280x1024: 0x000003c0 1280x720: 0x00000500 1920x1080: 0x00000360 0x6138, mode->active_height * interlace_factor This address gets rewritten later. 0x6110, FB_BASE 1024x768: 0x1f78e000 1280x1024: 0x1f78e000 1280x720: 0x1f6a8000 1920x1080: 0x01c5b000 0x6120, mode->width 1024x768: 0x000003c0 1280x1024: 0x000003c0 1280x720: 0x00000500 1920x1080: 0x00000360 0x2840, FB_BASE 0x2844, mode->width I don't know what hardware is in charge on this memory addresses 0x6584, (mode->width << 16) | (mode->active_height * interlace_factor) This address gets rewritten later. 0x65e8, (mode->width >> 2) - 1 This address gets rewritten later. 0x6528, mode->is_progressive ? 0 : 1 It is 0x00000000 on all the dumps. 0x6584, (mode->width << 16) | (mode->height * interlace_factor) 1024x768: 0x040002d0 1280x1024: 0x040002d0 1280x720: 0x050002d0 1920x1080: 0x035401e0 0x65e8, (mode->width / 4) - 1 1024x768: 0x000000ff 1280x1024: 0x000000ff 1280x720: 0x0000013f 1920x1080: 0x000000d4 0x6434, mode->width It is 0x00000000 in all dumps (!?) 0x6138, mode->height * interlace_factor 1024x768: 0x000002d0 1280x1024: 0x000002d0 1280x720: 0x000002d0 1920x1080: 0x000001e0","title":"Modesetting"},{"location":"Modesetting/#modesetting","text":"We know libxenon sets graphics modes by writing a complete Ana dump to Ana memory and writing some values to the GPU registers. The registers affected and the information that gets written is the following: total_width, hsync_offset, real_active_width, total_height, vsync_offset, active_height, width, height, is_progressive = 0 for non progressive modes, 1 for progressive modes. rgb = 1, only declared on the modes used through VGA. composite_sync=1, only declared on the PAL/NTSC non progressive modes. interlace_factor is set to 1 when mode is progressive and 2 when it is not. FB_BASE is a constant for the framebuffer base address on libxenon, but we get different addresses on the GPU dumps. These are the addresses that get that variables written at some stage of the initialization, in the order libxenon write them. I have take out the addresses that get fixed values written. As you can see, some addresses get written more than one time on the initialization process. Following are the values of the GPU dumps we currently own. We need to find a way to know if these dumps are valid as some values differ drastically from what we can read on libxenon's xenos.c and, if they are valid, why the are not the values expected. 0x6000, mode->total_width - 1 1024x768: 0x0000053f 1280x1024: 0x00000697 1280x720: 0x00000671 1920x1080: 0x0000081f 0x6010, mode->total_height - 1 1024x768: 0x00000325 1280x1024: 0x00000429 1280x720: 0x000002ed 1920x1080: 0x00000456 0x6004, (mode->hsync_offset << 16) | (mode->real_active_width + mode->hsync_offset) 1024x768: 0x00eb04eb 1280x1024: 0x01250625 1280x720: 0x00c705c7 1920x1080: 0x002d07ad 0x6014, (mode->vsync_offset << 16) | (mode->active_height * interlace_factor + mode->vsync_offset) 1024x768: 0x00230323 1280x1024: 0x00290429 1280x720: 0x001902e9 1920x1080: 0x001c0454 0x6030, mode->is_progressive ? 0 : 1 It is 0x00000000 on all the dumps. 0x6120, mode->width This address gets rewritten later. 0x6134, mode->width 1024x768: 0x000003c0 1280x1024: 0x000003c0 1280x720: 0x00000500 1920x1080: 0x00000360 0x6138, mode->active_height * interlace_factor This address gets rewritten later. 0x6110, FB_BASE 1024x768: 0x1f78e000 1280x1024: 0x1f78e000 1280x720: 0x1f6a8000 1920x1080: 0x01c5b000 0x6120, mode->width 1024x768: 0x000003c0 1280x1024: 0x000003c0 1280x720: 0x00000500 1920x1080: 0x00000360 0x2840, FB_BASE 0x2844, mode->width I don't know what hardware is in charge on this memory addresses 0x6584, (mode->width << 16) | (mode->active_height * interlace_factor) This address gets rewritten later. 0x65e8, (mode->width >> 2) - 1 This address gets rewritten later. 0x6528, mode->is_progressive ? 0 : 1 It is 0x00000000 on all the dumps. 0x6584, (mode->width << 16) | (mode->height * interlace_factor) 1024x768: 0x040002d0 1280x1024: 0x040002d0 1280x720: 0x050002d0 1920x1080: 0x035401e0 0x65e8, (mode->width / 4) - 1 1024x768: 0x000000ff 1280x1024: 0x000000ff 1280x720: 0x0000013f 1920x1080: 0x000000d4 0x6434, mode->width It is 0x00000000 in all dumps (!?) 0x6138, mode->height * interlace_factor 1024x768: 0x000002d0 1280x1024: 0x000002d0 1280x720: 0x000002d0 1920x1080: 0x000001e0","title":"Modesetting"},{"location":"Motherboard/","text":"Motherboard (This page is riddled with speculation and extrapolation of information from dodgy sources, so take it with a grain of salt.) The Xbox 360 motherboard (or motherboard) has undergone a few revisions, as Microsoft has corrected mistakes or added/improved existing features. Known revisions include: :* Xenon (Launch hardware) :* Zephyr (Elite) :* Falcon (65nm Chipset revision) :* Opus :* Jasper (Onboard Memory Unit) :* Trinity (Slim) Details The motherboard PCB has four layers (sources: 1 , 2 ), implying that the top and bottom layers (the ones we can see and probe) contain most of the signals. This is a good thing :) CPU, GPU, & Front side bus According to these three sources the FSB is a serial bus with 16 differential pairs in each direction, and each pair runs at 5.4Gbit/s. This agrees with Microsoft's published bandwidth specification of 21.6 Gbyte/sec (10.8 Gbyte/sec each way, 16 bits/2 bytes at a time, 5.4 Gbit/sec per pair). Looking at photos of the motherboard, we can see 40 pairs of carefully routed tracks between the CPU and GPU. 32 pairs (16 each way) + 8 clock/handshake/parity? pairs = 40 pairs. This very high frequency interface will make probing and snooping on the bus extremely difficult, which is unfortunate because the Xbox1 security was compromised in part by a FSB bus snoop done by bunnie. At this frequency, the (relatively) simple task of attaching probe wires to the FSB will change the impedance seen on the bus by the FSB PHYs and cause the bus to fail to work correctly (look at eye diagram...). It might still be possible to probe the FSB with very expensive gear though. It's not very likely that they made the mistake of sending sensitive information on an exposed bus again though. Photos http://arstechnica.com/articles/paedia/cpu/xbox360-1.ars http://g-prime.net/x360/open/ (archive.org mirror) http://www.darkmoon.org/xbox360_photos.htm (archive.org mirror) Category:Xbox360_Hardware","title":"Motherboard"},{"location":"Motherboard/#motherboard","text":"(This page is riddled with speculation and extrapolation of information from dodgy sources, so take it with a grain of salt.) The Xbox 360 motherboard (or motherboard) has undergone a few revisions, as Microsoft has corrected mistakes or added/improved existing features. Known revisions include: :* Xenon (Launch hardware) :* Zephyr (Elite) :* Falcon (65nm Chipset revision) :* Opus :* Jasper (Onboard Memory Unit) :* Trinity (Slim)","title":"Motherboard"},{"location":"Motherboard/#details","text":"The motherboard PCB has four layers (sources: 1 , 2 ), implying that the top and bottom layers (the ones we can see and probe) contain most of the signals. This is a good thing :)","title":"Details"},{"location":"Motherboard/#cpu-gpu-front-side-bus","text":"According to these three sources the FSB is a serial bus with 16 differential pairs in each direction, and each pair runs at 5.4Gbit/s. This agrees with Microsoft's published bandwidth specification of 21.6 Gbyte/sec (10.8 Gbyte/sec each way, 16 bits/2 bytes at a time, 5.4 Gbit/sec per pair). Looking at photos of the motherboard, we can see 40 pairs of carefully routed tracks between the CPU and GPU. 32 pairs (16 each way) + 8 clock/handshake/parity? pairs = 40 pairs. This very high frequency interface will make probing and snooping on the bus extremely difficult, which is unfortunate because the Xbox1 security was compromised in part by a FSB bus snoop done by bunnie. At this frequency, the (relatively) simple task of attaching probe wires to the FSB will change the impedance seen on the bus by the FSB PHYs and cause the bus to fail to work correctly (look at eye diagram...). It might still be possible to probe the FSB with very expensive gear though. It's not very likely that they made the mistake of sending sensitive information on an exposed bus again though.","title":"CPU, GPU, &amp; Front side bus"},{"location":"Motherboard/#photos","text":"http://arstechnica.com/articles/paedia/cpu/xbox360-1.ars http://g-prime.net/x360/open/ (archive.org mirror) http://www.darkmoon.org/xbox360_photos.htm (archive.org mirror) Category:Xbox360_Hardware","title":"Photos"},{"location":"Mupen64-360/","text":"General Info NFO ************************** * Mupen64-360 v0.96 Beta * ************************** http://www.libxenon.org/ Description =========== Mupen64-360 is a Nintendo64 emulator for the Xbox 360, it's powered by libxenon and it's a port of Wii64 (which itself was a port of Mupen64). Usage ===== Unzip on USB sick, then run from Xell. Many ROM formats are supported, zipped ROMs also work. In the browser, the Back button changes the current drive, A selects, B goes to parent dir. Back also quits a game. Other controls are described in the emulator itself. The browser background image is loaded from /mupen64-360/bg.png on the USB stick, other backgrounds are provided. History ======= v0.96 Beta: First binary release Credits ======= Wii64 / Mupen64 teams (guess why :) GliGli (Xbox 360 port) Ced2911 (GUI library) Razkar (Backgrounds) Everyone that contributed to libxenon... Video Category:Xbox360_Homebrew_Software","title":"Mupen64 360"},{"location":"Mupen64-360/#general-info","text":"","title":"General Info"},{"location":"Mupen64-360/#nfo","text":"************************** * Mupen64-360 v0.96 Beta * ************************** http://www.libxenon.org/ Description =========== Mupen64-360 is a Nintendo64 emulator for the Xbox 360, it's powered by libxenon and it's a port of Wii64 (which itself was a port of Mupen64). Usage ===== Unzip on USB sick, then run from Xell. Many ROM formats are supported, zipped ROMs also work. In the browser, the Back button changes the current drive, A selects, B goes to parent dir. Back also quits a game. Other controls are described in the emulator itself. The browser background image is loaded from /mupen64-360/bg.png on the USB stick, other backgrounds are provided. History ======= v0.96 Beta: First binary release Credits ======= Wii64 / Mupen64 teams (guess why :) GliGli (Xbox 360 port) Ced2911 (GUI library) Razkar (Backgrounds) Everyone that contributed to libxenon...","title":"NFO"},{"location":"Mupen64-360/#video","text":"Category:Xbox360_Homebrew_Software","title":"Video"},{"location":"NAND/","text":"NAND Flash memory Datasheet SMT socket that should work if you choose to remove yours: https://web.archive.org/web/20111206034431/http://www.emulation.com:80/cgi-cfm/insert_quantity.cfm?part_number=S%2DTSO%2DSM%2D048%2DA Attached to Southbridge NAND Points on Motherboard for FAT NAND Points on Motherboard for SLIM comming soon Different Sizes On different Motherboard Revision also different NANDs were used. Xenon -, Zephyr -, Falcon -, Opus - and some Jasper -Consoles (Retails) are using 16MB NANDs, other Jasper -Consoles (Retail),Arcade Bundles which came without a HDD, got a 256MB or 512MB NAND onboard. Only 64MB of these 256/512MB NAND are used for system files, the rest is used as an internal Memory Unit. All Development-/Demo-/Reviewer-/Test-Kits got at least a 64MB NAND. Depending on the NAND Size either Small- or Large-Block Flash Controllers get used. Flash Controllers The Flash Controller decides how to handle the NAND Memory. There are currently two types, the Old/Original SFC which handles the NAND with small block and the new SFC (Codename: Panda?) which handles the NAND as either small or large blocks. Original SFC (pre-Jasper) 16MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 64MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0xF80 New SFC Small Block: 16MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 Large Block: 256/512MB NAND Type Size Block Size 0x20000 (128KB) Block Count (non-MU) 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x1E0 Simple Calculations Have an address which is without ECC? realaddr = (addr / 512) * 528 + (realaddr % (mod) 512 > 0 ? realaddr % (mod) 512 : 0); This also works in reverse: addr = (realaddr / 528) * 512 + (realaddr % (mod) 528 > 0 ? realaddr % (mod) 528 : 0); Reading/Writing The Flash can be written or read using a number of methods. If you have the old shader hack running the easiest is using lflash . You can also wire LPT directly to the flash using this diagram . As well, you can build your own USB SPI Flasher with this diagram and use these binaries . Flash the PicXboot.hex to your PIC, then use the programmer from this picflash to flash the picflash.hex to the PIC through USB in bootloader mode. Once the device is flashed, you can then install it using the drivers from NandPro or use TeamXecuters NANDX drivers. Once wired you can read/write to the chip using software such as NandPro . In software the NAND is mapped to memory address 0x80000200C8000000. You must be in real-mode to access the space You can read it byte by byte but it is recommended to follow the standard and read it in 4 byte blocks Sectors 1: copyright notice, zeros, unencrypted numbers 2: encrypted data @2MB filesystem, unencrypted, but content encrypted, config not NAND File System Informations about the Filesystem on the Xbox360 NAND Flash can be found here Bad Blocks Its possible that bad blocks appears when reading/writing to the NAND. For solving these look at the following page: Bad Blocks Small flash chip close to CPU Some 360s have a small flash chip near the CPU, some don't as seen in the following pictures. No chip: Here is a high-res picture of a premium box with the chip: As discussed in this article on the xboxhacker.net forums, this appears to be a Atmel 25020 EEPROM. The chip model reads: ATMEL524 25020AN SU18 Datasheet can be found here . This chip is a low power 2048 bit serial EEPROM according to the datasheet. If the small chip near the CPU is removed the Xbox will boot up and function just fine [Darkmoon 360 experiments] According to IBM the CPU has \"An interface for a serial EEPROM in case patch logic configuration was needed during bring-up\" Small flash chip on front panel There is another Atmel chip on the front panel: Atmel 528 serial EEPROM This chip reads: ATMEL528 24C04N SU18 Datasheet can be found here This chip is a low power 4096 bit serial EEPROM according to the datasheet. Tools 360 Flash Tool, which is easy to find Xbox 360 NAND Editor by stoker25, open source and semi-complete, has code to do with bootloaders/keyvault/filesystem Category:Xbox360_Hardware","title":"NAND"},{"location":"NAND/#nand","text":"","title":"NAND"},{"location":"NAND/#flash-memory","text":"Datasheet SMT socket that should work if you choose to remove yours: https://web.archive.org/web/20111206034431/http://www.emulation.com:80/cgi-cfm/insert_quantity.cfm?part_number=S%2DTSO%2DSM%2D048%2DA Attached to Southbridge","title":"Flash memory"},{"location":"NAND/#nand-points-on-motherboard-for-fat","text":"","title":"NAND Points on Motherboard for FAT"},{"location":"NAND/#nand-points-on-motherboard-for-slim","text":"comming soon","title":"NAND Points on Motherboard for SLIM"},{"location":"NAND/#different-sizes","text":"On different Motherboard Revision also different NANDs were used. Xenon -, Zephyr -, Falcon -, Opus - and some Jasper -Consoles (Retails) are using 16MB NANDs, other Jasper -Consoles (Retail),Arcade Bundles which came without a HDD, got a 256MB or 512MB NAND onboard. Only 64MB of these 256/512MB NAND are used for system files, the rest is used as an internal Memory Unit. All Development-/Demo-/Reviewer-/Test-Kits got at least a 64MB NAND. Depending on the NAND Size either Small- or Large-Block Flash Controllers get used.","title":"Different Sizes"},{"location":"NAND/#flash-controllers","text":"The Flash Controller decides how to handle the NAND Memory. There are currently two types, the Old/Original SFC which handles the NAND with small block and the new SFC (Codename: Panda?) which handles the NAND as either small or large blocks. Original SFC (pre-Jasper) 16MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 64MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0xF80 New SFC Small Block: 16MB NAND Type Size Block Size 0x4000 (16KB) Block Count 0x400 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x3E0 Large Block: 256/512MB NAND Type Size Block Size 0x20000 (128KB) Block Count (non-MU) 0x1000 Page Size 0x200 Pages per Block Block size / Page size Raw Page Size (incl. SpareData) 0x210 Usable Filesystem-Size 0x1E0","title":"Flash Controllers"},{"location":"NAND/#simple-calculations","text":"Have an address which is without ECC? realaddr = (addr / 512) * 528 + (realaddr % (mod) 512 > 0 ? realaddr % (mod) 512 : 0); This also works in reverse: addr = (realaddr / 528) * 512 + (realaddr % (mod) 528 > 0 ? realaddr % (mod) 528 : 0);","title":"Simple Calculations"},{"location":"NAND/#readingwriting","text":"The Flash can be written or read using a number of methods. If you have the old shader hack running the easiest is using lflash . You can also wire LPT directly to the flash using this diagram . As well, you can build your own USB SPI Flasher with this diagram and use these binaries . Flash the PicXboot.hex to your PIC, then use the programmer from this picflash to flash the picflash.hex to the PIC through USB in bootloader mode. Once the device is flashed, you can then install it using the drivers from NandPro or use TeamXecuters NANDX drivers. Once wired you can read/write to the chip using software such as NandPro . In software the NAND is mapped to memory address 0x80000200C8000000. You must be in real-mode to access the space You can read it byte by byte but it is recommended to follow the standard and read it in 4 byte blocks","title":"Reading/Writing"},{"location":"NAND/#sectors","text":"1: copyright notice, zeros, unencrypted numbers 2: encrypted data @2MB filesystem, unencrypted, but content encrypted, config not","title":"Sectors"},{"location":"NAND/#nand-file-system","text":"Informations about the Filesystem on the Xbox360 NAND Flash can be found here","title":"NAND File System"},{"location":"NAND/#bad-blocks","text":"Its possible that bad blocks appears when reading/writing to the NAND. For solving these look at the following page: Bad Blocks","title":"Bad Blocks"},{"location":"NAND/#small-flash-chip-close-to-cpu","text":"Some 360s have a small flash chip near the CPU, some don't as seen in the following pictures. No chip: Here is a high-res picture of a premium box with the chip: As discussed in this article on the xboxhacker.net forums, this appears to be a Atmel 25020 EEPROM. The chip model reads: ATMEL524 25020AN SU18 Datasheet can be found here . This chip is a low power 2048 bit serial EEPROM according to the datasheet. If the small chip near the CPU is removed the Xbox will boot up and function just fine [Darkmoon 360 experiments] According to IBM the CPU has \"An interface for a serial EEPROM in case patch logic configuration was needed during bring-up\"","title":"Small flash chip close to CPU"},{"location":"NAND/#small-flash-chip-on-front-panel","text":"There is another Atmel chip on the front panel: Atmel 528 serial EEPROM This chip reads: ATMEL528 24C04N SU18 Datasheet can be found here This chip is a low power 4096 bit serial EEPROM according to the datasheet.","title":"Small flash chip on front panel"},{"location":"NAND/#tools","text":"360 Flash Tool, which is easy to find Xbox 360 NAND Editor by stoker25, open source and semi-complete, has code to do with bootloaders/keyvault/filesystem Category:Xbox360_Hardware","title":"Tools"},{"location":"NANDPro/","text":"NANDPro NFO =============================================================================== SUPPORTED DEVICE INTERFACES =============================================================================== USB: LPC2148 Olimex USB header board. High performance 16MB/2Mins. LibUsb driver. LPT: Parallel Printer Port, SPP mode. Low performance, 16MB/35mins (cpu dependant). Dlportio printer port driver. XSVF: Subset device of USB. LPC2148 Olimex USB header board required. NOT for nand programming. This command line device type is for flashing .xsvf files to a Xilinx cpld. POST: Subset device of USB. LPC2148 Olimex USB header board required. NOT for nand programming. This command line device type is for monitoring Post codes only. The included .hex file supports both Nand SPI flash, Xilinx Programming, and Post Monitor all at the same time. The mode selected ie: Nand Flash/Xsvf/PostMon is determined by the command line. Previous .hex files as well as the \"pic\" version of hardware will not work. The Maximus \"NANDFlasher\" has an array of plated through holes to break out all the extra LPC2148 gpio. This product can be flashed with the new ArmV3.hex file for full comatibility with Nandpro. The wiring coordinates are included here for those who have this device. The included .jpg file shows the connections to flash this device with the Philips utility. An RS232 level shifter is also required for this purpose. The Team Executor \"NAND-X\" can also be flashed with the ArmV3.hex, however the wiring connections may be difficult, and are not listed in this document. =============================================================================== DRIVER AND HARDWARE INSTALLATION =============================================================================== USB Install: Flash the .hex file to the LPC2148 using the \"Philips LPC2000 FlashUtility\" or equivalent. Connect LPC2148 to computer USB. Point \"found new hardware\" to the \"custom.inf\" Windows reports: \"Your new hardware is ready to use\" USB Hardware: Connect only wires from EXT connectors to MAINBRD where indicated. Connect only wires from EXT connectors to Xilinx jtag connector where indicated. No resistors or diodes at all. For sure! Do not add them! =============================================================================== LPT Install: Run the port95nt.exe application to install the DlPortio driver LPT Hardware: Some parallel ports run at 3.3v others at 5v. The MAINBRD is 3.3 volts. It is recommend to use 100 ohm series saftey resistors (R) for all lpt connections except for DB25.11 and DB25.18 (GND), as shown above. Testing with 5 volt lpt and NO resistors didn't burn anything up though. YMMV For DB25.11 connect diode exactly as shown. It is highly recommended to connect the diode to the MAINBRD end rather than the PC end of the wire. Preferred diode is BAT41 or other Schottkey switch diode with low forward voltage drop. 1N4148/53, 1N914, type switching diodes should be also be ok, but are not quite as good. 1N400X are rectifiers and not good at all. This solution isn't perfect but you typically dont leave it hooked up forever anyway. If someone wants to design and post a buffer circuit go right ahead. I can't be bothered =============================================================================== COMMAND LINE USAGE =============================================================================== NandPro v3.0a by Tiros Useage: To invoke Nand SPI flasher use: NandPro dev: -r# Filename (HexStartBlock HexBlockCount) ->Read NandPro dev: -w# Filename (HexStartBlock HexBlockCount) ->Write NandPro dev: -e# (HexStartBlock HexBlockCount) ->Erase dev: Is hardware interface usb: or lpt: dev: Can also be a filename:, to be used as a 'Virtual Nand Device' Virtual device config can be forced, by appending :HexConfigValue # Is nand size (16, 64, 256, 512) in MegaBytes HexBlocks are optional range limits, default is entire device -r# Read saving file RAW (with SPARE) -R# Read saving file without SPARE !r# Read saving only the SPARE data -w# Write RAW (with SPARE) file +w# Write RAW (with SPARE) file, init SPARE, block numbers, ECC @w# Write RAW (with SPARE) file, init block numbers, ECC *w# Write RAW (with SPARE) file, init ECC +W# Write while ADDING SPARE from file without SPARE To invoke Xilinx xsvf flasher use: NandPro xsvf: XsvfInputFilename.xsvf To invoke usb post monitor use: NandPro post: PostLogFileName.txt =============================================================================== =============================================================================== .XSVF CPLD CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Follow instructions for USB install. Make the following connections from the LPC2148 to the Xilinx device Jtag conenctor: ArmLpc Jtag Olimex Maximus 3.3v VCC EXT2.24 M1 GND GND EXT2.25 N3 P0.17 TCK EXT1.18 A2 P0.18 TDO EXT1.19 B3 P0.19 TDI EXT1.20 C1 P0.20 TMS EXT1.21 C2 Xilinx CPLD flashing typical command line: Flash a .xsvf file, created by Impact, to cpld: Nandpro xsvf: filename.xsvf General XSVF notes: LPT is not supported for this feature. Requires additional connections from LPC2148 to the Xilinx jtag connector. The Xilinx Impact tool is used to create .xsvf files. The Xilinx Impact software records/redirects cpld operations into a binary file (.xsvf) that can be processed by Nandpro. IE: Nandpro does not flash .jed files, but .jed files may be directly converted to .xsvf by Impact. See the Xilinx Impact tool for more information. =============================================================================== =============================================================================== POST MONITOR CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Follow instructions for USB install. The post connections require level shifting to 3.3 volts to be monitored. This will require an external circuit. The cpld can also be used for this purpose. Flash cpld with nandpro: nandpro xsvf: SlimPlusPost.xsvf The SlimPlusPost.xsvf is fully compatible with the existing released pinout with the exception of the DBG pin. The DBG pin has been relocated and now drives via open collector. The LED will remain off, and flash briefly on each reset attempt. To connect an LED to the DBG pin: 3.3V---/\\/\\330/\\/\\--->|-------DBG 3 (37) Make the following connections from the LPC2148 to the cpld level shifter outputs: ArmLpc Post Olimex Maximus CPLD Out (CMOD) P1.16 Post0 EXT2.5 L1 38 (28) P1.17 Post1 EXT2.6 J2 37 (27) P1.18 Post2 EXT2.7 I1 36 (26) P1.19 Post3 EXT2.8 G3 34 (25) P1.20 Post4 EXT2.9 A1 33 (24) P1.21 Post5 EXT2.10 D3 32 (23) P1.22 Post6 EXT2.11 E1 31 (22) P1.23 Post7 EXT2.12 G1 30 (18) Make the following connections from the main board post outputs to the cpld level shifter inputs: Mbrd CPLD Post Out In (CMOD) Post0 39 (29) Post1 40 (30) Post2 41 (31) Post3 42 (32) Post4 43 (33) Post5 44 (34) Post6 1 (35) Post7 2 (36) Post monitor typical command line: Nandpro post: PostLog.txt General post monitoring notes: LPT is not supported for this feature. Post changes will be displayed on the command line and logged to the specified filename as a text file. The log file will be over written on each run. Pressing any key will break the post monitor loop. =============================================================================== =============================================================================== NAND FLASHING CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Seven connections must be made from MAINBRD to the HW device interface. MAINBRD connects as specified to either Olimex board, or a PC printer port. ArmLpc Olimex LPT MAINBRD SS EXT1-3 DB25.1 --R--- J1D2.2 MISO EXT1-6 DB25.11 -->|-- J1D2.4 Diode, observe polarity! P0.28 EXT2-1 DB25.16 --R--- J2B1.6 GND EXT1-26 DB25.18 ------ J1D2.6 or J2B1.12 MOSI EXT1-7 DB25.14 --R--- J1D2.1 SCK EXT1-5 DB25.2 --R--- J1D2.3 P0.29 EXT2-2 DB25.17 --R--- J2B1.5 Make connections to MAINBRD and run the app. MAINBRD needs to be plugged in to AC power. Actually powered on or not does not matter. While running NandPro application reset will occur. After nand operation is complete, reset will be released. Nand flashing typical command line: Read entire 16M flash, including SPARE: NandPro dev: -r16 nand.bin Write entire 16M flash, including SPARE: NandPro dev: -w16 nand.bin Advanced command line examples: Read encrypted key vault with SPARE: nandpro dev: -r16 rawkv.bin 1 1 Read encrypted key vault from a \"Virtual Nand\" dev:, named vnand.bin, with SPARE : nandpro vnand.bin: -r16 rawkv.bin 1 1 Write encrypted key vault: nandpro dev: -w16 rawkv.bin 1 1 Flash a xell.bin compiler output (no SPARE) to block 40, adding SPARE while flashing: nandpro dev: +W16 xell.bin 40 Read config block from a \"Virtual Nand\", named vnand.bin, without SPARE: nandpro vnand.bin: -R16 configblk.bin 0x??? 1 Write above config block to dev: adding the SPARE back in: nandpro dev: +W16 configblk.bin 0x??? 1 Write a \"small\" python.ECC file to \"full size\" \"Virtual Nand\" : nandpro vnand.bin: -w16 python.ECC Write to a dev:, from another RAW file, fixing ECC while writing: nandpro dev: -w16 DumpWithErrors.bin General nand flashing notes: SPARE is the 16 bytes following a data block. ECC is 26 bits located within the spare area. Block numbers are also contained in spare area. Reading and writing defaults to the entire device. The start block argumnet is optional and dictates the starting block to program. The ending block is also optional, and end if no block is specified, programming will continue until end of file or end of specified nand size. Large block nands have different SPARE format than small block nands. The software uses the detected device's SPARE format for all (+) write operations. Files written RAW (-) are not translated in any way. The \"nand size\" argument only sets the limit of available blocks for device operations. It is not hardware related, and need not exactly match the true device. There is no need to erase before programming. You can hex edit a block, and use Nandpro to fix its ECC when you write it back. The \"Case\" of the command generally indicates if I/O file will contain SPARE or not Upper Case: No SPARE Lower Case: RAW (with SPARE) The \"Virtual Nand\" file can be read or be programmed, as if it where a device. The \"Virtual Nand\" file must be a raw file, containing SPARE. This can be used to extract or inject data from\\to an existing raw dump. Example: To inject a \"small\" python image into an existing \"full size\" image, or to extract individual blocks from an existing raw dump. Note: For the vnand: device the flash config is normally automatically detected. Some \"hybrid\" 256/512 images can not be detected properly, to mount these files the config value must be forced by specifying it as the last argument on the command line, preceeded by a ':'. Only vnand: device may be forced! Example: nandpro vnand.bin: -r64 rawkv.bin 1 1 :AA3020 READING WILL OVER-WRITE AN EXISTING FILE WITHOUT WARNING! NEW LOG FILE WILL OVERWRITE OLD WITHOUT WARNING! DO NOT LEAVE LPT CABLE CONNECTED WHEN CONSOLE DOES NOT HAVE AC POWER! =============================================================================== HISTORY =============================================================================== // //2.0 //Initial Release // //2.0a //Fixed usage for +W, +w //Fixed problem with payload injection for large block nands //Fixed miscalc of file blocks togo when injecting !raw //No ARM code impact // // //2.0b //Remove \"Press Any Key\" for unattended batch file processing //Removed retry on individual sectors, retry entire block instead, including erase // attempt to program all sectors anyway, then report status //ARM code update required for above //Added ARM HW version test, (U32) 0000 0001 required or abort //Added \"Virtual Nand\" device // // //2.0c //Bit settling verify feature added for LPT reading //Add support for Jasper16a //Improved detection for virtual nand device, fixes some problems with writing to vnand. //Allways corrects the ECC bytes (but not SPARE), even in raw mode // ie: A raw file that has been hex edited can simply be flashed with -w // //Added command line swithces //%r will read SPARE data only, 16 bytes per block //@w will write RAW file, while correcting block numbers //Can \"force\" a flash config on command line by appending :HexFlashConfig // //2.0d //For compatibility purposes -w does not calculate ECC //Raw files are flashed pure using -w. To correct ECC errors use *w instead // ie: A raw file that has been hex edited can simply be flashed with *w // //2.0e //Fixed the \"forced\" flash config on command line for virtual nand device. // //3.0a //Requires new v3 .hex for arm //Suppport added to flash .xsvf files by jtag //Support added for post monitoring and logging // Category:Xbox360_Homebrew_Software","title":"NANDPro"},{"location":"NANDPro/#nandpro","text":"","title":"NANDPro"},{"location":"NANDPro/#nfo","text":"=============================================================================== SUPPORTED DEVICE INTERFACES =============================================================================== USB: LPC2148 Olimex USB header board. High performance 16MB/2Mins. LibUsb driver. LPT: Parallel Printer Port, SPP mode. Low performance, 16MB/35mins (cpu dependant). Dlportio printer port driver. XSVF: Subset device of USB. LPC2148 Olimex USB header board required. NOT for nand programming. This command line device type is for flashing .xsvf files to a Xilinx cpld. POST: Subset device of USB. LPC2148 Olimex USB header board required. NOT for nand programming. This command line device type is for monitoring Post codes only. The included .hex file supports both Nand SPI flash, Xilinx Programming, and Post Monitor all at the same time. The mode selected ie: Nand Flash/Xsvf/PostMon is determined by the command line. Previous .hex files as well as the \"pic\" version of hardware will not work. The Maximus \"NANDFlasher\" has an array of plated through holes to break out all the extra LPC2148 gpio. This product can be flashed with the new ArmV3.hex file for full comatibility with Nandpro. The wiring coordinates are included here for those who have this device. The included .jpg file shows the connections to flash this device with the Philips utility. An RS232 level shifter is also required for this purpose. The Team Executor \"NAND-X\" can also be flashed with the ArmV3.hex, however the wiring connections may be difficult, and are not listed in this document. =============================================================================== DRIVER AND HARDWARE INSTALLATION =============================================================================== USB Install: Flash the .hex file to the LPC2148 using the \"Philips LPC2000 FlashUtility\" or equivalent. Connect LPC2148 to computer USB. Point \"found new hardware\" to the \"custom.inf\" Windows reports: \"Your new hardware is ready to use\" USB Hardware: Connect only wires from EXT connectors to MAINBRD where indicated. Connect only wires from EXT connectors to Xilinx jtag connector where indicated. No resistors or diodes at all. For sure! Do not add them! =============================================================================== LPT Install: Run the port95nt.exe application to install the DlPortio driver LPT Hardware: Some parallel ports run at 3.3v others at 5v. The MAINBRD is 3.3 volts. It is recommend to use 100 ohm series saftey resistors (R) for all lpt connections except for DB25.11 and DB25.18 (GND), as shown above. Testing with 5 volt lpt and NO resistors didn't burn anything up though. YMMV For DB25.11 connect diode exactly as shown. It is highly recommended to connect the diode to the MAINBRD end rather than the PC end of the wire. Preferred diode is BAT41 or other Schottkey switch diode with low forward voltage drop. 1N4148/53, 1N914, type switching diodes should be also be ok, but are not quite as good. 1N400X are rectifiers and not good at all. This solution isn't perfect but you typically dont leave it hooked up forever anyway. If someone wants to design and post a buffer circuit go right ahead. I can't be bothered =============================================================================== COMMAND LINE USAGE =============================================================================== NandPro v3.0a by Tiros Useage: To invoke Nand SPI flasher use: NandPro dev: -r# Filename (HexStartBlock HexBlockCount) ->Read NandPro dev: -w# Filename (HexStartBlock HexBlockCount) ->Write NandPro dev: -e# (HexStartBlock HexBlockCount) ->Erase dev: Is hardware interface usb: or lpt: dev: Can also be a filename:, to be used as a 'Virtual Nand Device' Virtual device config can be forced, by appending :HexConfigValue # Is nand size (16, 64, 256, 512) in MegaBytes HexBlocks are optional range limits, default is entire device -r# Read saving file RAW (with SPARE) -R# Read saving file without SPARE !r# Read saving only the SPARE data -w# Write RAW (with SPARE) file +w# Write RAW (with SPARE) file, init SPARE, block numbers, ECC @w# Write RAW (with SPARE) file, init block numbers, ECC *w# Write RAW (with SPARE) file, init ECC +W# Write while ADDING SPARE from file without SPARE To invoke Xilinx xsvf flasher use: NandPro xsvf: XsvfInputFilename.xsvf To invoke usb post monitor use: NandPro post: PostLogFileName.txt =============================================================================== =============================================================================== .XSVF CPLD CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Follow instructions for USB install. Make the following connections from the LPC2148 to the Xilinx device Jtag conenctor: ArmLpc Jtag Olimex Maximus 3.3v VCC EXT2.24 M1 GND GND EXT2.25 N3 P0.17 TCK EXT1.18 A2 P0.18 TDO EXT1.19 B3 P0.19 TDI EXT1.20 C1 P0.20 TMS EXT1.21 C2 Xilinx CPLD flashing typical command line: Flash a .xsvf file, created by Impact, to cpld: Nandpro xsvf: filename.xsvf General XSVF notes: LPT is not supported for this feature. Requires additional connections from LPC2148 to the Xilinx jtag connector. The Xilinx Impact tool is used to create .xsvf files. The Xilinx Impact software records/redirects cpld operations into a binary file (.xsvf) that can be processed by Nandpro. IE: Nandpro does not flash .jed files, but .jed files may be directly converted to .xsvf by Impact. See the Xilinx Impact tool for more information. =============================================================================== =============================================================================== POST MONITOR CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Follow instructions for USB install. The post connections require level shifting to 3.3 volts to be monitored. This will require an external circuit. The cpld can also be used for this purpose. Flash cpld with nandpro: nandpro xsvf: SlimPlusPost.xsvf The SlimPlusPost.xsvf is fully compatible with the existing released pinout with the exception of the DBG pin. The DBG pin has been relocated and now drives via open collector. The LED will remain off, and flash briefly on each reset attempt. To connect an LED to the DBG pin: 3.3V---/\\/\\330/\\/\\--->|-------DBG 3 (37) Make the following connections from the LPC2148 to the cpld level shifter outputs: ArmLpc Post Olimex Maximus CPLD Out (CMOD) P1.16 Post0 EXT2.5 L1 38 (28) P1.17 Post1 EXT2.6 J2 37 (27) P1.18 Post2 EXT2.7 I1 36 (26) P1.19 Post3 EXT2.8 G3 34 (25) P1.20 Post4 EXT2.9 A1 33 (24) P1.21 Post5 EXT2.10 D3 32 (23) P1.22 Post6 EXT2.11 E1 31 (22) P1.23 Post7 EXT2.12 G1 30 (18) Make the following connections from the main board post outputs to the cpld level shifter inputs: Mbrd CPLD Post Out In (CMOD) Post0 39 (29) Post1 40 (30) Post2 41 (31) Post3 42 (32) Post4 43 (33) Post5 44 (34) Post6 1 (35) Post7 2 (36) Post monitor typical command line: Nandpro post: PostLog.txt General post monitoring notes: LPT is not supported for this feature. Post changes will be displayed on the command line and logged to the specified filename as a text file. The log file will be over written on each run. Pressing any key will break the post monitor loop. =============================================================================== =============================================================================== NAND FLASHING CONNECTIONS AND OPERATION =============================================================================== =============================================================================== Seven connections must be made from MAINBRD to the HW device interface. MAINBRD connects as specified to either Olimex board, or a PC printer port. ArmLpc Olimex LPT MAINBRD SS EXT1-3 DB25.1 --R--- J1D2.2 MISO EXT1-6 DB25.11 -->|-- J1D2.4 Diode, observe polarity! P0.28 EXT2-1 DB25.16 --R--- J2B1.6 GND EXT1-26 DB25.18 ------ J1D2.6 or J2B1.12 MOSI EXT1-7 DB25.14 --R--- J1D2.1 SCK EXT1-5 DB25.2 --R--- J1D2.3 P0.29 EXT2-2 DB25.17 --R--- J2B1.5 Make connections to MAINBRD and run the app. MAINBRD needs to be plugged in to AC power. Actually powered on or not does not matter. While running NandPro application reset will occur. After nand operation is complete, reset will be released. Nand flashing typical command line: Read entire 16M flash, including SPARE: NandPro dev: -r16 nand.bin Write entire 16M flash, including SPARE: NandPro dev: -w16 nand.bin Advanced command line examples: Read encrypted key vault with SPARE: nandpro dev: -r16 rawkv.bin 1 1 Read encrypted key vault from a \"Virtual Nand\" dev:, named vnand.bin, with SPARE : nandpro vnand.bin: -r16 rawkv.bin 1 1 Write encrypted key vault: nandpro dev: -w16 rawkv.bin 1 1 Flash a xell.bin compiler output (no SPARE) to block 40, adding SPARE while flashing: nandpro dev: +W16 xell.bin 40 Read config block from a \"Virtual Nand\", named vnand.bin, without SPARE: nandpro vnand.bin: -R16 configblk.bin 0x??? 1 Write above config block to dev: adding the SPARE back in: nandpro dev: +W16 configblk.bin 0x??? 1 Write a \"small\" python.ECC file to \"full size\" \"Virtual Nand\" : nandpro vnand.bin: -w16 python.ECC Write to a dev:, from another RAW file, fixing ECC while writing: nandpro dev: -w16 DumpWithErrors.bin General nand flashing notes: SPARE is the 16 bytes following a data block. ECC is 26 bits located within the spare area. Block numbers are also contained in spare area. Reading and writing defaults to the entire device. The start block argumnet is optional and dictates the starting block to program. The ending block is also optional, and end if no block is specified, programming will continue until end of file or end of specified nand size. Large block nands have different SPARE format than small block nands. The software uses the detected device's SPARE format for all (+) write operations. Files written RAW (-) are not translated in any way. The \"nand size\" argument only sets the limit of available blocks for device operations. It is not hardware related, and need not exactly match the true device. There is no need to erase before programming. You can hex edit a block, and use Nandpro to fix its ECC when you write it back. The \"Case\" of the command generally indicates if I/O file will contain SPARE or not Upper Case: No SPARE Lower Case: RAW (with SPARE) The \"Virtual Nand\" file can be read or be programmed, as if it where a device. The \"Virtual Nand\" file must be a raw file, containing SPARE. This can be used to extract or inject data from\\to an existing raw dump. Example: To inject a \"small\" python image into an existing \"full size\" image, or to extract individual blocks from an existing raw dump. Note: For the vnand: device the flash config is normally automatically detected. Some \"hybrid\" 256/512 images can not be detected properly, to mount these files the config value must be forced by specifying it as the last argument on the command line, preceeded by a ':'. Only vnand: device may be forced! Example: nandpro vnand.bin: -r64 rawkv.bin 1 1 :AA3020 READING WILL OVER-WRITE AN EXISTING FILE WITHOUT WARNING! NEW LOG FILE WILL OVERWRITE OLD WITHOUT WARNING! DO NOT LEAVE LPT CABLE CONNECTED WHEN CONSOLE DOES NOT HAVE AC POWER! =============================================================================== HISTORY =============================================================================== // //2.0 //Initial Release // //2.0a //Fixed usage for +W, +w //Fixed problem with payload injection for large block nands //Fixed miscalc of file blocks togo when injecting !raw //No ARM code impact // // //2.0b //Remove \"Press Any Key\" for unattended batch file processing //Removed retry on individual sectors, retry entire block instead, including erase // attempt to program all sectors anyway, then report status //ARM code update required for above //Added ARM HW version test, (U32) 0000 0001 required or abort //Added \"Virtual Nand\" device // // //2.0c //Bit settling verify feature added for LPT reading //Add support for Jasper16a //Improved detection for virtual nand device, fixes some problems with writing to vnand. //Allways corrects the ECC bytes (but not SPARE), even in raw mode // ie: A raw file that has been hex edited can simply be flashed with -w // //Added command line swithces //%r will read SPARE data only, 16 bytes per block //@w will write RAW file, while correcting block numbers //Can \"force\" a flash config on command line by appending :HexFlashConfig // //2.0d //For compatibility purposes -w does not calculate ECC //Raw files are flashed pure using -w. To correct ECC errors use *w instead // ie: A raw file that has been hex edited can simply be flashed with *w // //2.0e //Fixed the \"forced\" flash config on command line for virtual nand device. // //3.0a //Requires new v3 .hex for arm //Suppport added to flash .xsvf files by jtag //Support added for post monitoring and logging // Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"NAND_Bad_Blocks/","text":"What is a BLOCK? A block is the smallest logically addressable unit of data that a specified device can transfer in an input/output operation. For XBOX 360s that is either 16KB or 128KB. What is a BAD BLOCK? Bad Blocks are blocks that contain one or more invalid bits whose reliability is not guaranteed. Bad Blocks may be present when the device is shipped, or may develop during the lifetime of the device. How to determine BAD BLOCKS? In one block there are n Pages, all have a fixed size of 528 Bytes (nomatter if the Block is 16K or 128K). Every Page has 16 Byte big ECC data at its end. The block itself does not have ECC data, only the pages have! In theory the whole block gets filled with zeros if its bad, practicly it's not like that. So, if the first 12 Bytes of the page's ECC data is nulled, the page is marked bad, so the whole block is aswell. The remaining 4 Bytes of the ECC is the CRC Data. If the first 12 Bytes of ECC is 0xFF the page has no data (empty, but NOT faulty) and if it hold anything else than 0x00 or 0xFF then the page is filled with data. What happens when a BAD BLOCK develops? There are two methods to replace the block. Skip Block Method Reserve Block Method How does the Reserve Block Method work? Blocks are not skipped but rather they are re-directed to a Reserved Block Area used specifically for Bad Block replacement. The Reserved Block Area also stores/saves the Bad Block Table that keeps track of the re-mapped \u201cdeveloped Bad Blocks\u201d. Which method does the XBOX employ? Short answer both. In 16MB nands the XBOX exclusively uses the Reserve Block Method, while in 256MB or 512MB nands it uses both. The MU area of the nand uses the Skip Block Method, while the area where the dash and kernel are stored uses the Reserve Block Method. XBOX 16MB NAND BLOCK Management If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Bad Block(0x168) is moved to Block 0x3FF in the reserved area, the next(0x1F6) is moved to 0X3FE, and it continues until all Bad Blocks have been remapped. When I read my nand I have Badblocks where is that data stored? When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0x3DE(First Config Block), and 0x3DF(Second Config Block). How would I remap the BadBlocks in the diagram with nandpro? Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow: nandpro xbr.bin: -r16 badblock168.bin 168 1 nandpro xbr.bin: -w16 badblock168.bin 3FF 1 nandpro xbr.bin: -r16 badblock1F6.bin 1F6 1 nandpro xbr.bin: -w16 badblock1F6.bin 3FE 1 nandpro xbr.bin: -r16 badblock23A.bin 23A 1 nandpro xbr.bin: -w16 badblock23A.bin 3FD 1 nandpro xbr.bin: -r16 badblock308.bin 308 1 nandpro xbr.bin: -w16 badblock308.bin 3FC 1 If using XeLLous to flash do I need to remap Badblocks? According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux. I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version). First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 3FF, and each following Badblock gets remapped as illustrated in the diagram): nandpro lpt: -r16 backup3FF.bin 3FF 1 Assuming your first Badblock was at 0x010, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this. nandpro xell.bin: -r16 xell10.bin 10 1 nandpro lpt: -w16 xell10.bin 3FF 1 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version). XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND. Therefore, the following steps must be carried out: Assuming your first Badblock was at 0x010, Make a copy of your original NAND copy nanddump.bin tempnand.bin Write the ECC to your NAND as per normal: nandpro [LPT|USB]: +w16 image_00000000.ecc. At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal. Write the ECC to tempnand.bin using NANDPro: nandpro tempnand.bin: +w16 image_00000000.ecc Read block 0x010 from your newly written-to VNAND: nandpro tempnand.bin: -r16 010.bin 10 1 5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case. nandpro [LPT|USB]: -w16 010.bin 3FF Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) -- Xb0xGuru 15:19, 24 February 2013 (UTC) XBOX 256/512MB NAND BLOCK Management Understanding 256/512 MB memory map, and Nandpro\u2019s translation: The block size in 256/512 Nands is 132 KB (135168 Bytes). This is a little different then how Nandpro references and addresses blocks. No matter the Block size of your nand nandpro uses a block size of 16 KB that means that for every Badblock in the 256/512 MB nandpro will report 8 consecutive errors. If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Badblock (0x0F8) is moved to Block 0xFF8 (16 KB) or Block 0x1FF (132 KB) in the reserved area, any consecutive Badblocks would of been moved to blocks 0xFF0 (16 KB) or Block 0x1FE (132 KB) and so forth. When I read my nand I have Badblocks where is that data stored? When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0xEF7(Config Block),. How would I remap the BadBlocks in the diagram with nandpro? Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow: nandpro xbr.bin: -r16 badblockF8.bin F8 8 nandpro xbr.bin: -w16 badblockF8.bin FF8 8 Is 8 correct? Yes remember nandpro reference blocks in sizes of 16 KB, but 256/512 MB have a block size of 132 KB. 132/16 is equal to 8, that why you need to use 8. If using XeLLous to flash do I need to remap Badblocks? According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux. I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version). First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 0xFF8, and each following Badblock gets remapped to the spare): nandpro lpt: -r256 backupFF8.bin FF8 8 Assuming your first Badblock was at 0x010 followed by seven more errors, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this. nandpro xell.bin: -r16 xell10.bin 10 8 nandpro lpt: -w16 xell10.bin FF8 8 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version). XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND. Therefore, the following steps must be carried out: Assuming your first Badblock was at 0x010, 1. Make a copy of your original NAND copy nanddump.bin tempnand.bin 2. Write the ECC to your NAND as per normal: nandpro [LPT|USB]: +w16 image_00000000.ecc At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal. 3. Write the ECC to tempnand.bin using NANDPro: nandpro tempnand.bin: +w16 image_00000000.ecc 4. Read block 0x010 from your newly written-to VNAND: nandpro tempnand.bin: -r16 010.bin 10 8 5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case. nandpro [LPT|USB]: -w16 010.bin FF8 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 8 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) -- Xb0xGuru 15:19, 24 February 2013 (UTC) Source: google-docs (archive.org mirror) & XBH, posted by trancy Category:Xbox360_Hardware Category:Xbox360 System Software","title":"NAND Bad Blocks"},{"location":"NAND_Bad_Blocks/#what-is-a-block","text":"A block is the smallest logically addressable unit of data that a specified device can transfer in an input/output operation. For XBOX 360s that is either 16KB or 128KB.","title":"What is a BLOCK?"},{"location":"NAND_Bad_Blocks/#what-is-a-bad-block","text":"Bad Blocks are blocks that contain one or more invalid bits whose reliability is not guaranteed. Bad Blocks may be present when the device is shipped, or may develop during the lifetime of the device.","title":"What is a BAD BLOCK?"},{"location":"NAND_Bad_Blocks/#how-to-determine-bad-blocks","text":"In one block there are n Pages, all have a fixed size of 528 Bytes (nomatter if the Block is 16K or 128K). Every Page has 16 Byte big ECC data at its end. The block itself does not have ECC data, only the pages have! In theory the whole block gets filled with zeros if its bad, practicly it's not like that. So, if the first 12 Bytes of the page's ECC data is nulled, the page is marked bad, so the whole block is aswell. The remaining 4 Bytes of the ECC is the CRC Data. If the first 12 Bytes of ECC is 0xFF the page has no data (empty, but NOT faulty) and if it hold anything else than 0x00 or 0xFF then the page is filled with data.","title":"How to determine BAD BLOCKS?"},{"location":"NAND_Bad_Blocks/#what-happens-when-a-bad-block-develops","text":"There are two methods to replace the block. Skip Block Method Reserve Block Method","title":"What happens when a BAD BLOCK develops?"},{"location":"NAND_Bad_Blocks/#how-does-the-reserve-block-method-work","text":"Blocks are not skipped but rather they are re-directed to a Reserved Block Area used specifically for Bad Block replacement. The Reserved Block Area also stores/saves the Bad Block Table that keeps track of the re-mapped \u201cdeveloped Bad Blocks\u201d. Which method does the XBOX employ? Short answer both. In 16MB nands the XBOX exclusively uses the Reserve Block Method, while in 256MB or 512MB nands it uses both. The MU area of the nand uses the Skip Block Method, while the area where the dash and kernel are stored uses the Reserve Block Method.","title":"How does the Reserve Block Method work?"},{"location":"NAND_Bad_Blocks/#xbox-16mb-nand-block-management","text":"If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Bad Block(0x168) is moved to Block 0x3FF in the reserved area, the next(0x1F6) is moved to 0X3FE, and it continues until all Bad Blocks have been remapped.","title":"XBOX 16MB NAND BLOCK Management"},{"location":"NAND_Bad_Blocks/#when-i-read-my-nand-i-have-badblocks-where-is-that-data-stored","text":"When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0x3DE(First Config Block), and 0x3DF(Second Config Block).","title":"When I read my nand I have Badblocks where is that data stored?"},{"location":"NAND_Bad_Blocks/#how-would-i-remap-the-badblocks-in-the-diagram-with-nandpro","text":"Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow: nandpro xbr.bin: -r16 badblock168.bin 168 1 nandpro xbr.bin: -w16 badblock168.bin 3FF 1 nandpro xbr.bin: -r16 badblock1F6.bin 1F6 1 nandpro xbr.bin: -w16 badblock1F6.bin 3FE 1 nandpro xbr.bin: -r16 badblock23A.bin 23A 1 nandpro xbr.bin: -w16 badblock23A.bin 3FD 1 nandpro xbr.bin: -r16 badblock308.bin 308 1 nandpro xbr.bin: -w16 badblock308.bin 3FC 1","title":"How would I remap the BadBlocks in the diagram with nandpro?"},{"location":"NAND_Bad_Blocks/#if-using-xellous-to-flash-do-i-need-to-remap-badblocks","text":"According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux.","title":"If using XeLLous to flash do I need to remap Badblocks?"},{"location":"NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-free60-version","text":"First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 3FF, and each following Badblock gets remapped as illustrated in the diagram): nandpro lpt: -r16 backup3FF.bin 3FF 1 Assuming your first Badblock was at 0x010, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this. nandpro xell.bin: -r16 xell10.bin 10 1 nandpro lpt: -w16 xell10.bin 3FF 1 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version)."},{"location":"NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-rgh-team-xecuter-dgx-version","text":"XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND. Therefore, the following steps must be carried out: Assuming your first Badblock was at 0x010, Make a copy of your original NAND copy nanddump.bin tempnand.bin Write the ECC to your NAND as per normal: nandpro [LPT|USB]: +w16 image_00000000.ecc. At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal. Write the ECC to tempnand.bin using NANDPro: nandpro tempnand.bin: +w16 image_00000000.ecc Read block 0x010 from your newly written-to VNAND: nandpro tempnand.bin: -r16 010.bin 10 1 5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case. nandpro [LPT|USB]: -w16 010.bin 3FF Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) -- Xb0xGuru 15:19, 24 February 2013 (UTC)","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version)."},{"location":"NAND_Bad_Blocks/#xbox-256512mb-nand-block-management","text":"","title":"XBOX 256/512MB NAND BLOCK Management"},{"location":"NAND_Bad_Blocks/#understanding-256512-mb-memory-map-and-nandpros-translation","text":"The block size in 256/512 Nands is 132 KB (135168 Bytes). This is a little different then how Nandpro references and addresses blocks. No matter the Block size of your nand nandpro uses a block size of 16 KB that means that for every Badblock in the 256/512 MB nandpro will report 8 consecutive errors. If you noticed in the memory table above any Badblocks encountered are consecutively moved to the Reserved BadBlock Area. The first Badblock (0x0F8) is moved to Block 0xFF8 (16 KB) or Block 0x1FF (132 KB) in the reserved area, any consecutive Badblocks would of been moved to blocks 0xFF0 (16 KB) or Block 0x1FE (132 KB) and so forth.","title":"Understanding 256/512 MB memory map, and Nandpro\u2019s translation:"},{"location":"NAND_Bad_Blocks/#when-i-read-my-nand-i-have-badblocks-where-is-that-data-stored_1","text":"When reading your nand any Badblocks would have already been remapped to the reserve area. This is important to keep in mind, specifically when you encounter Badblocks where crucial data is kept such as blocks 0x001(Key Vault), 0xEF7(Config Block),.","title":"When I read my nand I have Badblocks where is that data stored?"},{"location":"NAND_Bad_Blocks/#how-would-i-remap-the-badblocks-in-the-diagram-with-nandpro_1","text":"Assuming your attempting to flash the latest release of XBReboot named as \u2018xbr.bin\u2019. And have made a full-backup and have already injected your Key Vault and Configuration Blocks into \u2018xbr.bin\u2019. The commands would be as follow: nandpro xbr.bin: -r16 badblockF8.bin F8 8 nandpro xbr.bin: -w16 badblockF8.bin FF8 8 Is 8 correct? Yes remember nandpro reference blocks in sizes of 16 KB, but 256/512 MB have a block size of 132 KB. 132/16 is equal to 8, that why you need to use 8.","title":"How would I remap the BadBlocks in the diagram with nandpro?"},{"location":"NAND_Bad_Blocks/#if-using-xellous-to-flash-do-i-need-to-remap-badblocks_1","text":"According to the XeLLous release notes no, it is suppose to be one of the main features of the update. That is not to say bugs might not be encountered. If you encounter suspicious issues, and believe it might be related to a bad flash, then I recommend flashing manually with nandpro or using trancy\u2019s XBR-Flash for Linux.","title":"If using XeLLous to flash do I need to remap Badblocks?"},{"location":"NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-free60-version_1","text":"First of all ensure your using the free60 version of Xell. Next you will need to backup the location of the remapped BadBlocks like so (Remeber your first Badblock always goes to 0xFF8, and each following Badblock gets remapped to the spare): nandpro lpt: -r256 backupFF8.bin FF8 8 Assuming your first Badblock was at 0x010 followed by seven more errors, you will need to remap the free60 Xell data that was intended to be stored in that block. Like this. nandpro xell.bin: -r16 xell10.bin 10 8 nandpro lpt: -w16 xell10.bin FF8 8 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 1 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.)","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (free60 version)."},{"location":"NAND_Bad_Blocks/#i-have-a-badblock-between-blocks-0x000-and-0x050-and-cant-boot-into-xell-rgh-team-xecuter-dgx-version_1","text":"XeLL for RGH/DGX is written with +w16 ('+' to signify the recreation of ECC data) so you cannot simply -r16 from image_00000000.ecc (or DGX.ecc) as it's not seen by NANDPro as a valid VNAND. Therefore, the following steps must be carried out: Assuming your first Badblock was at 0x010, 1. Make a copy of your original NAND copy nanddump.bin tempnand.bin 2. Write the ECC to your NAND as per normal: nandpro [LPT|USB]: +w16 image_00000000.ecc At this point you should confirm that you get an 'error xxx writing to xxx' message. This is perfectly normal. 3. Write the ECC to tempnand.bin using NANDPro: nandpro tempnand.bin: +w16 image_00000000.ecc 4. Read block 0x010 from your newly written-to VNAND: nandpro tempnand.bin: -r16 010.bin 10 8 5. Write the block to the same place in the spare area as the original relocated bad block. If this is the first bad block, it should be 0x3FF but check using 360 Flash Dump Tool, xNANDHealer, J-Runner etc to ensure this is the case. nandpro [LPT|USB]: -w16 010.bin FF8 Lastly the bad block needs to erased to prevent any corruption: nandpro lpt: -e16 10 8 (EDIT: The bad block may not need to be erased. If the CRC in the ECC data doesn't match that of the page, the SMC will deem it a bad block anyway and then look to the spare area for a relocated block.) -- Xb0xGuru 15:19, 24 February 2013 (UTC) Source: google-docs (archive.org mirror) & XBH, posted by trancy Category:Xbox360_Hardware Category:Xbox360 System Software","title":"I have a Badblock between blocks 0x000 and 0x050, and can\u2019t boot into Xell (RGH / Team-Xecuter DGX version)."},{"location":"NAND_File_System/","text":"NAND Flash System The Xbox 360 NAND uses a proprietary format created by Microsoft. The format is used to store console-specific data (keyvault, config blocks, etc) and system data (bootloaders, kernel/hypervisor, dashboard files). The NAND is split into two sections - one for storing the keyvault, bootloaders and config blocks and one for storing the dashboard files. The file are stored using a format which is designed to be transactional (each change can be reverted). NAND Basic Format The NAND uses a series of pages to combine into blocks, which are small snippets of data (usually 512 bytes) which each have an EDC tag at the end (an extra 16 bytes or 64 in bigblock). These pages are each part of a specific block (which can be identified with the EDC), which is usually made with 16 pages (or 32 for bigblock NANDs) Metadata All (non-eMMC) NANDs have specific Spare-/Metadata for each page inside the NAND. Sometimes it will not be dumped with the NAND, so it has to either be added back or redumped. The Metadata contains the pages block number, a series of flags and a checksum. Those differ slightly, depending on the blocksize. Small Block unsigned char BlockID1; // lba/id = (((BlockID0&0xF)<<8)+(BlockID1)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence0; // Not reversed unsigned char FsSequence1; unsigned char FsSequence2; unsigned char BadBlock; unsigned char FsSequence3; unsigned char FsSize1; // ((FsSize0<<8)+FsSize1) = cert size unsigned char FsSize0; unsigned char FsPageCount; // free pages left in block (ie: if 3 pages are used by cert then this would be 29:0x1d) unsigned char FsUnused1[0x2]; unsigned char FsBlockType : 6; unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0; Big Block on Small NAND unsigned char FsSequence0; unsigned char BlockID1; // lba/id = (((BlockID0<<8)&0xF)+(BlockID1&0xFF)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence1; unsigned char FsSequence2; unsigned char BadBlock; unsigned char FsSequence3; unsigned char FsSize1; // (((FsSize0<<8)&0xFF)+(FsSize1&0xFF)) = cert size unsigned char FsSize0; unsigned char FsPageCount; // free pages left in block (ie: if 3 pages are used by cert then this would be 29:0x1d) unsigned char FsUnused1[2]; unsigned char FsBlockType : 6; unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0; Big Block unsigned char BadBlock; unsigned char BlockID1; // lba/id = (((BlockID0&0xF)<<8)+(BlockID1&0xFF)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence2; // oddly, compared to before these are reversed...? unsigned char FsSequence1; unsigned char FsSequence0; unsigned char FsUnused1; unsigned char FsSize1; // FS: 06 ((FsSize0<<16)+(FsSize1<<8)+FsSize2) = cert size unsigned char FsSize0; // FS: 20 unsigned char FsPageCount; // FS: 04 free pages left in block (multiples of 4 pages, ie if 3f then 3f*4 pages are free after) unsigned char FsUnused2[0x2]; unsigned char FsBlockType : 6; // FS: 2a bitmap: 2c (both use FS: vals for size), mobiles unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0; Error Detection/Correction Code The ECC/EDC checksum uses a custom algorithm - here is C code for that: int checkEcc(u8* datc, u8* spare) { unsigned int i=0, val=0; unsigned char edc[4] = {0,0,0,0}; unsigned long * data = (unsigned long*) datc; unsigned int v=0; // printf(\"original ECC : %02x %02x %02x %02x \", (spare[0xC] & 0xC0), spare[0xD],spare[0xE],spare[0xF]); for (i = 0; i < 0x1066; i++) { if (!(i & 31)) { if (i == 0x1000) data = (unsigned long*)spare; v = ~*data++; // byte order: LE } val ^= v & 1; v>>=1; if (val & 1) val ^= 0x6954559; val >>= 1; } val = ~val; edc[0] = (val << 6) & 0xC0; edc[1] = (val >> 2) & 0xFF; edc[2] = (val >> 10) & 0xFF; edc[3] = (val >> 18) & 0xFF; if(((spare[0xC] & 0xC0) != edc[0])||(spare[0xD] != edc[1])||(spare[0xE] != edc[2])||(spare[0xF] != edc[3])) return ECC_FAILED; return ECC_CORRECT; } NAND Format The first byte of a NAND image should always be 0xFF. If it isn't 0xFF this isn't a valid image. Another thing which should be checked is the copyright header, which is located at 0x10 in the NAND. This string should be read in two parts (skipping the year out, as it changes depending when that xbox was made) and then checked against a control string (although some valid images have this string changed to zeropair). At 0x2 in the NAND the version of the flash is stored (2bytes). Further on at 0x8 the offset of the CB is stored, followed by the CF1 offset (4bytes each). At 0x6C the offset to the keyvault is located (4bytes). Up from that at 0x78 the length of the SMC and offset to the SMC are stored (4bytes each). System Management Controller finish later XeLL Image Layout The whole XeLL Image is pretty small with 1,3 MB compared to an original Xbox360 NAND-Image which is normally 16 MB or 64 MB. 0x00000000..0x000001ff (0x00000200 bytes) Header 0x00000200..0x000003ff (0x00000200 bytes) Exploit 0x00000400..0x00000fff (0x00000c00 bytes) Padding 0x00001000..0x00003fff (0x00003000 bytes) SMC 0x00004000..0x00007fff (0x00004000 bytes) Keyvault 0x00008000..0x000117ff (0x00009800 bytes) CB 1921 0x00011800..0x00016ebf (0x000056c0 bytes) CD 1921 0x00016ec0..0x0006cf2f (0x00056070 bytes) CE 1888 0x0006cf30..0x0006ffff (0x000030d0 bytes) Padding 0x00070000..0x000744bf (0x000044c0 bytes) CF 4532 0x000744c0..0x000a33ff (0x0002ef40 bytes) CG 4532 0x000a3400..0x000bffff (0x0001cc00 bytes) Padding 0x000c0000..0x000fffff (0x00040000 bytes) Xell (backup) 0x00100000..0x0013ffff (0x00040000 bytes) Xell (main) The (hacked) SMC Code is usually seen as Header + Exploit + Padding the actual SMC, so 0x0000 - 0x3FFF. The Keyvault is the unique \"System Information\" which holds stuff like DVDKey, Console Region, Console Serial and other things. Whole keyvault is crypted with CPUKey. After that exploitable CB (2BL) and CD (4BL), matching the console revision, follows. After padding CB/CD theres CE (Base-Kernel 1888) followed by exploitable Patchslots CF/CG (4532 or 4548) and again some padding. At the end of the Image theres a Backup-XeLL, which gets executed if the original XeLL fails (Bad Update maybe) followed by the original XeLL. Category:Xbox360 System Software","title":"NAND Flash System"},{"location":"NAND_File_System/#nand-flash-system","text":"The Xbox 360 NAND uses a proprietary format created by Microsoft. The format is used to store console-specific data (keyvault, config blocks, etc) and system data (bootloaders, kernel/hypervisor, dashboard files). The NAND is split into two sections - one for storing the keyvault, bootloaders and config blocks and one for storing the dashboard files. The file are stored using a format which is designed to be transactional (each change can be reverted).","title":"NAND Flash System"},{"location":"NAND_File_System/#nand-basic-format","text":"The NAND uses a series of pages to combine into blocks, which are small snippets of data (usually 512 bytes) which each have an EDC tag at the end (an extra 16 bytes or 64 in bigblock). These pages are each part of a specific block (which can be identified with the EDC), which is usually made with 16 pages (or 32 for bigblock NANDs)","title":"NAND Basic Format"},{"location":"NAND_File_System/#metadata","text":"All (non-eMMC) NANDs have specific Spare-/Metadata for each page inside the NAND. Sometimes it will not be dumped with the NAND, so it has to either be added back or redumped. The Metadata contains the pages block number, a series of flags and a checksum. Those differ slightly, depending on the blocksize.","title":"Metadata"},{"location":"NAND_File_System/#small-block","text":"unsigned char BlockID1; // lba/id = (((BlockID0&0xF)<<8)+(BlockID1)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence0; // Not reversed unsigned char FsSequence1; unsigned char FsSequence2; unsigned char BadBlock; unsigned char FsSequence3; unsigned char FsSize1; // ((FsSize0<<8)+FsSize1) = cert size unsigned char FsSize0; unsigned char FsPageCount; // free pages left in block (ie: if 3 pages are used by cert then this would be 29:0x1d) unsigned char FsUnused1[0x2]; unsigned char FsBlockType : 6; unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0;","title":"Small Block"},{"location":"NAND_File_System/#big-block-on-small-nand","text":"unsigned char FsSequence0; unsigned char BlockID1; // lba/id = (((BlockID0<<8)&0xF)+(BlockID1&0xFF)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence1; unsigned char FsSequence2; unsigned char BadBlock; unsigned char FsSequence3; unsigned char FsSize1; // (((FsSize0<<8)&0xFF)+(FsSize1&0xFF)) = cert size unsigned char FsSize0; unsigned char FsPageCount; // free pages left in block (ie: if 3 pages are used by cert then this would be 29:0x1d) unsigned char FsUnused1[2]; unsigned char FsBlockType : 6; unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0;","title":"Big Block on Small NAND"},{"location":"NAND_File_System/#big-block","text":"unsigned char BadBlock; unsigned char BlockID1; // lba/id = (((BlockID0&0xF)<<8)+(BlockID1&0xFF)) unsigned char BlockID0 : 4; unsigned char FsUnused0 : 4; unsigned char FsSequence2; // oddly, compared to before these are reversed...? unsigned char FsSequence1; unsigned char FsSequence0; unsigned char FsUnused1; unsigned char FsSize1; // FS: 06 ((FsSize0<<16)+(FsSize1<<8)+FsSize2) = cert size unsigned char FsSize0; // FS: 20 unsigned char FsPageCount; // FS: 04 free pages left in block (multiples of 4 pages, ie if 3f then 3f*4 pages are free after) unsigned char FsUnused2[0x2]; unsigned char FsBlockType : 6; // FS: 2a bitmap: 2c (both use FS: vals for size), mobiles unsigned char ECC3 : 2; unsigned char ECC2; // 14 bit ECD unsigned char ECC1; unsigned char ECC0;","title":"Big Block"},{"location":"NAND_File_System/#error-detectioncorrection-code","text":"The ECC/EDC checksum uses a custom algorithm - here is C code for that: int checkEcc(u8* datc, u8* spare) { unsigned int i=0, val=0; unsigned char edc[4] = {0,0,0,0}; unsigned long * data = (unsigned long*) datc; unsigned int v=0; // printf(\"original ECC : %02x %02x %02x %02x \", (spare[0xC] & 0xC0), spare[0xD],spare[0xE],spare[0xF]); for (i = 0; i < 0x1066; i++) { if (!(i & 31)) { if (i == 0x1000) data = (unsigned long*)spare; v = ~*data++; // byte order: LE } val ^= v & 1; v>>=1; if (val & 1) val ^= 0x6954559; val >>= 1; } val = ~val; edc[0] = (val << 6) & 0xC0; edc[1] = (val >> 2) & 0xFF; edc[2] = (val >> 10) & 0xFF; edc[3] = (val >> 18) & 0xFF; if(((spare[0xC] & 0xC0) != edc[0])||(spare[0xD] != edc[1])||(spare[0xE] != edc[2])||(spare[0xF] != edc[3])) return ECC_FAILED; return ECC_CORRECT; }","title":"Error Detection/Correction Code"},{"location":"NAND_File_System/#nand-format","text":"The first byte of a NAND image should always be 0xFF. If it isn't 0xFF this isn't a valid image. Another thing which should be checked is the copyright header, which is located at 0x10 in the NAND. This string should be read in two parts (skipping the year out, as it changes depending when that xbox was made) and then checked against a control string (although some valid images have this string changed to zeropair). At 0x2 in the NAND the version of the flash is stored (2bytes). Further on at 0x8 the offset of the CB is stored, followed by the CF1 offset (4bytes each). At 0x6C the offset to the keyvault is located (4bytes). Up from that at 0x78 the length of the SMC and offset to the SMC are stored (4bytes each).","title":"NAND Format"},{"location":"NAND_File_System/#system-management-controller","text":"finish later","title":"System Management Controller"},{"location":"NAND_File_System/#xell-image-layout","text":"The whole XeLL Image is pretty small with 1,3 MB compared to an original Xbox360 NAND-Image which is normally 16 MB or 64 MB. 0x00000000..0x000001ff (0x00000200 bytes) Header 0x00000200..0x000003ff (0x00000200 bytes) Exploit 0x00000400..0x00000fff (0x00000c00 bytes) Padding 0x00001000..0x00003fff (0x00003000 bytes) SMC 0x00004000..0x00007fff (0x00004000 bytes) Keyvault 0x00008000..0x000117ff (0x00009800 bytes) CB 1921 0x00011800..0x00016ebf (0x000056c0 bytes) CD 1921 0x00016ec0..0x0006cf2f (0x00056070 bytes) CE 1888 0x0006cf30..0x0006ffff (0x000030d0 bytes) Padding 0x00070000..0x000744bf (0x000044c0 bytes) CF 4532 0x000744c0..0x000a33ff (0x0002ef40 bytes) CG 4532 0x000a3400..0x000bffff (0x0001cc00 bytes) Padding 0x000c0000..0x000fffff (0x00040000 bytes) Xell (backup) 0x00100000..0x0013ffff (0x00040000 bytes) Xell (main) The (hacked) SMC Code is usually seen as Header + Exploit + Padding the actual SMC, so 0x0000 - 0x3FFF. The Keyvault is the unique \"System Information\" which holds stuff like DVDKey, Console Region, Console Serial and other things. Whole keyvault is crypted with CPUKey. After that exploitable CB (2BL) and CD (4BL), matching the console revision, follows. After padding CB/CD theres CE (Base-Kernel 1888) followed by exploitable Patchslots CF/CG (4532 or 4548) and again some padding. At the end of the Image theres a Backup-XeLL, which gets executed if the original XeLL fails (Bad Update maybe) followed by the original XeLL. Category:Xbox360 System Software","title":"XeLL Image Layout"},{"location":"NAND_Reading/","text":"NAND reading This tutorial explains how to read the Xbox360's NAND /Flash via a PC's parallel/\"printer\" port in as clean and easy as possible a way. The same method is used to dump all models of the Xbox 360 ( Xenon , Zephyr , Falcon , Opus , Jasper ). Please keep quick & dirty setups and speculation out or, in case some guesswork is really needed, flag them, so this article and the whole wiki can develop as trustworthy sources. There are guides to dump via USB, but compared to this it's quite expensive and easily found with a search. Maybe someone will add one later on. If you're facing any problems, feel free to ask in #free60 on OFTC. :) Moreover thanks to tmbinc, Tiros, Redline and all else involved (feel free to add their names) for their great work! :) Requirements First of all, you'll need soldering skills\u2014if you've never used a soldering iron before, you should train on a less expensive object. This skill level is similar to adding a modchip to a console. You'll need the following: Prerequisites: :*LPT (parallel) port (preferably supporting SPP) Components: :*1 \u00d7 diode BAT41 - There are several diodes you can use. People on xboxhacker.net had the best experiences with BAT41, others used N4148. I (kote) used PH4148. :*5 \u00d7 100\u2013120 \u03a9 resistors - not a must-have, but it'll protect your box :*LPT cable - Hollow connector housings will make your life easier. Alternatively, use a bare DB25 male connector and wire. Tools: :*Multimeter - (Voltmeter/Continuity) :*Soldering Iron :*A lot of patience and spare time ;) - A third hand will make your life easier, too Software :* 32-bit OS/PC - The necessary PortIO(?-Guessing) driver is available for 32-bit systems only. There is a 64-bit port, however NandPro2 compatibility is unknown (22/08/2009). Since many 64-bit systems don't have a parallel port, this shouldn't affect many people. :* 64-bit Update: Go here. Download 'Binaries only - x86 & x64 DLLs and libs'. Extract inpout32.dll from Win32 folder to nandpro folder. Rename inpout32.dll to DLPortIO.dll (credit) :*NandPro - NandPro (by User:Tiros Tiros on xboxhacker.net - for reading out the NAND image.) seems to work with Windows Vista 32-bit and Windows 7 32-bit. Windows XP Compatibility Mode or running with administrator rights may be necessary. XP or earlier is preferred. :*Verifying NAND Dumps: ::*File comparison Utility - MD5SUM, SHA1SUM, (Total Commander) ::*360 Flash Tool - (there are different versions! The latest is V0.88a CD FIXED [22/08/2009]) ::*NAND Compare and Reconstruction Tool - (compare 2 nand images or reconstruct image from 3 bad reads) Photos 1 2 3 Steps: Preparing the cable First of all, there are different kinds of LPT cables out there. If you got one with at least one male DB25 connector, you will be fine. There are also cables with two DB25 connectors and possibilites to do it without any DB25 connector. However, this tutorial is supposed to be as universal as possible, so we will behave like there are only cables with one connector. Well, whatever is on the other end of your cable, cut it off. So you will get a cable with a DB25 connector at one side and loose wires on the other side. Now you need to trace the wires in the cable. If you've got a cable with openable plug housings, you're in luck: just open the housings and compare single wires with those on the loose end. Otherwise it's time for your continuity tester. You will need to know which wire goes to which pin at the end. Write down the colour of the wire attached to each pin. Since there are only seven needed wires, you don't have to trace every wire. The following pins need to be connected: 1, 2, 11, 14, 16, 17, 18. In case a pin isn't connected, just resolder a wire from an unneeded pin (e.g., 15) to the needed one (e.g., 14). I (some11) bought a LPT Cable (Nikkai LPT Parallel Printer Cable [L79BT]) from Maplins. http://i45.tinypic.com/29lhggk.jpg Here is the wire color map output: Pin Color (Main/Second) Pin Color (Main/Second) Pin 1 Yellow Pin 13 Black Pin 2 Pink Black Pin 14 White Pin 3 Pink Pin 15 Grey Black Pin 4 Orange Black Pin 16 Grey Pin 5 Orange White Pin 17 Purple White Pin 6 Orange Pin 18 Purple Pin 7 Red Black Pin 19 Blue White Pin 8 Red White Pin 20 Blue Pin 9 Red Pin 21 Green (Different) Pin 10 Brown White Pin 22 Green Black Pin 11 Brown Pin 23 Green White Pin 12 Black White Pin 24 Green Pin 25 Yellow Black After you've done that, you can cut the unneeded wires at the loose end so they won't bother you while soldering. Strip a small amount of insulation (5 mm should be plenty) from the end of each of the other wires, and twist the loose strands inside together. Tin each wire, so that you get nice and sweet clean wires. Opening the Xbox 360 http://www.anandtech.com/printarticle.aspx?i=2610 Preparing and Soldering Once you have a clear view of the board, it's time to locate the solder pads of J1D2 (red) and J2B1 (blue). http://www.abload.de/img/locationnoqa.jpg You will have to establish the following connections: LPT(DB25) Component Xbox 360 DB25.1 resistor J1D2.2 DB25.2 resistor J1D2.3 DB25.11 diode J1D2.4 DB25.14 resistor J1D2.1 DB25.16 resistor J2B1.6 DB25.17 resistor J2B1.5 DB25.18 nothing J1D2.6, J2B1.12, or a screwhole http://www.abload.de/img/connectiontableaolh.jpg This is how you count on a board: http://www.abload.de/img/howtocount5y02.jpg The square is always 1, in this case J2B1.1. Also, notice the white dot near pin 1 and the labels near pins 2, 12, and 13. \"Component\" means that you will have to add the resistor or diode between those two points. I suggest that you first solder the component on the board and after that the wire to the component. The diode's black ring has to be in the direction of the Xbox board. By \"screwhole\", we mean a screwhole. (The ground (or \"earth\") connection we're using is also present on J1D2.6 and J2B1.12, but those are difficult to solder.) Solder the wire from DB25.18 to one of those big reddish rings (where the long screws go through the DVD-ROM drive legs), and fix it with insulation tape (NOT DUCT TAPE! Otherwise you will damage your Xbox). '''It is important that you solder the diode directly to the board. It won't work if it's in the plug housing! ''' LPT (parallel port) connections are the same for Xenon, Zephyr, Falcon, Opus, and Jasper (but JTAG connections are different between Xenon motherboards and the other ones). New Xenon exploit diagram: http://i.imgur.com/Fdjmi.png Diagram (including LPT & JTAG connections): https://web.archive.org/web/20111202124409/http://img710.imageshack.us/img710/31/spidiagramsandungas.png Another diagram (including LPT & JTAG connections): https://web.archive.org/web/20111202142124/http://img12.imageshack.us/img12/4983/xenondiagram.jpg Slim diagram: http://imageshack.us/photo/my-images/32/lptslim.png/ Checklist Is every wire connected to the correct pin? Are there any short circuits or doubly connected wires? (Watch out for sprawling solder!) Have you taken everything out of the box that doesn't belong in there? When you've checked that, plug the parallel cable into your turned-off computer, the power supply into your Xbox, and the power cable into the power outlet. Setting up your PC Turn on your PC. It's possible that your Xbox will turn on, too. Don't worry, just leave it turned on. As long as it doesn't start to smoke, smell, or anything else weird it will be fine. Later on, it should turn off the fans on its own, but the LEDs will remain blinking. If it doesn't turn on: don't worry, it doesn't have to be turned on while reading the NAND. Go to the BIOS settings and search for LPT mode settings. Tiros recommends SPP/Normal mode in his help file (Nandpro.txt), but the mode doesn't actually appear to matter. If you're having trouble in the next step, give a different mode a try. After you have done that, save settings and leave BIOS. Boot up Windows. Now the time has come to unpack NandPro2. In the archive you'll find port95nt.exe (driver) and some other files (e.g. NandPro.exe). Install the driver. If you're using Vista or higher, you might have to turn on XP Compatibility Mode, as already mentioned. To install it, just double-click on it and walk through the setup. There shouldn't be any error messages. Then: reboot. Reading/Dumping the nand twice and drinking coffee. Prepare the coffee. ;) Windows should have booted up now. Open up Windows Command Prompt (press Windows Key + R to open up Run. Type cmd and press Enter). Navigate to NandPro's installation directory by using common commands (cd, dir, and the TAB key for auto-completion). Then type nandpro.exe lpt: -r16 nand1.bin and press enter. If everything's fine, it should output this: Testing LPT device address:0378 // address can differ Using LPT device at address:0378 // address can differ FlashConfig:01198010 // must be the same (except Jasper boards, see next block) Starting Block:0x000000 // Starting and ending should be as shown here if you want Ending Block:0x0003FF // to read the whole flash [you want! :p] If you get FlashConfig: 0012000 try soldering the diode directly to the motherboard instead on having it on the conector side. It worked for iD4rK, and others. The Flashconfig is dependant on the mainboard version, other valid values are: FlashConfig - System Types 01198010 - Xenon, Zephyr, Opus, Falcon 00023010 - Jasper 16mb 008A3020 - Jasper 256mb 00AA3020 - Jasper 512mb Press any key to continue. It should start to count up addresses. If it starts to output stuff like \"Error 0 .. blah blah\" something's wrong. Recheck wiring, change LPT mode, or try a different computer. It is possible that there are one or two bad blocks on your NAND (error 25x), so don't worry if you get that error once or twice. Well, the reading (dumping) process will take about half an hour. So head to your coffee machine. ;) Unfortunately, we will need at least two dumps to check whether there are really no failures in your dump. So once NandPro has finished dumping, press the up arrow key (or retype the command), CHANGE THE FILENAME TO NAND2.BIN, press Enter, and dump it a second time. Get another coffee. Or turn on the TV. Maybe you have got a girlfriend? When NandPro2 has finished the second dump without errors close the command-line. Checking for errors First, open up both files with 360 Flash Tool. If it looks like in the picture beneath this, everything should be fine. If an error message \"Couldn't open file\" pops up, something went wrong. :* http://www.abload.de/img/360flashtool4ld2.jpg Second, start up Total Commander. Choose File -> Compare by content. A new window will open. Select both files and click on compare. If they are identical: congratulations! You are done with this. =) If not, search for errors in wiring etc. or try a different PC. :* http://www.abload.de/img/totalcommander6zw7.jpg While 360 Flash Tool will show you the content of the NAND, it's not a conclusive check whether the integrity is good: it's possible to get a \"thumbs up\" from the utility even if you have corrupted (and more importantly, vital) blocks. A much better check is to run the resulted image through Degraded v1.1, which will highlight any errors. A NAND with bad blocks usually looks like this: :* https://web.archive.org/web/20111202132655/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Bad_Block_DUMP.jpg Note in this example that the bad block information has been located elsewhere, so you *should* be okay. Even so, it's advisable to run a second dump through the utility and see whether this has a bad block (and relocated) in the exact same address. If this is the case, you should be good to go. A good NAND dump might look like this: :* https://web.archive.org/web/20111202140910/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Degraded_1.jpg If you get this, great :) Your NAND dump is about as good as it's gonna be! NAND Compare and Reconstruction Tool A nice tool to check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. - compare 2 nand images better than simply using md5 as it tells you which blocks are mismatched, which allows you to reread only those that are in error rather than the entire chip (speeding up the process) one use of this is when verifying a write by reading back the nand and comparing it against the original you wrote, if you get a bad block just reread that individual block, patch it into the full read and compare again (files are reread each time you click compare, no need to reselect the same files in the gui) - reconstruct image from 3 bad reads assumes that read errors don't occur in same place each time, which is true for some read errors (e.g. lpt timing problems), if there is a good reason why you can't read something then this may not be true this tool cannot recreate a nand out of nothing, if you give it 3 files full of zeros you'll get a recreated nand full of zeros, always look at a dump to make sure it looks correct (e.g. has a microsoft copyright at the top, once you've reconstructed a nand open it in 360 flash tool and make sure it reads ok there) the tool works by comparing blocks between the 3 files, any block found matching in 2 (or 3) of the files will be considered good, you will be warned if not all blocks can be recovered, in which case you'll need to get more reads or look for a good reason why your reads are so bad Official Site: http://www.xboxhacker.net/index.php?topic=13208.0 Download: http://dwl.xbox-scene.com/xbox360pc/nandtools/NandCompare-v1.3.rar (images taken from http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/pag3.htm )","title":"NAND reading"},{"location":"NAND_Reading/#nand-reading","text":"This tutorial explains how to read the Xbox360's NAND /Flash via a PC's parallel/\"printer\" port in as clean and easy as possible a way. The same method is used to dump all models of the Xbox 360 ( Xenon , Zephyr , Falcon , Opus , Jasper ). Please keep quick & dirty setups and speculation out or, in case some guesswork is really needed, flag them, so this article and the whole wiki can develop as trustworthy sources. There are guides to dump via USB, but compared to this it's quite expensive and easily found with a search. Maybe someone will add one later on. If you're facing any problems, feel free to ask in #free60 on OFTC. :) Moreover thanks to tmbinc, Tiros, Redline and all else involved (feel free to add their names) for their great work! :)","title":"NAND reading"},{"location":"NAND_Reading/#requirements","text":"First of all, you'll need soldering skills\u2014if you've never used a soldering iron before, you should train on a less expensive object. This skill level is similar to adding a modchip to a console. You'll need the following: Prerequisites: :*LPT (parallel) port (preferably supporting SPP) Components: :*1 \u00d7 diode BAT41 - There are several diodes you can use. People on xboxhacker.net had the best experiences with BAT41, others used N4148. I (kote) used PH4148. :*5 \u00d7 100\u2013120 \u03a9 resistors - not a must-have, but it'll protect your box :*LPT cable - Hollow connector housings will make your life easier. Alternatively, use a bare DB25 male connector and wire. Tools: :*Multimeter - (Voltmeter/Continuity) :*Soldering Iron :*A lot of patience and spare time ;) - A third hand will make your life easier, too Software :* 32-bit OS/PC - The necessary PortIO(?-Guessing) driver is available for 32-bit systems only. There is a 64-bit port, however NandPro2 compatibility is unknown (22/08/2009). Since many 64-bit systems don't have a parallel port, this shouldn't affect many people. :* 64-bit Update: Go here. Download 'Binaries only - x86 & x64 DLLs and libs'. Extract inpout32.dll from Win32 folder to nandpro folder. Rename inpout32.dll to DLPortIO.dll (credit) :*NandPro - NandPro (by User:Tiros Tiros on xboxhacker.net - for reading out the NAND image.) seems to work with Windows Vista 32-bit and Windows 7 32-bit. Windows XP Compatibility Mode or running with administrator rights may be necessary. XP or earlier is preferred. :*Verifying NAND Dumps: ::*File comparison Utility - MD5SUM, SHA1SUM, (Total Commander) ::*360 Flash Tool - (there are different versions! The latest is V0.88a CD FIXED [22/08/2009]) ::*NAND Compare and Reconstruction Tool - (compare 2 nand images or reconstruct image from 3 bad reads)","title":"Requirements"},{"location":"NAND_Reading/#photos","text":"1 2 3","title":"Photos"},{"location":"NAND_Reading/#steps","text":"","title":"Steps:"},{"location":"NAND_Reading/#preparing-the-cable","text":"First of all, there are different kinds of LPT cables out there. If you got one with at least one male DB25 connector, you will be fine. There are also cables with two DB25 connectors and possibilites to do it without any DB25 connector. However, this tutorial is supposed to be as universal as possible, so we will behave like there are only cables with one connector. Well, whatever is on the other end of your cable, cut it off. So you will get a cable with a DB25 connector at one side and loose wires on the other side. Now you need to trace the wires in the cable. If you've got a cable with openable plug housings, you're in luck: just open the housings and compare single wires with those on the loose end. Otherwise it's time for your continuity tester. You will need to know which wire goes to which pin at the end. Write down the colour of the wire attached to each pin. Since there are only seven needed wires, you don't have to trace every wire. The following pins need to be connected: 1, 2, 11, 14, 16, 17, 18. In case a pin isn't connected, just resolder a wire from an unneeded pin (e.g., 15) to the needed one (e.g., 14). I (some11) bought a LPT Cable (Nikkai LPT Parallel Printer Cable [L79BT]) from Maplins. http://i45.tinypic.com/29lhggk.jpg Here is the wire color map output: Pin Color (Main/Second) Pin Color (Main/Second) Pin 1 Yellow Pin 13 Black Pin 2 Pink Black Pin 14 White Pin 3 Pink Pin 15 Grey Black Pin 4 Orange Black Pin 16 Grey Pin 5 Orange White Pin 17 Purple White Pin 6 Orange Pin 18 Purple Pin 7 Red Black Pin 19 Blue White Pin 8 Red White Pin 20 Blue Pin 9 Red Pin 21 Green (Different) Pin 10 Brown White Pin 22 Green Black Pin 11 Brown Pin 23 Green White Pin 12 Black White Pin 24 Green Pin 25 Yellow Black After you've done that, you can cut the unneeded wires at the loose end so they won't bother you while soldering. Strip a small amount of insulation (5 mm should be plenty) from the end of each of the other wires, and twist the loose strands inside together. Tin each wire, so that you get nice and sweet clean wires.","title":"Preparing the cable"},{"location":"NAND_Reading/#opening-the-xbox-360","text":"http://www.anandtech.com/printarticle.aspx?i=2610","title":"Opening the Xbox 360"},{"location":"NAND_Reading/#preparing-and-soldering","text":"Once you have a clear view of the board, it's time to locate the solder pads of J1D2 (red) and J2B1 (blue). http://www.abload.de/img/locationnoqa.jpg You will have to establish the following connections: LPT(DB25) Component Xbox 360 DB25.1 resistor J1D2.2 DB25.2 resistor J1D2.3 DB25.11 diode J1D2.4 DB25.14 resistor J1D2.1 DB25.16 resistor J2B1.6 DB25.17 resistor J2B1.5 DB25.18 nothing J1D2.6, J2B1.12, or a screwhole http://www.abload.de/img/connectiontableaolh.jpg This is how you count on a board: http://www.abload.de/img/howtocount5y02.jpg The square is always 1, in this case J2B1.1. Also, notice the white dot near pin 1 and the labels near pins 2, 12, and 13. \"Component\" means that you will have to add the resistor or diode between those two points. I suggest that you first solder the component on the board and after that the wire to the component. The diode's black ring has to be in the direction of the Xbox board. By \"screwhole\", we mean a screwhole. (The ground (or \"earth\") connection we're using is also present on J1D2.6 and J2B1.12, but those are difficult to solder.) Solder the wire from DB25.18 to one of those big reddish rings (where the long screws go through the DVD-ROM drive legs), and fix it with insulation tape (NOT DUCT TAPE! Otherwise you will damage your Xbox). '''It is important that you solder the diode directly to the board. It won't work if it's in the plug housing! ''' LPT (parallel port) connections are the same for Xenon, Zephyr, Falcon, Opus, and Jasper (but JTAG connections are different between Xenon motherboards and the other ones). New Xenon exploit diagram: http://i.imgur.com/Fdjmi.png Diagram (including LPT & JTAG connections): https://web.archive.org/web/20111202124409/http://img710.imageshack.us/img710/31/spidiagramsandungas.png Another diagram (including LPT & JTAG connections): https://web.archive.org/web/20111202142124/http://img12.imageshack.us/img12/4983/xenondiagram.jpg Slim diagram: http://imageshack.us/photo/my-images/32/lptslim.png/","title":"Preparing and Soldering"},{"location":"NAND_Reading/#checklist","text":"Is every wire connected to the correct pin? Are there any short circuits or doubly connected wires? (Watch out for sprawling solder!) Have you taken everything out of the box that doesn't belong in there? When you've checked that, plug the parallel cable into your turned-off computer, the power supply into your Xbox, and the power cable into the power outlet.","title":"Checklist"},{"location":"NAND_Reading/#setting-up-your-pc","text":"Turn on your PC. It's possible that your Xbox will turn on, too. Don't worry, just leave it turned on. As long as it doesn't start to smoke, smell, or anything else weird it will be fine. Later on, it should turn off the fans on its own, but the LEDs will remain blinking. If it doesn't turn on: don't worry, it doesn't have to be turned on while reading the NAND. Go to the BIOS settings and search for LPT mode settings. Tiros recommends SPP/Normal mode in his help file (Nandpro.txt), but the mode doesn't actually appear to matter. If you're having trouble in the next step, give a different mode a try. After you have done that, save settings and leave BIOS. Boot up Windows. Now the time has come to unpack NandPro2. In the archive you'll find port95nt.exe (driver) and some other files (e.g. NandPro.exe). Install the driver. If you're using Vista or higher, you might have to turn on XP Compatibility Mode, as already mentioned. To install it, just double-click on it and walk through the setup. There shouldn't be any error messages. Then: reboot.","title":"Setting up your PC"},{"location":"NAND_Reading/#readingdumping-the-nand-twice-and-drinking-coffee","text":"Prepare the coffee. ;) Windows should have booted up now. Open up Windows Command Prompt (press Windows Key + R to open up Run. Type cmd and press Enter). Navigate to NandPro's installation directory by using common commands (cd, dir, and the TAB key for auto-completion). Then type nandpro.exe lpt: -r16 nand1.bin and press enter. If everything's fine, it should output this: Testing LPT device address:0378 // address can differ Using LPT device at address:0378 // address can differ FlashConfig:01198010 // must be the same (except Jasper boards, see next block) Starting Block:0x000000 // Starting and ending should be as shown here if you want Ending Block:0x0003FF // to read the whole flash [you want! :p] If you get FlashConfig: 0012000 try soldering the diode directly to the motherboard instead on having it on the conector side. It worked for iD4rK, and others. The Flashconfig is dependant on the mainboard version, other valid values are: FlashConfig - System Types 01198010 - Xenon, Zephyr, Opus, Falcon 00023010 - Jasper 16mb 008A3020 - Jasper 256mb 00AA3020 - Jasper 512mb Press any key to continue. It should start to count up addresses. If it starts to output stuff like \"Error 0 .. blah blah\" something's wrong. Recheck wiring, change LPT mode, or try a different computer. It is possible that there are one or two bad blocks on your NAND (error 25x), so don't worry if you get that error once or twice. Well, the reading (dumping) process will take about half an hour. So head to your coffee machine. ;) Unfortunately, we will need at least two dumps to check whether there are really no failures in your dump. So once NandPro has finished dumping, press the up arrow key (or retype the command), CHANGE THE FILENAME TO NAND2.BIN, press Enter, and dump it a second time. Get another coffee. Or turn on the TV. Maybe you have got a girlfriend? When NandPro2 has finished the second dump without errors close the command-line.","title":"Reading/Dumping the nand twice and drinking coffee."},{"location":"NAND_Reading/#checking-for-errors","text":"First, open up both files with 360 Flash Tool. If it looks like in the picture beneath this, everything should be fine. If an error message \"Couldn't open file\" pops up, something went wrong. :* http://www.abload.de/img/360flashtool4ld2.jpg Second, start up Total Commander. Choose File -> Compare by content. A new window will open. Select both files and click on compare. If they are identical: congratulations! You are done with this. =) If not, search for errors in wiring etc. or try a different PC. :* http://www.abload.de/img/totalcommander6zw7.jpg While 360 Flash Tool will show you the content of the NAND, it's not a conclusive check whether the integrity is good: it's possible to get a \"thumbs up\" from the utility even if you have corrupted (and more importantly, vital) blocks. A much better check is to run the resulted image through Degraded v1.1, which will highlight any errors. A NAND with bad blocks usually looks like this: :* https://web.archive.org/web/20111202132655/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Bad_Block_DUMP.jpg Note in this example that the bad block information has been located elsewhere, so you *should* be okay. Even so, it's advisable to run a second dump through the utility and see whether this has a bad block (and relocated) in the exact same address. If this is the case, you should be good to go. A good NAND dump might look like this: :* https://web.archive.org/web/20111202140910/http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/File/Degraded_1.jpg If you get this, great :) Your NAND dump is about as good as it's gonna be! NAND Compare and Reconstruction Tool A nice tool to check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. - compare 2 nand images better than simply using md5 as it tells you which blocks are mismatched, which allows you to reread only those that are in error rather than the entire chip (speeding up the process) one use of this is when verifying a write by reading back the nand and comparing it against the original you wrote, if you get a bad block just reread that individual block, patch it into the full read and compare again (files are reread each time you click compare, no need to reselect the same files in the gui) - reconstruct image from 3 bad reads assumes that read errors don't occur in same place each time, which is true for some read errors (e.g. lpt timing problems), if there is a good reason why you can't read something then this may not be true this tool cannot recreate a nand out of nothing, if you give it 3 files full of zeros you'll get a recreated nand full of zeros, always look at a dump to make sure it looks correct (e.g. has a microsoft copyright at the top, once you've reconstructed a nand open it in 360 flash tool and make sure it reads ok there) the tool works by comparing blocks between the 3 files, any block found matching in 2 (or 3) of the files will be considered good, you will be warned if not all blocks can be recovered, in which case you'll need to get more reads or look for a good reason why your reads are so bad Official Site: http://www.xboxhacker.net/index.php?topic=13208.0 Download: http://dwl.xbox-scene.com/xbox360pc/nandtools/NandCompare-v1.3.rar (images taken from http://www.infectus.biz/INFECTUS-BOOK/Tutorial_Eng/Xbox360/Timing_Attack_Infectus/pag3.htm )","title":"Checking for errors"},{"location":"NFS_Root/","text":"NFS Root This tutorial assumes that you already have XeLL and Xenon Toolchain . Install and Setup a NFS Server To do this you may have to edit your kernel on your host machine to enable nfs. For Gentoo : Instructions . For Debian/Ubuntu : Instructions Your /etc/exports should look like this: /mnt/nfsroot 192.168.1.*(rw,no_root_squash,no_subtree_check,async) Change the IP scheme and path to fit your configuration. Make the /mnt/nfsroot directory and copy the image.squashfs (from a LiveCD) into it: mkdir /mnt/nfsroot cp image.squashfs /mnt/nfsroot/ Then extract the squashfs as root by doing: unsquashfs image.squashfs Now copy everything from the squashfs-root folder to /mnt/nfsroot by typing: cd /mnt/nfsroot/squashfs-root && cp * -vaR /mnt/nfsroot Alternative: Debootstrap a fresh powerpc system (debian/ubuntu) and use it as NFSroot. Let the nfs-share re-export with: exportfs -ra Compile the kernel that you want to use Get the kernel sources You can get them from kernel.org 2.6.38.8 at time of writing (in the future this might change) Get the patches and the kernel config You can get them from here . NOTE: At the time of writing v0.11.1 was the latest. Make sure that your kernel config and your patch are the same version. Extract the kernel With the following command: tar -xvjf linux-2.6.38.8.tar.bz2 Patch the kernel With the following commands: cd linux-2.6.38.8 # assumes that the patch is in the directory above the kernel folder that you just changed into patch -p1 --dry-run <../patch-2.6.38.8-xbox0.11.1.diff # if the dry-run didn't show any errors do the following: patch -p1 <../patch-2.6.38.8-xbox0.11.1.diff Copy and Edit the kernel config file Copy the kernel config to the extracted linux-kernel folder: # The '.' in front of the filename is there on purpose! cp /path/to/xenon-config /path/to/extracted/linux-2.6.38.8/.config Look for a line similar to this: CONFIG_CMDLINE=\"root=/dev/nfs video=xenonfb nfsroot=192.168.1.100:/mnt/nfsroot rw ip=dhcp panic=60\" Edit the NFSroot to be your IP address and adjust the path correctly. Alternative: Use kboot.conf to pass a custom CMDLINE to the Server. If you want to do this you set: CONFIG_CMDLINE_BOOL=n CONFIG_CMDLINE=n Build the kernel Do the following: make ARCH=powerpc CROSS_COMPILE=xenon- menuconfig Load up your config file that you just edited and then exit and run the following command: make ARCH=powerpc CROSS_COMPILE=xenon- all You might get an error if so you might need to edit arch/powerpc/kernel/pci_64.c line 149 and change the lh to llh both occurrences. Rerun the last command and you should have a kernel. It will be in arch/powerpc/boot/zImage.xenon Configure Xell to boot from your computer via tftp To do this you need to recompile Xell. I assume that you already have a toolchain, I used the one from libxenon. You will need to edit the Xell source file network.c changing the default IP address to your IP address. Then compile Xell. Setup tftp For Gentoo and 'atftpd' just type: emerge -v atftp Then edit the atftp config file: nano /etc/conf.d/atftp I changed mine to look like this: TFTPD_ROOT=\"/tftpboot\" just edit this line and leave the rest the way it is as it is already correct. For Debian/Ubuntu use the following: Instructions (Sections: Set up DHCP server and Setup a TFTP server When done with that make the matching tftp directory (if it doesn't exist already) and put your linux-kernel into it, rename it xenon . NOTE : XeLL assumes a path like /tftpboot/xenon in its standard configuration. If your tftp-daemon has a path like /var/lib/tftpboot/ set up you need to make a subdir tftpboot in there. Final path would look like: /var/lib/tftpboot/tftpboot/ Now if everything worked correctly you should be able to boot your 360 via NFS. NOTE: It's recommended that the TFTP-Server is the one who serves the DHCP Responses and no other DHCP Server is in your network so XeLL can find the TFTP Server Adress. NOTE(2): it is also possible to do this without a (linux) dhcpd server setup, using a router if you have a router that supports it (ddwrt, cisco, possibly some residential grade routers) by forwarding all tftp requests to your tftp server. for ddwrt: enable DNSmasq Go to your Web-Interface and log in Go to Setup->Basic Setup Make sure that DHCP Type = DHCP Server DHCP Server = Enable Use DNSMasq for DHCP = Checked Use DNSMasq for DNS = Checked Go to Administration->Services LAN Domain = DNSMasq = Enabled Local DNS = Enabled in DNSmasq additional options: domain=lan-name-here local=/lan-name-here/ expand-hosts dhcp-option=66,\"tftp-server-address-here\" Or edit /tmp/dnsmasq.conf with the correct settings (the above settings) adding cisco conf next","title":"NFS Root"},{"location":"NFS_Root/#nfs-root","text":"This tutorial assumes that you already have XeLL and Xenon Toolchain .","title":"NFS Root"},{"location":"NFS_Root/#install-and-setup-a-nfs-server","text":"To do this you may have to edit your kernel on your host machine to enable nfs. For Gentoo : Instructions . For Debian/Ubuntu : Instructions Your /etc/exports should look like this: /mnt/nfsroot 192.168.1.*(rw,no_root_squash,no_subtree_check,async) Change the IP scheme and path to fit your configuration. Make the /mnt/nfsroot directory and copy the image.squashfs (from a LiveCD) into it: mkdir /mnt/nfsroot cp image.squashfs /mnt/nfsroot/ Then extract the squashfs as root by doing: unsquashfs image.squashfs Now copy everything from the squashfs-root folder to /mnt/nfsroot by typing: cd /mnt/nfsroot/squashfs-root && cp * -vaR /mnt/nfsroot Alternative: Debootstrap a fresh powerpc system (debian/ubuntu) and use it as NFSroot. Let the nfs-share re-export with: exportfs -ra","title":"Install and Setup a NFS Server"},{"location":"NFS_Root/#compile-the-kernel-that-you-want-to-use","text":"","title":"Compile the kernel that you want to use"},{"location":"NFS_Root/#get-the-kernel-sources","text":"You can get them from kernel.org 2.6.38.8 at time of writing (in the future this might change)","title":"Get the kernel sources"},{"location":"NFS_Root/#get-the-patches-and-the-kernel-config","text":"You can get them from here . NOTE: At the time of writing v0.11.1 was the latest. Make sure that your kernel config and your patch are the same version.","title":"Get the patches and the kernel config"},{"location":"NFS_Root/#extract-the-kernel","text":"With the following command: tar -xvjf linux-2.6.38.8.tar.bz2","title":"Extract the kernel"},{"location":"NFS_Root/#patch-the-kernel","text":"With the following commands: cd linux-2.6.38.8 # assumes that the patch is in the directory above the kernel folder that you just changed into patch -p1 --dry-run <../patch-2.6.38.8-xbox0.11.1.diff # if the dry-run didn't show any errors do the following: patch -p1 <../patch-2.6.38.8-xbox0.11.1.diff","title":"Patch the kernel"},{"location":"NFS_Root/#copy-and-edit-the-kernel-config-file","text":"Copy the kernel config to the extracted linux-kernel folder: # The '.' in front of the filename is there on purpose! cp /path/to/xenon-config /path/to/extracted/linux-2.6.38.8/.config Look for a line similar to this: CONFIG_CMDLINE=\"root=/dev/nfs video=xenonfb nfsroot=192.168.1.100:/mnt/nfsroot rw ip=dhcp panic=60\" Edit the NFSroot to be your IP address and adjust the path correctly. Alternative: Use kboot.conf to pass a custom CMDLINE to the Server. If you want to do this you set: CONFIG_CMDLINE_BOOL=n CONFIG_CMDLINE=n","title":"Copy and Edit the kernel config file"},{"location":"NFS_Root/#build-the-kernel","text":"Do the following: make ARCH=powerpc CROSS_COMPILE=xenon- menuconfig Load up your config file that you just edited and then exit and run the following command: make ARCH=powerpc CROSS_COMPILE=xenon- all You might get an error if so you might need to edit arch/powerpc/kernel/pci_64.c line 149 and change the lh to llh both occurrences. Rerun the last command and you should have a kernel. It will be in arch/powerpc/boot/zImage.xenon","title":"Build the kernel"},{"location":"NFS_Root/#configure-xell-to-boot-from-your-computer-via-tftp","text":"To do this you need to recompile Xell. I assume that you already have a toolchain, I used the one from libxenon. You will need to edit the Xell source file network.c changing the default IP address to your IP address. Then compile Xell.","title":"Configure Xell to boot from your computer via tftp"},{"location":"NFS_Root/#setup-tftp","text":"For Gentoo and 'atftpd' just type: emerge -v atftp Then edit the atftp config file: nano /etc/conf.d/atftp I changed mine to look like this: TFTPD_ROOT=\"/tftpboot\" just edit this line and leave the rest the way it is as it is already correct. For Debian/Ubuntu use the following: Instructions (Sections: Set up DHCP server and Setup a TFTP server When done with that make the matching tftp directory (if it doesn't exist already) and put your linux-kernel into it, rename it xenon . NOTE : XeLL assumes a path like /tftpboot/xenon in its standard configuration. If your tftp-daemon has a path like /var/lib/tftpboot/ set up you need to make a subdir tftpboot in there. Final path would look like: /var/lib/tftpboot/tftpboot/ Now if everything worked correctly you should be able to boot your 360 via NFS. NOTE: It's recommended that the TFTP-Server is the one who serves the DHCP Responses and no other DHCP Server is in your network so XeLL can find the TFTP Server Adress. NOTE(2): it is also possible to do this without a (linux) dhcpd server setup, using a router if you have a router that supports it (ddwrt, cisco, possibly some residential grade routers) by forwarding all tftp requests to your tftp server. for ddwrt: enable DNSmasq Go to your Web-Interface and log in Go to Setup->Basic Setup Make sure that DHCP Type = DHCP Server DHCP Server = Enable Use DNSMasq for DHCP = Checked Use DNSMasq for DNS = Checked Go to Administration->Services LAN Domain = DNSMasq = Enabled Local DNS = Enabled in DNSmasq additional options: domain=lan-name-here local=/lan-name-here/ expand-hosts dhcp-option=66,\"tftp-server-address-here\" Or edit /tmp/dnsmasq.conf with the correct settings (the above settings) adding cisco conf next","title":"Setup tftp"},{"location":"NandCompare/","text":"NANDCompare NFO nand compare (v1.4): -------------------- i made 6 reads of my nand with no matches (one of them was good but of course i didn't know that at the time), but diffing them i could see that the differences where spread all throughout the file, so i wrote this tool to reconstruct it then i also discovered the usefulness of the compare function in verification of the write, so hopefully this tool will be of use to other people please send feedback, bugs, etc. to rab (richardaburton@gmail.com) or post in the thread on xbox-scene or xboxhacker the tool has two functions: --------------------------- - compare 2 nand images better than simply using md5 as it tells you which blocks are mismatched, which allows you to reread only those that are in error rather than the entire chip (speeding up the process) one use of this is when verifying a write by reading back the nand and comparing it against the original you wrote, if you get a bad block just reread that individual block, patch it into the full read and compare again (files are reread each time you click compare, no need to reselect the same files in the gui) e.g. nandpro lpt: -w16 XBR.bin (write image as normal) nandpro lpt: -r16 verify.bin (read back image) (do comparison, shows block 2e mismatches) nandpro lpt: -r16 2e.bin 2e 1 (read block 2e) nandpro verify.bin: -w16 2e.bin 2e 1 (patch this new read into verify image) (do comparison again, if still bad rewrite just this block and read it back again as above) - reconstruct image from 3 bad reads assumes that read errors don't occur in same place each time, which is true for some read errors (e.g. lpt timing problems), if there is a good reason why you can't read something then this may not be true this tool cannot recreate a nand out of nothing, if you give it 3 files full of zeros you'll get a recreated nand full of zeros, always look at a dump to make sure it looks correct (e.g. has a microsoft copyright at the top, once you've reconstructed a nand open it in 360 flash tool and make sure it reads ok there) the tool works by comparing blocks between the 3 files, any block found matching in 2 (or 3) of the files will be considered good, you will be warned if not all blocks can be recovered, in which case you'll need to get more reads or look for a good reason why your reads are so bad version history: ---------------- 1.4 (2010/01/23) - support any size image (any number of blocks at 0x4000 + ecc) for partial dumps of large nands, 2mb xell backups, etc. 1.3 (2009/12/18) - reduce block size for 256/512mb nands (to 0x4000 + ecc) based on user feedback (nandpro uses small block numbering so our output didn't match up with nandpro) - make gui more responsive when operating on large nands 1.2 (2009/12/15) - support for 256mb nand - use correct block size for 256/512mb nand (0x20000 + ecc) - added progress bar 1.1 (2009/12/13) - support for 512mb nand (assumes same block size as 16mb) 1.0 (2009/12/12) - first release Category:Xbox360_Homebrew_Software","title":"NANDCompare"},{"location":"NandCompare/#nandcompare","text":"","title":"NANDCompare"},{"location":"NandCompare/#nfo","text":"nand compare (v1.4): -------------------- i made 6 reads of my nand with no matches (one of them was good but of course i didn't know that at the time), but diffing them i could see that the differences where spread all throughout the file, so i wrote this tool to reconstruct it then i also discovered the usefulness of the compare function in verification of the write, so hopefully this tool will be of use to other people please send feedback, bugs, etc. to rab (richardaburton@gmail.com) or post in the thread on xbox-scene or xboxhacker the tool has two functions: --------------------------- - compare 2 nand images better than simply using md5 as it tells you which blocks are mismatched, which allows you to reread only those that are in error rather than the entire chip (speeding up the process) one use of this is when verifying a write by reading back the nand and comparing it against the original you wrote, if you get a bad block just reread that individual block, patch it into the full read and compare again (files are reread each time you click compare, no need to reselect the same files in the gui) e.g. nandpro lpt: -w16 XBR.bin (write image as normal) nandpro lpt: -r16 verify.bin (read back image) (do comparison, shows block 2e mismatches) nandpro lpt: -r16 2e.bin 2e 1 (read block 2e) nandpro verify.bin: -w16 2e.bin 2e 1 (patch this new read into verify image) (do comparison again, if still bad rewrite just this block and read it back again as above) - reconstruct image from 3 bad reads assumes that read errors don't occur in same place each time, which is true for some read errors (e.g. lpt timing problems), if there is a good reason why you can't read something then this may not be true this tool cannot recreate a nand out of nothing, if you give it 3 files full of zeros you'll get a recreated nand full of zeros, always look at a dump to make sure it looks correct (e.g. has a microsoft copyright at the top, once you've reconstructed a nand open it in 360 flash tool and make sure it reads ok there) the tool works by comparing blocks between the 3 files, any block found matching in 2 (or 3) of the files will be considered good, you will be warned if not all blocks can be recovered, in which case you'll need to get more reads or look for a good reason why your reads are so bad version history: ---------------- 1.4 (2010/01/23) - support any size image (any number of blocks at 0x4000 + ecc) for partial dumps of large nands, 2mb xell backups, etc. 1.3 (2009/12/18) - reduce block size for 256/512mb nands (to 0x4000 + ecc) based on user feedback (nandpro uses small block numbering so our output didn't match up with nandpro) - make gui more responsive when operating on large nands 1.2 (2009/12/15) - support for 256mb nand - use correct block size for 256/512mb nand (0x20000 + ecc) - added progress bar 1.1 (2009/12/13) - support for 512mb nand (assumes same block size as 16mb) 1.0 (2009/12/12) - first release Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Northbridge/","text":"Northbridge The Xbox 360's North Bridge is integrated into the system's Xenos (GPU) and shares a memory controller with it. 128-bit GDDR3 Memory Controller @ 1.4GHz (22.4GB/s) :*700 MHz 512MB Samsung GDDR3 RAM (8 chips, each 512Mbit by 16 bits) Shared System/Graphics memory ::*(5.6GB/s per chip) ::*90nm Process 500MB/s read/write (1GB/s total) SIS Southbridge interface (PCI express) Category:Xbox360_Hardware","title":"Northbridge"},{"location":"Northbridge/#northbridge","text":"The Xbox 360's North Bridge is integrated into the system's Xenos (GPU) and shares a memory controller with it. 128-bit GDDR3 Memory Controller @ 1.4GHz (22.4GB/s) :*700 MHz 512MB Samsung GDDR3 RAM (8 chips, each 512Mbit by 16 bits) Shared System/Graphics memory ::*(5.6GB/s per chip) ::*90nm Process 500MB/s read/write (1GB/s total) SIS Southbridge interface (PCI express) Category:Xbox360_Hardware","title":"Northbridge"},{"location":"Old_Main_Page/","text":"Old Main page Free60 is a project towards porting GNU/Linux, BSD, Darwin and related open-source operating systems to the Microsoft Xbox 360 video game console. - 3-core PowerPC , 3.2 GHz - 512 MB of RAM - ATI graphics - (optional) 20 GB hard drive - DVD drive - 3x USB 2.0 - 100 MBit Ethernet - TV/VGA support Status Run Code You can run your own code on Xbox 360 systems with kernel versions 4532 and 4548. If you own a box manufactured before 2007, upgrade to one of these versions, but to no later one. Linux Bootloader A preliminary second-stage boot loader exists. Linux Kernel Patches for the Linux kernel to support a large part of the Xbox 360 hardware exist. As long as you're waiting for a convenient way to boot, you can set up your cross compiler environment. Linux Distributions Several LiveCD variants and installation howtos for Debian-etch , Ubuntu7.04 and Ubuntu7.10 are available. Documentation First Steps Try it out now How to test out linux (almost) without altering your system. Hardware CPU GPU R6T3 Software Kernel Hypervisor Misc Videos FAQ Communication There are several ways for you to get in touch with the people behind Free60 and for sharing information between users. We are an open project and therefore explicitly invite anybody to contact us and to help . IRC 29 Sep 2007: 3D Acceleration work has started: tmbinc has released an initial version of his 'gpu' library . It does not yet follow a standard API (like OpenGL), but allows you to play with the 3D GPU. 8 May 2007: Updated LiveCD ready: Stonersmurf mastered the updated LiveCD including the latest kernel patches. The Download is 621MB in size. See the Release Notes for details. Here is the Press Release 1 May 2007: We now have a fix for Samsung users We will soon release an updated LiveCD . If you want to build your own kernel, see Linux Kernel Development for patches against linux-2.6.21. 1 Apr 2007: X.org driver and a new LiveCD No April Fools' Day joke. We have released a preliminary X.org driver and Cpasjuste has built a new LiveCD which makes use of it. Unfortunately, support for Samsung drives and sound drivers are still missing. 30 Mar 2007: Gentoo Minimal LiveCD Cpasjuste has combined the Kernel patches and latest Xell into a LiveCD. The download is about 90MB in size and since it uses the readcd boot method, you may soon be able to boot it without soldering a serial connection to your Xbox 360 mainboard. 20 Mar 2007: Linux Bootloader available tmbinc has come up with a Linux Bootloader , which handles CPU initialization and loads the Linux Kernel either from network or CDROM. 8 Mar 2007: First Linux patchset available Felix Domke posted a patchset for the Linux Kernel 2.6.20 Kernel to the Linux-PPC mailing list. 1 Mar 2007: Hypervisor privilege-escalation vulnerability Some \"Anonymous Hacker\"; published a security advisory that will make it possible to run alternative operating systems on the Xbox 360. 30 Dec 2006: Homebrew mock-up at 23C3 An \"Anonymous Hacker\" showed a Xbox 360 running unsigned code at 23C3 conference. See more in the Videos section. 7 Mar 2006: CPU Datasheet More great work from [Speedy22] this time he has created a datasheet for the Xbox 360's CPU . It can be found here . Microsoft, Xbox, Xbox360 (and probably some more) are registered trademarks by Microsoft Corp. No affiliation between the Free60 Project and Microsoft Corp. exists or is implied. All other trademarks and copyrights are property of their respective owners. Please note that all information on this website is for informational purpose only and is provided AS IS . Everything you do with this information is on your own risk. If you believe anything on this site violates any law or any of your rights, please contact us so that we can find a quick solution. Everything done on this project is for the sole purpose of writing interoperable software under Sect. 1201 (f) Reverse Engineering exception of the DMCA. Category:Template documentation","title":"Old Main page"},{"location":"Old_Main_Page/#old-main-page","text":"Free60 is a project towards porting GNU/Linux, BSD, Darwin and related open-source operating systems to the Microsoft Xbox 360 video game console. - 3-core PowerPC , 3.2 GHz - 512 MB of RAM - ATI graphics - (optional) 20 GB hard drive - DVD drive - 3x USB 2.0 - 100 MBit Ethernet - TV/VGA support","title":"Old Main page"},{"location":"Old_Main_Page/#status","text":"","title":"Status"},{"location":"Old_Main_Page/#run-code","text":"You can run your own code on Xbox 360 systems with kernel versions 4532 and 4548. If you own a box manufactured before 2007, upgrade to one of these versions, but to no later one.","title":"Run Code"},{"location":"Old_Main_Page/#linux-bootloader","text":"A preliminary second-stage boot loader exists.","title":"Linux Bootloader"},{"location":"Old_Main_Page/#linux-kernel","text":"Patches for the Linux kernel to support a large part of the Xbox 360 hardware exist. As long as you're waiting for a convenient way to boot, you can set up your cross compiler environment.","title":"Linux Kernel"},{"location":"Old_Main_Page/#linux-distributions","text":"Several LiveCD variants and installation howtos for Debian-etch , Ubuntu7.04 and Ubuntu7.10 are available.","title":"Linux Distributions"},{"location":"Old_Main_Page/#documentation","text":"","title":"Documentation"},{"location":"Old_Main_Page/#first-steps","text":"Try it out now How to test out linux (almost) without altering your system.","title":"First Steps"},{"location":"Old_Main_Page/#hardware","text":"CPU GPU R6T3","title":"Hardware"},{"location":"Old_Main_Page/#software","text":"Kernel Hypervisor","title":"Software"},{"location":"Old_Main_Page/#misc","text":"Videos FAQ","title":"Misc"},{"location":"Old_Main_Page/#communication","text":"There are several ways for you to get in touch with the people behind Free60 and for sharing information between users. We are an open project and therefore explicitly invite anybody to contact us and to help .","title":"Communication"},{"location":"Old_Main_Page/#irc","text":"29 Sep 2007: 3D Acceleration work has started: tmbinc has released an initial version of his 'gpu' library . It does not yet follow a standard API (like OpenGL), but allows you to play with the 3D GPU. 8 May 2007: Updated LiveCD ready: Stonersmurf mastered the updated LiveCD including the latest kernel patches. The Download is 621MB in size. See the Release Notes for details. Here is the Press Release 1 May 2007: We now have a fix for Samsung users We will soon release an updated LiveCD . If you want to build your own kernel, see Linux Kernel Development for patches against linux-2.6.21. 1 Apr 2007: X.org driver and a new LiveCD No April Fools' Day joke. We have released a preliminary X.org driver and Cpasjuste has built a new LiveCD which makes use of it. Unfortunately, support for Samsung drives and sound drivers are still missing. 30 Mar 2007: Gentoo Minimal LiveCD Cpasjuste has combined the Kernel patches and latest Xell into a LiveCD. The download is about 90MB in size and since it uses the readcd boot method, you may soon be able to boot it without soldering a serial connection to your Xbox 360 mainboard. 20 Mar 2007: Linux Bootloader available tmbinc has come up with a Linux Bootloader , which handles CPU initialization and loads the Linux Kernel either from network or CDROM. 8 Mar 2007: First Linux patchset available Felix Domke posted a patchset for the Linux Kernel 2.6.20 Kernel to the Linux-PPC mailing list. 1 Mar 2007: Hypervisor privilege-escalation vulnerability Some \"Anonymous Hacker\"; published a security advisory that will make it possible to run alternative operating systems on the Xbox 360. 30 Dec 2006: Homebrew mock-up at 23C3 An \"Anonymous Hacker\" showed a Xbox 360 running unsigned code at 23C3 conference. See more in the Videos section. 7 Mar 2006: CPU Datasheet More great work from [Speedy22] this time he has created a datasheet for the Xbox 360's CPU . It can be found here . Microsoft, Xbox, Xbox360 (and probably some more) are registered trademarks by Microsoft Corp. No affiliation between the Free60 Project and Microsoft Corp. exists or is implied. All other trademarks and copyrights are property of their respective owners. Please note that all information on this website is for informational purpose only and is provided AS IS . Everything you do with this information is on your own risk. If you believe anything on this site violates any law or any of your rights, please contact us so that we can find a quick solution. Everything done on this project is for the sole purpose of writing interoperable software under Sect. 1201 (f) Reverse Engineering exception of the DMCA. Category:Template documentation","title":"IRC"},{"location":"Opus/","text":"REDIRECT Falcon Category:Xbox360_Hardware","title":"Opus"},{"location":"Other_OS_Loader/","text":"The following has been written on April 1st, 2010. Happy April fool's day! In a leaked private e-mail to current Free60 project maintainer Georg Lukas, Microsoft Interactive Entertainment Business has stated to release a dashboard update for the Xbox 360 allowing to boot an \"Other OS\", similar to the functionality recently disabled in the PS3 by Sony : From: xxx <xxx@ieb.microsoft.com> To: Georg Lukas <georg@op-co.de> Subject: Loading other Operating Systems on the Xbox 360 Hello, due to the recent policy change at Sony and the hacker attempts to patching our Dashboard Software for illegal activities, we have decided to add a feature to the Xbox 360 dashboard to allow booting other operating systems from USB media. The \"Other OS\" feature will be run in a hypervisor VM context, restricting hardware access to the GPU and preventing the boot-up of a patched dashboard. We would like to ask you for your help in choosing the minimum PCI memory ranges required for booting up and working with a Linux OS. Please contact us ASAP, as we are planning to deploy this feature in the Summer 2010 dashboard update. Kind regards, XXX Category:Template documentation","title":"Other OS Loader"},{"location":"PCSXR-Xenon/","text":"General Info NFO Pcsxr-xenon - Release a 0.5 --------------------------- **** Pcsxr-xenon is a sony playstation 1 emulator using libxenon, based on lastest PCSX-Reloaded source code available. **** ============================== Changelogs ============================== alpha 0.5.1 - missing sound over hdmi ============================== Thanks ============================== - Big thanks to GliGli to mantain libxenon - Thanks to [c0Z], i'm always asking you something and don't understand - Thanks to Razkar, Tuxuser, Cancerous to support me all the time - Thanks to Pcsx-reloaded, pcsx-rearmed, shalma to your gift to the ps1 emulation scene Ced2911 - 08/14/2011 Update 04/03/2012 Pcsxr 0.6 New gpu plugin, allow to play game in hd !! Load game from fat, ext2/3/4, ntfs device Save states support Thanks, Gligli, Razkar, Tuxuser, [c0z], lantus, all the libxenon-dev team Update 18/03/2012 Pcsxr 0.62 Remove ext2/3/4, ntfs support (red screen on some setup) Bug fixe on gpu plugin Category:Xbox360_Homebrew_Software","title":"PCSXR Xenon"},{"location":"PCSXR-Xenon/#general-info","text":"","title":"General Info"},{"location":"PCSXR-Xenon/#nfo","text":"Pcsxr-xenon - Release a 0.5 --------------------------- **** Pcsxr-xenon is a sony playstation 1 emulator using libxenon, based on lastest PCSX-Reloaded source code available. **** ============================== Changelogs ============================== alpha 0.5.1 - missing sound over hdmi ============================== Thanks ============================== - Big thanks to GliGli to mantain libxenon - Thanks to [c0Z], i'm always asking you something and don't understand - Thanks to Razkar, Tuxuser, Cancerous to support me all the time - Thanks to Pcsx-reloaded, pcsx-rearmed, shalma to your gift to the ps1 emulation scene Ced2911 - 08/14/2011 Update 04/03/2012 Pcsxr 0.6 New gpu plugin, allow to play game in hd !! Load game from fat, ext2/3/4, ntfs device Save states support Thanks, Gligli, Razkar, Tuxuser, [c0z], lantus, all the libxenon-dev team Update 18/03/2012 Pcsxr 0.62 Remove ext2/3/4, ntfs support (red screen on some setup) Bug fixe on gpu plugin Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"PC_Software/","text":"NAND Tools Name: NandCompare Description: Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. Author: Rab at XBH Download: v1.3 Name: NandPro Description: Read/write NAND dumps and repair the spare bytes / ECC sections. Author: Tiros at XBH Download: xbins Name: 360FlashTool Description: Decrypt and extract various parts of an Xbox NAND dump. Author: Robinsod, TheSpecialist and SeventhSon at XBH Since Robinsod released the source of \"360 Flash Dump Tool\" and stoped developing a couple of people (Redline99, Tiros and MODFREAKz) decided to continue develop this great app. Download: 0.97 Name: NANDFS Description: Add/remove/extract files from a NAND dump. Open source. Author: [stoker25], based on 360 Flash Tool source by Robinsod. Download: v.45d binaries v.45d source Category:Xbox360_Homebrew_Software","title":"PC Software"},{"location":"PC_Software/#nand-tools","text":"Name: NandCompare Description: Check/verify your Xbox 360 NAND dumps and potentially even repair them if you have at least 3 'bad' dumps. Author: Rab at XBH Download: v1.3 Name: NandPro Description: Read/write NAND dumps and repair the spare bytes / ECC sections. Author: Tiros at XBH Download: xbins Name: 360FlashTool Description: Decrypt and extract various parts of an Xbox NAND dump. Author: Robinsod, TheSpecialist and SeventhSon at XBH Since Robinsod released the source of \"360 Flash Dump Tool\" and stoped developing a couple of people (Redline99, Tiros and MODFREAKz) decided to continue develop this great app. Download: 0.97 Name: NANDFS Description: Add/remove/extract files from a NAND dump. Open source. Author: [stoker25], based on 360 Flash Tool source by Robinsod. Download: v.45d binaries v.45d source Category:Xbox360_Homebrew_Software","title":"NAND Tools"},{"location":"PEC/","text":"PEC (Profile Embedded Content) files are used by the Xbox 360 as an additional layer of security on profiles. Certain GPD files are relocated inside the PEC file. The PEC file stores information on avatar clothes/items, and is just another STFS package. With this said you must properly rehash and resign the PEC file to avoid the Xbox detecting corruption of the package. Rehashing is the same as all STFS packages (besides the starting block), but resigning is different (view below). Header Offset Length Type Information 0x0 0x228 [[Console_Security_Certificate Console Security Certificate]] 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 [[STFS#Volume_Descriptor Structure]] 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID Notes The Console ID at 0x275 must match the Console ID located in the Console Security Certificate , otherwise the Xbox360 will see it as a corrupted file. The signature located in the Console Security Certificate is signed using the hash at location 0x228. (SHA1 hash from 0x23C - 0x1000) From 0x1000 the rest of the file is the standard block portion of STFS , with data block 0 starting at 0x3000, and hash table 0 at 0x1000/0x2000. The PEC file always has 2 hash tables (type 1 package). Category:Xbox360_System_Software","title":"PEC"},{"location":"PEC/#header","text":"Offset Length Type Information 0x0 0x228 [[Console_Security_Certificate Console Security Certificate]] 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 [[STFS#Volume_Descriptor Structure]] 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID","title":"Header"},{"location":"PEC/#notes","text":"The Console ID at 0x275 must match the Console ID located in the Console Security Certificate , otherwise the Xbox360 will see it as a corrupted file. The signature located in the Console Security Certificate is signed using the hash at location 0x228. (SHA1 hash from 0x23C - 0x1000) From 0x1000 the rest of the file is the standard block portion of STFS , with data block 0 starting at 0x3000, and hash table 0 at 0x1000/0x2000. The PEC file always has 2 hash tables (type 1 package). Category:Xbox360_System_Software","title":"Notes"},{"location":"POST/","text":"During bootup the XBox 360 issues several POST Codes on a special 8-bit bus for diagnostic purposes. POST stands for power on self test. Its a bus created to help debug the xbox boot up process. In the bootloaders there is code that updates the number represented by the bus so it is possible to see at which point the bootloader is executing and where it hangs if an error occured. The reset glitch hack uses the post codes to track the progress of initialization and know when to assert the reset signal. In RGH1, it waits for when the second bootloader(CB) starts verifying the integrity check of the hash of the fourth bootloder(CD). When the bootloaders were updated starting on 14717, they removed the post codes from the bootloaders and added a few tricks like random delays to prevent glitchers from being able to tell when the xbox is checking the hash. Pinout On Phat consoles the pinout is as follows: DBG_WN_POST_OUT0/BIT7 FT6U8 DBG_WN_POST_OUT1/BIT6 FT6U2 DBG_WN_POST_OUT2/BIT5 FT6U3 DBG_WN_POST_OUT3/BIT4 FT6U4 DBG_WN_POST_OUT4/BIT3 FT6U5 DBG_WN_POST_OUT5/BIT2 FT6U6 DBG_WN_POST_OUT6/BIT1 FT6U7 DBG_WN_POST_OUT7/BIT0 FT6U1 Voltage levels are 1.2V for PHAT / 1.8V for SLIM Reading the POST bus The POST bus holds the last code's bits all the time. So we can read it with simple multimeter. To assemble bits to the byte, join them together like that (BIT ORDER 76543210): For Example: bit7,bit6,bit5,bit4,bit3,bit2,bit1,bit0 00111010 = 0x3A = CD auth success Writing to the POST Bus Writing to the POST Bus is easy: Just write you 8 bit shifted by 56 Bit left to memory location 0x8000 0200 0006 1010: ; load address in r7 li %r7,0x200 oris %r7,%r7,0x8000 rldicr %r7,%r7,32,31 ori %r7,%r7,0x1010 oris %r7,%r7,6 ; write POST code li %r3, 0x12 rldicr %r3, %r3, 56, 7 std %r3, 0(%r7) The address is given in real mode, so you need to be careful when paging is enabled. Meaning of different POST Codes Domain Code Enum Description JTAG & 0x10 Payload started RGH 0x11 Payload has copied XeLL to the RAM from NAND and executed it 1BL 0x10 - 1BL started 0x11 FSB_CONFIG_PHY_CONTROL Execute FSB function1 0x12 FSB_CONFIG_RX_STATE Execute FSB function2 0x13 FSB_CONFIG_TX_STATE Execute FSB function3 0x14 FSB_CONFIG_TX_CREDITS Execute FSB function4 0x15 FETCH_OFFSET Verify CB offset 0x16 FETCH_HEADER Copy CB header from NAND 0x17 VERIFY_HEADER Verify CB header 0x18 FETCH_CONTENTS Copy CB into protected SRAM 0x19 HMACSHA_COMPUTE Generate CB HMAC key 0x1A RC4_INITIALIZE Initialize CB RC4 decryption key 0x1B RC4_DECRYPT RC4 decrypt CB 0x1C SHA_COMPUTE Generate hash of CB for verification 0x1D SIG_VERIFY RSA signature check of CB hash 0x1E BRANCH Jump to CB 1BL 0x81 PANIC - MACHINE_CHECK Panics 0x82 PANIC - DATA_STORAGE 0x83 PANIC - DATA_SEGMENT 0x84 PANIC - INSTRUCTION_STORAGE 0x85 PANIC - INSTRUCTION_SEGMENT 0x86 PANIC - EXTERNAL 0x87 PANIC - ALIGNMENT 0x88 PANIC - PROGRAM 0x89 PANIC - FPU_UNAVAILABLE 0x8A PANIC - DECREMENTER 0x8B PANIC - HYPERVISOR_DECREMENTER 0x8C PANIC - SYSTEM_CALL 0x8D PANIC - TRACE 0x8E PANIC - VPU_UNAVAILABLE 0x8F PANIC - MAINTENANCE 0x90 PANIC - VMX_ASSIST 0x91 PANIC - THERMAL_MANAGEMENT 0x92 - 1BL is executed on wrong CPU thread (panic) 0x93 PANIC - TOO_MANY_CORES 1BL is executed on wrong CPU core (panic) 0x94 PANIC - VERIFY_OFFSET CB offset verification failed 0x95 PANIC - VERIFY_HEADER CB header verification failed 0x96 PANIC - SIG_VERIFY CB RSA signature verification failed 0x97 PANIC - NONHOST_RESUME_STATUS 0x98 PANIC - NEXT_STAGE_SIZE Size of next stage is out-of-bounds CB_A/2BL 0xD0 CB_A entry point, copy self to 0x8000.0200.0001.C000 and continue from there (Slim 0xD1 READ_FUSES Copy fuses from SoC for CB_B decryption excl.) 0xD2 VERIFY_OFFSET_CB_B Verify CB_B offset 0xD3 FETCH_HEADER_CB_B Copy CB_B header from NAND for verification 0xD4 VERIFY_HEADER_CB_B Verify CB_B header 0xD5 FETCH_CONTENTS_CB_B Copy CBB into memory at 0x8000.0200.0001.0000 (old location of CB_A) 0xD6 HMACSHA_COMPUTE_CB_B Create HMAC key for CD decryption 0xD7 RC4_INITIALIZE_CB_B Initialize CD RC4 key using HMAC key 0xD8 RC4_DECRYPT_CB_B RC4 decrypt CD 0xD9 SHA_COMPUTE_CB_B Compute hash of CD for verification 0xDA SHA_VERIFY_CB_B MemCmp computed hash with expected one (where rgh2 glitches) 0xDB BRANCH_CB_B Jump to CB_B CB_A 0xF0 PANIC - VERIFY_OFFSET_CB_B CBB offset verification fail Panics 0xF1 PANIC - VERIFY_HEADER_CB_B CBB header verification fail 0xF2 PANIC - SHA_VERIFY_CB_B CBB security hash comparison fail 0xF3 PANIC - ENTRY_SIZE_INVALID_CB_B CBB size check fail (must be less than 0xC000) CB/2BL 0x20 - CB entry point, initialize SoC 0x21 INIT_SECOTP Initialize secopt, verify lockdown fuses 0x22 INIT_SECENG Initialize security engine 0x23 INIT_SYSRAM Initialize EDRAM 0x24 VERIFY_OFFSET_3BL_CC 0x25 LOCATE_3BL_CC 0x26 FETCH_HEADER_3BL_CC 0x27 VERIFY_HEADER_3BL_CC 0x28 FETCH_CONTENTS_3BL_CC 0x29 HMACSHA_COMPUTE_3BL_CC 0x2A RC4_INITIALIZE_3BL_CC 0x2B RC4_DECRYPT_3BL_CC 0x2C SHA_COMPUTE_3BL_CC 0x2D SIG_VERIFY_3BL_CC 0x2E HWINIT Hardware initialization 0x2F RELOCATE Setup tlb entries, relocate to ram 0x30 VERIFY_OFFSET_4BL_CD Verify CD offset 0x31 FETCH_HEADER_4BL_CD Copy CD header from NAND for verification 0x32 VERIFY_HEADER_4BL_CD Verify CD header 0x33 FETCH_CONTENTS_4BL_CD Copy CD from nand 0x34 HMACSHA_COMPUTE_4BL_CD Create HMAC key for CD decryption 0x35 RC4_INITIALIZE_4BL_CD Initialize CD RC4 key using HMAC key 0x36 RC4_DECRYPT_4BL_CD RC4 decrypt CD with key 0x37 SHA_COMPUTE_4BL_CD Compute hash of CD for verification 0x38 SIG_VERIFY_4BL_CD RSA signature check of CD hash 0x39 SHA_VERIFY_4BL_CD MemCmp computed hash with expected one 0x3A BRANCH Setup memory encryption and jump to CD 0x3B PCI_INIT Initialize PCI CB 0x9B PANIC - VERIFY_SECOTP_1 Secopt fuse verification fail Panics 0x9C PANIC - VERIFY_SECOTP_2 Secopt fuse verification fail2 0x9D PANIC - VERIFY_SECOTP_3 Secopt fuse verification console type? fail 0x9E PANIC - VERIFY_SECOTP_4 Secopt fuse verification console type? fail 0x9F PANIC - VERIFY_SECOTP_5 Secopt fuse verification console type? fail 0xA0 PANIC - VERIFY_SECOTP_6 CB revocation check failed 0xA1 PANIC - VERIFY_SECOTP_7 Panic after 0x21 0xA2 PANIC - VERIFY_SECOTP_8 Panic after 0x21 0xA3 PANIC - VERIFY_SECOTP_9 Panic after 0x21 0xA4 PANIC - VERIFY_SECOTP_10 Failed SMC HMAC 0xA5 PANIC - VERIFY_OFFSET_3BL_CC 0xA6 PANIC - LOCATE_3BL_CC 0xA7 PANIC - VERIFY_HEADER_3BL_CC 0xA8 PANIC - SIG_VERIFY_3BL_CC 0xA9 PANIC - HWINIT Hardware initialization failed 0xAA PANIC - VERIFY_OFFSET_4BL_CD Failed to verify CD offset 0xAB PANIC - VERIFY_HEADER_4BL_CD Failed to verify CD header 0xAC PANIC - SIG_VERIFY_4BL_CD 0xAD PANIC - SHA_VERIFY_4BL_CD CD security hash comparison fail 0xAE PANIC - UNEXPECTED_INTERRUPT CB exception, unknown interrupt vector 0xAF PANIC - UNSUPPORTED_RAM_SIZE 0xB0 PANIC - VERIFY_CONSOLE_TYPE Secopt fuse verification console type? fail CD/4BL 0x40 - Entrypoint of CD, setup memory paging 0x41 VERIFY_OFFSET Verify offset to CE 0x42 FETCH_HEADER Copy CE header from NAND for verification 0x43 VERIFY_HEADER Verify CE Header 0x44 FETCH_CONTENTS Read CE from nand into memory 0x45 HMACSHA_COMPUTE Create HMAC key for CE decryption 0x46 RC4_INITIALIZE Initialize CE RC4 key using HMAC key 0x47 RC4_DECRYPT RC4 decrypt CE 0x48 SHA_COMPUTE Compute hash of CE for verification 0x49 SHA_VERIFY MemCmp computed hash with expected one (where rgh1 glitches) 0x4A LOAD_6BL_CF 0x4B LZX_EXPAND LZX Decompress CE 0x4C SWEEP_CACHES 0x4D DECODE_FUSES Decode fuses 0x4E FETCH_OFFSET_6BL_CF Load CF (kernel patches) offset 0x4F VERIFY_OFFSET_6BL_CF Verify CF offset 0x50 LOAD_UPDATE_1 Load CF1/CG1 (patch slot 1) if version & header checks pass 0x51 LOAD_UPDATE_2 Load CF2/CG2 (patch slot 2) if version & header checks pass 0x52 BRANCH Startup kernel/Hypervisor 0x53 DECRYT_VERIFY_HV_CERT Decrypt and verify hypervisor certificate CD 0xB1 PANIC - VERIFY_OFFSET CE decryption failed Panics 0xB2 PANIC - VERIFY_HEADER Failed to verify CE header 0xB3 PANIC - SHA_VERIFY CE hash comparison fail 0xB4 PANIC - LZX_EXPAND CE LZX decompression failed 0xB5 PANIC - VERIFY_OFFSET_6BL CF verification failed 0xB6 PANIC - DECODE_FUSES Fuse decryption/check failed 0xB7 PANIC - UPDATE_MISSING CF decryption failed, patches missing. 0xB8 PANIC - CF hash auth failed CE 0xC1 LZX_EXPAND_1 LDICreateDecompression failed CF 0xC2 LZX_EXPAND_2 CG size verification failed Panics 0xC3 LZX_EXPAND_3 Header / patch fragment info check failed 0xC4 LZX_EXPAND_4 Unexpected LDI fragment type 0xC5 LZX_EXPAND_5 LDISetWindowData failed 0xC6 LZX_EXPAND_6 LDIDecompress failed 0xC7 LZX_EXPAND_7 LDIResetDecompression failed 0xC8 SHA_VERIFY CG auth failed Hypervisor 0x58 INIT_HYPERVISOR Hypervisor Initialization begin /HV 0x59 INIT_SOC_MMIO Initialize SoC MMIO 0x5A INIT_XEX_TRAINING Initialize XEX training 0x5B INIT_KEYRING Initialize key ring 0x5C INIT_KEYS Initialize keys 0x5D INIT_SOC_INT Initialize SoC Interrupts 0x5E INIT_SOC_INT_COMPLETE Initialization complete HV Panics 0xFF PANIC - FATAL Fatal error Kernel 0x60 INIT_KERNEL Initialize kernel 0x61 INIT_HAL_PHASE_0 Initialize hardware abstraction layer (phase 0) 0x62 INIT_PROCESS_OBJECTS Initialize process objects 0x63 INIT_KERNEL_DEBUGGER Initialize kernel debugger 0x64 INIT_MEMORY_MANAGER Initialize memory manager 0x65 INIT_STACKS Initialize stacks 0x66 INIT_OBJECT_SYSTEM Initialize object system 0x67 INIT_PHASE1_THREAD Initialize phase 1 thread 0x68 INIT_PROCESSORS Initialize processors 0x69 INIT_KEY_VAULT Initialize keyvault 0x6A INIT_HAL_PHASE_1 Initialize hardware abstraction layer (phase 1) 0x6B INIT_SFC_DRIVER Initialize SFC (Flash controller) 0x6C INIT_SECURITY Initialize security 0x6D INIT_KEY_EX_VAULT Initialize keyvault (extended portion) 0x6E INIT_SETTINGS Initialize settings 0x6F INIT_POWER_MODE Initialize power mode 0x70 INIT_VIDEO_DRIVER Initialize video driver 0x71 INIT_AUDIO_DRIVER Initialize audio driver 0x72 INIT_BOOT_ANIMATION Initialize boot animation + XMADecoder & XAudioRender Init 0x73 INIT_SATA_DRIVER Initialize SATA driver 0x74 INIT_SHADOWBOOT Initialize shadowboot 0x75 INIT_DUMP_SYSTEM Initialize dump system 0x76 INIT_SYSTEM_ROOT Initialize system root 0x77 INIT_OTHER_DRIVERS Initialize other drivers 0x78 INIT_STFS_DRIVER Initialize STFS driver 0x79 LOAD_XAM Load XAM Credits Retrieved from (https://www.xdevwiki.tk/index.php?title=POST_Codes&oldid=156)","title":"POST"},{"location":"POST/#pinout","text":"On Phat consoles the pinout is as follows: DBG_WN_POST_OUT0/BIT7 FT6U8 DBG_WN_POST_OUT1/BIT6 FT6U2 DBG_WN_POST_OUT2/BIT5 FT6U3 DBG_WN_POST_OUT3/BIT4 FT6U4 DBG_WN_POST_OUT4/BIT3 FT6U5 DBG_WN_POST_OUT5/BIT2 FT6U6 DBG_WN_POST_OUT6/BIT1 FT6U7 DBG_WN_POST_OUT7/BIT0 FT6U1 Voltage levels are 1.2V for PHAT / 1.8V for SLIM","title":"Pinout"},{"location":"POST/#reading-the-post-bus","text":"The POST bus holds the last code's bits all the time. So we can read it with simple multimeter. To assemble bits to the byte, join them together like that (BIT ORDER 76543210): For Example: bit7,bit6,bit5,bit4,bit3,bit2,bit1,bit0 00111010 = 0x3A = CD auth success","title":"Reading the POST bus"},{"location":"POST/#writing-to-the-post-bus","text":"Writing to the POST Bus is easy: Just write you 8 bit shifted by 56 Bit left to memory location 0x8000 0200 0006 1010: ; load address in r7 li %r7,0x200 oris %r7,%r7,0x8000 rldicr %r7,%r7,32,31 ori %r7,%r7,0x1010 oris %r7,%r7,6 ; write POST code li %r3, 0x12 rldicr %r3, %r3, 56, 7 std %r3, 0(%r7) The address is given in real mode, so you need to be careful when paging is enabled.","title":"Writing to the POST Bus"},{"location":"POST/#meaning-of-different-post-codes","text":"Domain Code Enum Description JTAG & 0x10 Payload started RGH 0x11 Payload has copied XeLL to the RAM from NAND and executed it 1BL 0x10 - 1BL started 0x11 FSB_CONFIG_PHY_CONTROL Execute FSB function1 0x12 FSB_CONFIG_RX_STATE Execute FSB function2 0x13 FSB_CONFIG_TX_STATE Execute FSB function3 0x14 FSB_CONFIG_TX_CREDITS Execute FSB function4 0x15 FETCH_OFFSET Verify CB offset 0x16 FETCH_HEADER Copy CB header from NAND 0x17 VERIFY_HEADER Verify CB header 0x18 FETCH_CONTENTS Copy CB into protected SRAM 0x19 HMACSHA_COMPUTE Generate CB HMAC key 0x1A RC4_INITIALIZE Initialize CB RC4 decryption key 0x1B RC4_DECRYPT RC4 decrypt CB 0x1C SHA_COMPUTE Generate hash of CB for verification 0x1D SIG_VERIFY RSA signature check of CB hash 0x1E BRANCH Jump to CB 1BL 0x81 PANIC - MACHINE_CHECK Panics 0x82 PANIC - DATA_STORAGE 0x83 PANIC - DATA_SEGMENT 0x84 PANIC - INSTRUCTION_STORAGE 0x85 PANIC - INSTRUCTION_SEGMENT 0x86 PANIC - EXTERNAL 0x87 PANIC - ALIGNMENT 0x88 PANIC - PROGRAM 0x89 PANIC - FPU_UNAVAILABLE 0x8A PANIC - DECREMENTER 0x8B PANIC - HYPERVISOR_DECREMENTER 0x8C PANIC - SYSTEM_CALL 0x8D PANIC - TRACE 0x8E PANIC - VPU_UNAVAILABLE 0x8F PANIC - MAINTENANCE 0x90 PANIC - VMX_ASSIST 0x91 PANIC - THERMAL_MANAGEMENT 0x92 - 1BL is executed on wrong CPU thread (panic) 0x93 PANIC - TOO_MANY_CORES 1BL is executed on wrong CPU core (panic) 0x94 PANIC - VERIFY_OFFSET CB offset verification failed 0x95 PANIC - VERIFY_HEADER CB header verification failed 0x96 PANIC - SIG_VERIFY CB RSA signature verification failed 0x97 PANIC - NONHOST_RESUME_STATUS 0x98 PANIC - NEXT_STAGE_SIZE Size of next stage is out-of-bounds CB_A/2BL 0xD0 CB_A entry point, copy self to 0x8000.0200.0001.C000 and continue from there (Slim 0xD1 READ_FUSES Copy fuses from SoC for CB_B decryption excl.) 0xD2 VERIFY_OFFSET_CB_B Verify CB_B offset 0xD3 FETCH_HEADER_CB_B Copy CB_B header from NAND for verification 0xD4 VERIFY_HEADER_CB_B Verify CB_B header 0xD5 FETCH_CONTENTS_CB_B Copy CBB into memory at 0x8000.0200.0001.0000 (old location of CB_A) 0xD6 HMACSHA_COMPUTE_CB_B Create HMAC key for CD decryption 0xD7 RC4_INITIALIZE_CB_B Initialize CD RC4 key using HMAC key 0xD8 RC4_DECRYPT_CB_B RC4 decrypt CD 0xD9 SHA_COMPUTE_CB_B Compute hash of CD for verification 0xDA SHA_VERIFY_CB_B MemCmp computed hash with expected one (where rgh2 glitches) 0xDB BRANCH_CB_B Jump to CB_B CB_A 0xF0 PANIC - VERIFY_OFFSET_CB_B CBB offset verification fail Panics 0xF1 PANIC - VERIFY_HEADER_CB_B CBB header verification fail 0xF2 PANIC - SHA_VERIFY_CB_B CBB security hash comparison fail 0xF3 PANIC - ENTRY_SIZE_INVALID_CB_B CBB size check fail (must be less than 0xC000) CB/2BL 0x20 - CB entry point, initialize SoC 0x21 INIT_SECOTP Initialize secopt, verify lockdown fuses 0x22 INIT_SECENG Initialize security engine 0x23 INIT_SYSRAM Initialize EDRAM 0x24 VERIFY_OFFSET_3BL_CC 0x25 LOCATE_3BL_CC 0x26 FETCH_HEADER_3BL_CC 0x27 VERIFY_HEADER_3BL_CC 0x28 FETCH_CONTENTS_3BL_CC 0x29 HMACSHA_COMPUTE_3BL_CC 0x2A RC4_INITIALIZE_3BL_CC 0x2B RC4_DECRYPT_3BL_CC 0x2C SHA_COMPUTE_3BL_CC 0x2D SIG_VERIFY_3BL_CC 0x2E HWINIT Hardware initialization 0x2F RELOCATE Setup tlb entries, relocate to ram 0x30 VERIFY_OFFSET_4BL_CD Verify CD offset 0x31 FETCH_HEADER_4BL_CD Copy CD header from NAND for verification 0x32 VERIFY_HEADER_4BL_CD Verify CD header 0x33 FETCH_CONTENTS_4BL_CD Copy CD from nand 0x34 HMACSHA_COMPUTE_4BL_CD Create HMAC key for CD decryption 0x35 RC4_INITIALIZE_4BL_CD Initialize CD RC4 key using HMAC key 0x36 RC4_DECRYPT_4BL_CD RC4 decrypt CD with key 0x37 SHA_COMPUTE_4BL_CD Compute hash of CD for verification 0x38 SIG_VERIFY_4BL_CD RSA signature check of CD hash 0x39 SHA_VERIFY_4BL_CD MemCmp computed hash with expected one 0x3A BRANCH Setup memory encryption and jump to CD 0x3B PCI_INIT Initialize PCI CB 0x9B PANIC - VERIFY_SECOTP_1 Secopt fuse verification fail Panics 0x9C PANIC - VERIFY_SECOTP_2 Secopt fuse verification fail2 0x9D PANIC - VERIFY_SECOTP_3 Secopt fuse verification console type? fail 0x9E PANIC - VERIFY_SECOTP_4 Secopt fuse verification console type? fail 0x9F PANIC - VERIFY_SECOTP_5 Secopt fuse verification console type? fail 0xA0 PANIC - VERIFY_SECOTP_6 CB revocation check failed 0xA1 PANIC - VERIFY_SECOTP_7 Panic after 0x21 0xA2 PANIC - VERIFY_SECOTP_8 Panic after 0x21 0xA3 PANIC - VERIFY_SECOTP_9 Panic after 0x21 0xA4 PANIC - VERIFY_SECOTP_10 Failed SMC HMAC 0xA5 PANIC - VERIFY_OFFSET_3BL_CC 0xA6 PANIC - LOCATE_3BL_CC 0xA7 PANIC - VERIFY_HEADER_3BL_CC 0xA8 PANIC - SIG_VERIFY_3BL_CC 0xA9 PANIC - HWINIT Hardware initialization failed 0xAA PANIC - VERIFY_OFFSET_4BL_CD Failed to verify CD offset 0xAB PANIC - VERIFY_HEADER_4BL_CD Failed to verify CD header 0xAC PANIC - SIG_VERIFY_4BL_CD 0xAD PANIC - SHA_VERIFY_4BL_CD CD security hash comparison fail 0xAE PANIC - UNEXPECTED_INTERRUPT CB exception, unknown interrupt vector 0xAF PANIC - UNSUPPORTED_RAM_SIZE 0xB0 PANIC - VERIFY_CONSOLE_TYPE Secopt fuse verification console type? fail CD/4BL 0x40 - Entrypoint of CD, setup memory paging 0x41 VERIFY_OFFSET Verify offset to CE 0x42 FETCH_HEADER Copy CE header from NAND for verification 0x43 VERIFY_HEADER Verify CE Header 0x44 FETCH_CONTENTS Read CE from nand into memory 0x45 HMACSHA_COMPUTE Create HMAC key for CE decryption 0x46 RC4_INITIALIZE Initialize CE RC4 key using HMAC key 0x47 RC4_DECRYPT RC4 decrypt CE 0x48 SHA_COMPUTE Compute hash of CE for verification 0x49 SHA_VERIFY MemCmp computed hash with expected one (where rgh1 glitches) 0x4A LOAD_6BL_CF 0x4B LZX_EXPAND LZX Decompress CE 0x4C SWEEP_CACHES 0x4D DECODE_FUSES Decode fuses 0x4E FETCH_OFFSET_6BL_CF Load CF (kernel patches) offset 0x4F VERIFY_OFFSET_6BL_CF Verify CF offset 0x50 LOAD_UPDATE_1 Load CF1/CG1 (patch slot 1) if version & header checks pass 0x51 LOAD_UPDATE_2 Load CF2/CG2 (patch slot 2) if version & header checks pass 0x52 BRANCH Startup kernel/Hypervisor 0x53 DECRYT_VERIFY_HV_CERT Decrypt and verify hypervisor certificate CD 0xB1 PANIC - VERIFY_OFFSET CE decryption failed Panics 0xB2 PANIC - VERIFY_HEADER Failed to verify CE header 0xB3 PANIC - SHA_VERIFY CE hash comparison fail 0xB4 PANIC - LZX_EXPAND CE LZX decompression failed 0xB5 PANIC - VERIFY_OFFSET_6BL CF verification failed 0xB6 PANIC - DECODE_FUSES Fuse decryption/check failed 0xB7 PANIC - UPDATE_MISSING CF decryption failed, patches missing. 0xB8 PANIC - CF hash auth failed CE 0xC1 LZX_EXPAND_1 LDICreateDecompression failed CF 0xC2 LZX_EXPAND_2 CG size verification failed Panics 0xC3 LZX_EXPAND_3 Header / patch fragment info check failed 0xC4 LZX_EXPAND_4 Unexpected LDI fragment type 0xC5 LZX_EXPAND_5 LDISetWindowData failed 0xC6 LZX_EXPAND_6 LDIDecompress failed 0xC7 LZX_EXPAND_7 LDIResetDecompression failed 0xC8 SHA_VERIFY CG auth failed Hypervisor 0x58 INIT_HYPERVISOR Hypervisor Initialization begin /HV 0x59 INIT_SOC_MMIO Initialize SoC MMIO 0x5A INIT_XEX_TRAINING Initialize XEX training 0x5B INIT_KEYRING Initialize key ring 0x5C INIT_KEYS Initialize keys 0x5D INIT_SOC_INT Initialize SoC Interrupts 0x5E INIT_SOC_INT_COMPLETE Initialization complete HV Panics 0xFF PANIC - FATAL Fatal error Kernel 0x60 INIT_KERNEL Initialize kernel 0x61 INIT_HAL_PHASE_0 Initialize hardware abstraction layer (phase 0) 0x62 INIT_PROCESS_OBJECTS Initialize process objects 0x63 INIT_KERNEL_DEBUGGER Initialize kernel debugger 0x64 INIT_MEMORY_MANAGER Initialize memory manager 0x65 INIT_STACKS Initialize stacks 0x66 INIT_OBJECT_SYSTEM Initialize object system 0x67 INIT_PHASE1_THREAD Initialize phase 1 thread 0x68 INIT_PROCESSORS Initialize processors 0x69 INIT_KEY_VAULT Initialize keyvault 0x6A INIT_HAL_PHASE_1 Initialize hardware abstraction layer (phase 1) 0x6B INIT_SFC_DRIVER Initialize SFC (Flash controller) 0x6C INIT_SECURITY Initialize security 0x6D INIT_KEY_EX_VAULT Initialize keyvault (extended portion) 0x6E INIT_SETTINGS Initialize settings 0x6F INIT_POWER_MODE Initialize power mode 0x70 INIT_VIDEO_DRIVER Initialize video driver 0x71 INIT_AUDIO_DRIVER Initialize audio driver 0x72 INIT_BOOT_ANIMATION Initialize boot animation + XMADecoder & XAudioRender Init 0x73 INIT_SATA_DRIVER Initialize SATA driver 0x74 INIT_SHADOWBOOT Initialize shadowboot 0x75 INIT_DUMP_SYSTEM Initialize dump system 0x76 INIT_SYSTEM_ROOT Initialize system root 0x77 INIT_OTHER_DRIVERS Initialize other drivers 0x78 INIT_STFS_DRIVER Initialize STFS driver 0x79 LOAD_XAM Load XAM","title":"Meaning of different POST Codes"},{"location":"POST/#credits","text":"Retrieved from (https://www.xdevwiki.tk/index.php?title=POST_Codes&oldid=156)","title":"Credits"},{"location":"Pin_Headers/","text":"There are ten sets of pin headers on the board. They are numbered according to the PCB sections (J X Y N ). ID #Pins Purpose J1D2 9 XDK Debug Header #2 J1F1 6 Southbridge LED Header J2B1 13 XDK Debug header J2D1 6 Southbridge Header J2D2 8 GPU Header J5C1 6 ANA Header J5C2 6 GPU SPI EEPROM Header J7F1 6 CPU SPI EEPROM Header J7G1 3 Aux Power Header J8C1 10 CPU JTAG Header J1D2, J2D1, J2D2 J1D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 Unknown 7 Unknown 8 GND Ground 9 GND Ground J2D1 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground J2D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground 7 Unknown 8 Unknown scheme: https://web.archive.org/web/20070320235201/http://people.zeelandnet.nl/kbgeldof/j2b1_conn.JPG Category:Xbox360_Hardware","title":"Pin Headers"},{"location":"Pin_Headers/#j1d2-j2d1-j2d2","text":"J1D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 Unknown 7 Unknown 8 GND Ground 9 GND Ground J2D1 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground J2D2 Pin Signal Description 1 Unknown 2 Unknown 3 Unknown 4 Unknown 5 Unknown 6 GND Ground 7 Unknown 8 Unknown scheme: https://web.archive.org/web/20070320235201/http://people.zeelandnet.nl/kbgeldof/j2b1_conn.JPG Category:Xbox360_Hardware","title":"J1D2, J2D1, J2D2"},{"location":"Play_and_Charge_Kit/","text":"The Play and Charge Kit is sold separately from the Xbox 360 Wireless Controller. It contains a rechargable battery pack and a USB cable which connects the controller to the console. Battery Pack The battery pack that comes with the Play amd Charge Kit contains 2 standard rechargable AA batteries soldered to a control circuit board with a 6-pin header. The pinout for the header is (left to right): Temp, P-/GND, SCK, SCA, P, VCC The SCK, SCA, GND, and VCC pins are connected to an AT24C04M 2-wire serial EEPROM chip. Presumably the controller checks the EEPROM to verify that the battery pack has been charged fewer than a factory-set number of times and stops charging if that number is exceeded. Category:Xbox360_Hardware","title":"Play and Charge Kit"},{"location":"Play_and_Charge_Kit/#battery-pack","text":"The battery pack that comes with the Play amd Charge Kit contains 2 standard rechargable AA batteries soldered to a control circuit board with a 6-pin header. The pinout for the header is (left to right): Temp, P-/GND, SCK, SCA, P, VCC The SCK, SCA, GND, and VCC pins are connected to an AT24C04M 2-wire serial EEPROM chip. Presumably the controller checks the EEPROM to verify that the battery pack has been charged fewer than a factory-set number of times and stops charging if that number is exceeded. Category:Xbox360_Hardware","title":"Battery Pack"},{"location":"Pong/","text":"General Info NFO Hi there Just for show you a small app i've made for Xbox 360, with the help of libxenon and SDL. The game of the year : PONG! :D Actually, no extra, we move to top/bottom and that's it. I add sound when i get bin2o working Input have bug (bottom key sometime not response) Video Category:Xbox360_Homebrew_Software","title":"Pong"},{"location":"Pong/#general-info","text":"","title":"General Info"},{"location":"Pong/#nfo","text":"Hi there Just for show you a small app i've made for Xbox 360, with the help of libxenon and SDL. The game of the year : PONG! :D Actually, no extra, we move to top/bottom and that's it. I add sound when i get bin2o working Input have bug (bottom key sometime not response)","title":"NFO"},{"location":"Pong/#video","text":"Category:Xbox360_Homebrew_Software","title":"Video"},{"location":"Pre-release_differences/","text":"Hardware Motherboard Extra unnamed header used for TITAN board, near ROL board connector. \\==TITAN Board== Some board used for CPU debugging (?) Has DIP switches which have unknown functions LED lights for indicating something DIP switches are set to 4 down, 3 up, 2 down, 1 down (from a china xedk), although this can be random. Flash Pre-1839 CPU key and 1BL key set to 00...00 (16 bytes of 00's) \\==Pre-1838== 1640 seems to include some strings to do with xshell \"\\Device\\Harddisk0\\Partition1\\dashboard.xbx\", \"\\Device\\Harddisk0\\Partition1\\xshell.xex\", 1746 doesn't have a single mention Bootloader names are different, instead of SB/SC/SD/SE/SF/SG it's S2/S3/S4/S5/S6/S7 Kernel seems to have version field blanked out in the SE section, and different magic bytes on decompression. ECC data is different: *2 bytes to indicate block number, but second byte has 0xF0 added to it, XOR that byte with 0xF0 to get true number Doesn't indicate where the FS blocks are Doesn't seem to have bad block management... probably does though Uses a whole different file system for storing the dashboard files, instead of SFCX it uses FATX Loads more files inside FATX NANDs: *drivers.xex *xnet.xex *xlivebase.xex *xgi.xex *uvbase.xex *musicplayer.xex (not sure if this is there normally) *gamercard.xex *gamercard.xzp *livecommon.xzp *spa.bin *common.xzp *huduiskin.xzp *processdump.xex *rrbkgnd.bmp *saferec.bmp *recovery.ttf \\=File Formats= Pre-1861 XEX1 format for xex files instead of XEX2... xorloser where are you? Pre-1839 Keyvault is different (e.g. console serial is 0x18 bytes?!) Keyvault also has different device keys, which stops wireless controllers from working Also, console security certificate is incomplete-ish: *Part number set to 12345678901 *No manufacturing date? *Console type is weird, 0x80000002, normally when it ends in 02 it's retail :S Category:Xbox360_Hardware Category:Xbox360 System Software","title":"Hardware"},{"location":"Pre-release_differences/#hardware","text":"","title":"Hardware"},{"location":"Pre-release_differences/#motherboard","text":"Extra unnamed header used for TITAN board, near ROL board connector. \\==TITAN Board== Some board used for CPU debugging (?) Has DIP switches which have unknown functions LED lights for indicating something DIP switches are set to 4 down, 3 up, 2 down, 1 down (from a china xedk), although this can be random.","title":"Motherboard"},{"location":"Pre-release_differences/#flash","text":"","title":"Flash"},{"location":"Pre-release_differences/#pre-1839","text":"CPU key and 1BL key set to 00...00 (16 bytes of 00's) \\==Pre-1838== 1640 seems to include some strings to do with xshell \"\\Device\\Harddisk0\\Partition1\\dashboard.xbx\", \"\\Device\\Harddisk0\\Partition1\\xshell.xex\", 1746 doesn't have a single mention Bootloader names are different, instead of SB/SC/SD/SE/SF/SG it's S2/S3/S4/S5/S6/S7 Kernel seems to have version field blanked out in the SE section, and different magic bytes on decompression. ECC data is different: *2 bytes to indicate block number, but second byte has 0xF0 added to it, XOR that byte with 0xF0 to get true number Doesn't indicate where the FS blocks are Doesn't seem to have bad block management... probably does though Uses a whole different file system for storing the dashboard files, instead of SFCX it uses FATX Loads more files inside FATX NANDs: *drivers.xex *xnet.xex *xlivebase.xex *xgi.xex *uvbase.xex *musicplayer.xex (not sure if this is there normally) *gamercard.xex *gamercard.xzp *livecommon.xzp *spa.bin *common.xzp *huduiskin.xzp *processdump.xex *rrbkgnd.bmp *saferec.bmp *recovery.ttf \\=File Formats=","title":"Pre-1839"},{"location":"Pre-release_differences/#pre-1861","text":"XEX1 format for xex files instead of XEX2... xorloser where are you?","title":"Pre-1861"},{"location":"Pre-release_differences/#pre-1839_1","text":"Keyvault is different (e.g. console serial is 0x18 bytes?!) Keyvault also has different device keys, which stops wireless controllers from working Also, console security certificate is incomplete-ish: *Part number set to 12345678901 *No manufacturing date? *Console type is weird, 0x80000002, normally when it ends in 02 it's retail :S Category:Xbox360_Hardware Category:Xbox360 System Software","title":"Pre-1839"},{"location":"Profile_Account/","text":"The Account file is a HMAC-RC4 encrypted file stored in profiles to hold things such as the profiles gamertag, PUID (Passport User ID), online key and more. Encryption The file is encrypted with a custom form of HMAC-RC4, which is handled by the XeKeysUnobfuscate function. The key differs between retail and development consoles and is stored in key index 0x19. Retail key 0xE1 0xBC 0x15 0x9C 0x73 0xB1 0xEA 0xE9 0xAB 0x31 0x70 0xF3 0xAD 0x47 0xEB 0xF3 Devkit key 0xDA 0xB6 0x9A 0xD9 0x8E 0x28 0x76 0x4F 0x97 0x7E 0xE2 0x48 0x7E 0x4F 0x3F 0x68 To decrypt the file: Copy the first 16 bytes of the file to a buffer. This is the HMAC-SHA1 hash of the file which is made using one of the keys above. Use HMAC-SHA1 on that buffer with a key from above to create the RC4 key, which is 0x10 bytes. Decrypt 8 bytes after the hash of the file (at offset 0x10) using RC4. This is the confounder. Decrypt 380 bytes after the confounder using RC4. This is the decrypted account data. Make a hash of the confounder and decrypted data using HMAC-SHA1 and a key above and compare it to the first 16 bytes of the file, if it doesn't match then the decryption failed. To encrypt the file: Copy the decrypted data to offset 0x18 Create a random 8 byte confounder and copy this to offset 0x10. Make a hash of the confounder and decrypted data using HMAC-SHA1 and a key above, resize it to 16 bytes and then copy that to the beginning of the file. Use HMAC-SHA1 on that hash with a key from above to create the RC4 key, which is 0x10 bytes. Encrypt 388 bytes from position 0x10 using RC4. Decrypted File Offset Length Type Information 0 4 UInt32 Reserved(Flags) 4 4 UInt32 LiveFlags 8 16 chars/32 bytes Unicode Gamertag 40 8 ulong XUID 48 4 UInt32 Cached User Flags 52 4 ASCII string Xbox Live Service Provider 56 4 PasscodeKeys[4] Passcode 60 20 ASCII string Online Domain 80 24 ASCII string Online Kerberos Realm 104 16 Bytes Online Key 120 114 ASCII string User Passport Membername 234 32 ASCII string User Passport Password 266 114 ASCII string Owner Passport Membername Note Last 3 not used anymore(if ever). Reserved(flags) Name Value Passcode Enabled 0x10000000 LIVE Enabled 0x20000000 Recovering 0x40000000 The flag at bit0 seems to be always set, not sure what it means though. Cached User Flags Bits Used Indices Field Name 0 Payment Instrument Credit Card 8-15 Country 16-19 Subscription Teir 24 Parental Controls Enabled 25-29 Language The other bits are used, I'm just not sure what they all represent. Passcode The passcode is made up of these bytes: Byte Button 0 Null 1 DPad Up 2 DPad Down 3 DPad Left 4 DPad Right 5 X 6 Y 7 A 8 B 9 Left Trigger 10 Right Trigger 11 Left Bumper 12 Right Bumper Note A and B are not valid for passwords. XUID public class XUID { public System.UInt64 Value; public XUID(System.UInt64 _Value) { Value = _Value; } public System.Boolean IsOfflineXuid { get { return (Value & 17293822569102704640L) == 16140901064495857664L; } } public System.Boolean IsOnline { get { return (Value & 18446462598732840960L) == 2533274790395904L; } } public System.Boolean IsTeam//Guess this is todo with devs { get { return (Value & 18374686479671624000L) == 18302628885633696000L; } } public System.Boolean IsValidXuid { get { return IsOfflineXuid != IsOnlineXuid; } } } Country public enum XboxLiveCountry { Albania = 2, Algeria = 0x1b, Argentina = 4, Armenia = 3, Australia = 6, Austria = 5, Azerbaijan = 7, Bahrain = 10, Belarus = 14, Belgium = 8, Belize = 15, Bolivia = 12, Brazil = 13, BruneiDarussalam = 11, Bulgaria = 9, Canada = 0x10, Chile = 0x13, China = 20, Colombia = 0x15, CostaRica = 0x16, Croatia = 0x29, CzechRepublic = 0x17, Denmark = 0x19, DominicanRepublic = 0x1a, Ecuador = 0x1c, Egypt = 30, ElSalvador = 0x5f, Estonia = 0x1d, FaroeIslands = 0x21, Finland = 0x20, France = 0x22, Georgia = 0x24, Germany = 0x18, Greece = 0x25, Guatemala = 0x26, Honduras = 40, HongKong = 0x27, Hungary = 0x2a, Iceland = 0x31, India = 0x2e, Indonesia = 0x2b, Iran = 0x30, Iraq = 0x2f, Ireland = 0x2c, Israel = 0x2d, Italy = 50, Jamaica = 0x33, Japan = 0x35, Jordan = 0x34, Kazakhstan = 0x3a, Kenya = 0x36, Korea = 0x38, Kuwait = 0x39, Kyrgyzstan = 0x37, Latvia = 0x3f, Lebanon = 0x3b, LibyanArabJamahiriya = 0x40, Liechtenstein = 60, Lithuania = 0x3d, Luxembourg = 0x3e, Macao = 0x45, Macedonia = 0x43, Malaysia = 0x48, Maldives = 70, Mexico = 0x47, Monaco = 0x42, Mongolia = 0x44, Morocco = 0x41, Netherlands = 0x4a, NewZealand = 0x4c, Nicaragua = 0x49, Norway = 0x4b, Oman = 0x4d, Pakistan = 0x51, Panama = 0x4e, Paraguay = 0x55, Peru = 0x4f, Philippines = 80, Poland = 0x52, Portugal = 0x54, PuertoRico = 0x53, Qatar = 0x56, Romania = 0x57, RussianFederation = 0x58, SaudiArabia = 0x59, Singapore = 0x5b, Slovakia = 0x5d, Slovenia = 0x5c, SouthAfrica = 0x6d, Spain = 0x1f, Sweden = 90, Switzerland = 0x12, SyrianArabRepublic = 0x60, Taiwan = 0x65, Thailand = 0x61, TrinidadAndTobago = 100, Tunisia = 0x62, Turkey = 0x63, Ukraine = 0x66, UnitedArabEmirates = 1, UnitedKingdom = 0x23, UnitedStates = 0x67, Unknown = 0, Uruguay = 0x68, Uzbekistan = 0x69, Venezuela = 0x6a, Vietnam = 0x6b, Yemen = 0x6c, Zimbabwe = 110 } SubscriptionTeir enum SubscriptionTeir { NoSubcription, Silver = 3, Gold = 6, FamilyGold = 9 }; Language enum ConsoleLanguage { None, English, Japanese, German, French, Spanish, Italian, Korean, TChinese, Portuguese, SChinese, Polish, Russian }; Category:Xbox360 System Software","title":"Profile Account"},{"location":"Profile_Account/#encryption","text":"The file is encrypted with a custom form of HMAC-RC4, which is handled by the XeKeysUnobfuscate function. The key differs between retail and development consoles and is stored in key index 0x19. Retail key 0xE1 0xBC 0x15 0x9C 0x73 0xB1 0xEA 0xE9 0xAB 0x31 0x70 0xF3 0xAD 0x47 0xEB 0xF3 Devkit key 0xDA 0xB6 0x9A 0xD9 0x8E 0x28 0x76 0x4F 0x97 0x7E 0xE2 0x48 0x7E 0x4F 0x3F 0x68 To decrypt the file: Copy the first 16 bytes of the file to a buffer. This is the HMAC-SHA1 hash of the file which is made using one of the keys above. Use HMAC-SHA1 on that buffer with a key from above to create the RC4 key, which is 0x10 bytes. Decrypt 8 bytes after the hash of the file (at offset 0x10) using RC4. This is the confounder. Decrypt 380 bytes after the confounder using RC4. This is the decrypted account data. Make a hash of the confounder and decrypted data using HMAC-SHA1 and a key above and compare it to the first 16 bytes of the file, if it doesn't match then the decryption failed. To encrypt the file: Copy the decrypted data to offset 0x18 Create a random 8 byte confounder and copy this to offset 0x10. Make a hash of the confounder and decrypted data using HMAC-SHA1 and a key above, resize it to 16 bytes and then copy that to the beginning of the file. Use HMAC-SHA1 on that hash with a key from above to create the RC4 key, which is 0x10 bytes. Encrypt 388 bytes from position 0x10 using RC4.","title":"Encryption"},{"location":"Profile_Account/#decrypted-file","text":"Offset Length Type Information 0 4 UInt32 Reserved(Flags) 4 4 UInt32 LiveFlags 8 16 chars/32 bytes Unicode Gamertag 40 8 ulong XUID 48 4 UInt32 Cached User Flags 52 4 ASCII string Xbox Live Service Provider 56 4 PasscodeKeys[4] Passcode 60 20 ASCII string Online Domain 80 24 ASCII string Online Kerberos Realm 104 16 Bytes Online Key 120 114 ASCII string User Passport Membername 234 32 ASCII string User Passport Password 266 114 ASCII string Owner Passport Membername Note Last 3 not used anymore(if ever).","title":"Decrypted File"},{"location":"Profile_Account/#reservedflags","text":"Name Value Passcode Enabled 0x10000000 LIVE Enabled 0x20000000 Recovering 0x40000000 The flag at bit0 seems to be always set, not sure what it means though.","title":"Reserved(flags)"},{"location":"Profile_Account/#cached-user-flags","text":"Bits Used Indices Field Name 0 Payment Instrument Credit Card 8-15 Country 16-19 Subscription Teir 24 Parental Controls Enabled 25-29 Language The other bits are used, I'm just not sure what they all represent.","title":"Cached User Flags"},{"location":"Profile_Account/#passcode","text":"The passcode is made up of these bytes: Byte Button 0 Null 1 DPad Up 2 DPad Down 3 DPad Left 4 DPad Right 5 X 6 Y 7 A 8 B 9 Left Trigger 10 Right Trigger 11 Left Bumper 12 Right Bumper Note A and B are not valid for passwords.","title":"Passcode"},{"location":"Profile_Account/#xuid","text":"public class XUID { public System.UInt64 Value; public XUID(System.UInt64 _Value) { Value = _Value; } public System.Boolean IsOfflineXuid { get { return (Value & 17293822569102704640L) == 16140901064495857664L; } } public System.Boolean IsOnline { get { return (Value & 18446462598732840960L) == 2533274790395904L; } } public System.Boolean IsTeam//Guess this is todo with devs { get { return (Value & 18374686479671624000L) == 18302628885633696000L; } } public System.Boolean IsValidXuid { get { return IsOfflineXuid != IsOnlineXuid; } } }","title":"XUID"},{"location":"Profile_Account/#country","text":"public enum XboxLiveCountry { Albania = 2, Algeria = 0x1b, Argentina = 4, Armenia = 3, Australia = 6, Austria = 5, Azerbaijan = 7, Bahrain = 10, Belarus = 14, Belgium = 8, Belize = 15, Bolivia = 12, Brazil = 13, BruneiDarussalam = 11, Bulgaria = 9, Canada = 0x10, Chile = 0x13, China = 20, Colombia = 0x15, CostaRica = 0x16, Croatia = 0x29, CzechRepublic = 0x17, Denmark = 0x19, DominicanRepublic = 0x1a, Ecuador = 0x1c, Egypt = 30, ElSalvador = 0x5f, Estonia = 0x1d, FaroeIslands = 0x21, Finland = 0x20, France = 0x22, Georgia = 0x24, Germany = 0x18, Greece = 0x25, Guatemala = 0x26, Honduras = 40, HongKong = 0x27, Hungary = 0x2a, Iceland = 0x31, India = 0x2e, Indonesia = 0x2b, Iran = 0x30, Iraq = 0x2f, Ireland = 0x2c, Israel = 0x2d, Italy = 50, Jamaica = 0x33, Japan = 0x35, Jordan = 0x34, Kazakhstan = 0x3a, Kenya = 0x36, Korea = 0x38, Kuwait = 0x39, Kyrgyzstan = 0x37, Latvia = 0x3f, Lebanon = 0x3b, LibyanArabJamahiriya = 0x40, Liechtenstein = 60, Lithuania = 0x3d, Luxembourg = 0x3e, Macao = 0x45, Macedonia = 0x43, Malaysia = 0x48, Maldives = 70, Mexico = 0x47, Monaco = 0x42, Mongolia = 0x44, Morocco = 0x41, Netherlands = 0x4a, NewZealand = 0x4c, Nicaragua = 0x49, Norway = 0x4b, Oman = 0x4d, Pakistan = 0x51, Panama = 0x4e, Paraguay = 0x55, Peru = 0x4f, Philippines = 80, Poland = 0x52, Portugal = 0x54, PuertoRico = 0x53, Qatar = 0x56, Romania = 0x57, RussianFederation = 0x58, SaudiArabia = 0x59, Singapore = 0x5b, Slovakia = 0x5d, Slovenia = 0x5c, SouthAfrica = 0x6d, Spain = 0x1f, Sweden = 90, Switzerland = 0x12, SyrianArabRepublic = 0x60, Taiwan = 0x65, Thailand = 0x61, TrinidadAndTobago = 100, Tunisia = 0x62, Turkey = 0x63, Ukraine = 0x66, UnitedArabEmirates = 1, UnitedKingdom = 0x23, UnitedStates = 0x67, Unknown = 0, Uruguay = 0x68, Uzbekistan = 0x69, Venezuela = 0x6a, Vietnam = 0x6b, Yemen = 0x6c, Zimbabwe = 110 }","title":"Country"},{"location":"Profile_Account/#subscriptionteir","text":"enum SubscriptionTeir { NoSubcription, Silver = 3, Gold = 6, FamilyGold = 9 };","title":"SubscriptionTeir"},{"location":"Profile_Account/#language","text":"enum ConsoleLanguage { None, English, Japanese, German, French, Spanish, Italian, Korean, TChinese, Portuguese, SChinese, Polish, Russian }; Category:Xbox360 System Software","title":"Language"},{"location":"R6T3/","text":"R6T3 is the label of a resistor on the mainboard of the Xbox 360, it supplies the necessary voltage for the Xenon (CPU) to burn the so-called eFuses . Burned eFuses prevent older firmwares (any older rev. than 4552) from running on your Xbox 360, thus eliminating the possibility to downgrade to an earlier version of the kernel. The Resistor itself is located in the field T-6. It is a 10k Ohm (10,000 Ohm) SMT resistor (Case 0402) functioning as part of a current limiting circuit. The eFuse circuit uses a dual BJT array part MBT3904 . The datasheet says: Q1 has Pin 3 - collector Pin 4 - emmiter PIn 5 - base Q2 has Pin 1 - emmiter Pin 2 - base PIn 6 - collector From looking at the board traces, R6T3 is the collector resistor to Q2. The collector pin enables the LDO that provides the voltage for the eFuse burning. The base of Q2 is tied to the collector of Q1. When Q2 is on, the voltage at the collector is logic LO and the LDO is disabled (logic LO at the enable pin). Q2 turns on when the base is logic HI, which means Q1 must be off, so the voltage will pull high through the Q1 collector resistor. Important Note The removal of R6T3 will cause an E80 system error if the NXE update is installed. Replacing the resistor with the original or with another 10K Ohm resistor usually fixes the error state. Given the difficulty in surface mounting a resistor as small as R6T3, simply holding a 10K Ohm in place while the 360 is powering up after giving a E80 will typically allow normal operation from then on. Care must be taken not to bridge the gap without a resistor in place as this may cause system damage. Alternative to Removing R6T3 For people who find removing R6T3 too difficult can follow one of the two solution: if U6T1 is present if U6T2 is present Shorting pin 6 to pin 1 (C to E) of the transistor pack, or pin 6 (C) to any conveniant ground. Thats only one jumper, ena pin cant go hi, since its grounded. External Links Just discussing possible alternatives to removing R6T3 at XboxHacker HIGH RES R6T3 IMAGE Slim Version The slim version of R6T3 on the trinity motherboard is R4R1. It is located right next to the x-clamp on the bottom of the motherboard. Some people have reported removing the resistor will not throw an error on startup, but will throw an error if the console tries to update. Category:Xbox360_Hardware","title":"R6T3"},{"location":"R6T3/#important-note","text":"The removal of R6T3 will cause an E80 system error if the NXE update is installed. Replacing the resistor with the original or with another 10K Ohm resistor usually fixes the error state. Given the difficulty in surface mounting a resistor as small as R6T3, simply holding a 10K Ohm in place while the 360 is powering up after giving a E80 will typically allow normal operation from then on. Care must be taken not to bridge the gap without a resistor in place as this may cause system damage.","title":"Important Note"},{"location":"R6T3/#alternative-to-removing-r6t3","text":"For people who find removing R6T3 too difficult can follow one of the two solution: if U6T1 is present if U6T2 is present Shorting pin 6 to pin 1 (C to E) of the transistor pack, or pin 6 (C) to any conveniant ground. Thats only one jumper, ena pin cant go hi, since its grounded.","title":"Alternative to Removing R6T3"},{"location":"R6T3/#external-links","text":"Just discussing possible alternatives to removing R6T3 at XboxHacker HIGH RES R6T3 IMAGE","title":"External Links"},{"location":"R6T3/#slim-version","text":"The slim version of R6T3 on the trinity motherboard is R4R1. It is located right next to the x-clamp on the bottom of the motherboard. Some people have reported removing the resistor will not throw an error on startup, but will throw an error if the console tries to update. Category:Xbox360_Hardware","title":"Slim Version"},{"location":"RF_Module/","text":"The RF module is believed to be based on DECT technology: 1 (Dutch) Chips on the RF module: :*Backside: ::*ATMEL528 24C04N I2C EEPROM ::*MS VS55RC :*Frontside (Under metal shield): ::*MS VS55RB The RF Module also contains 4 red/green leds, 1 green led in the middle of the power button, 1 switch. The multi color leds are connected to the MS V55RC via resistors. The switch and the center led are connected to D8, a 1x2mm 6pin device (diode?). The VS55RB probably also performs some power management functions. It is possible to switch the box on via the wireless controllers, so the wireless part will need to be powered when the Xbox is switched off. The layout of the connectors is as follows: 3.3v usb usb gnd pon fb1 fb2 gnd TP17 The two usb wires are connected to the southbridge. fb1 and fb2 ('front bus') form a slow serial bus, something like I2C but different: the bit numbers don't match and the start and stop conditions are different. These can be used to control the leds: for examble without AV cable, there is no USB activity on boot, but there is on this front bus. Whether the leds can be controlled by USB as well is unsure. Pon is a active low signal which goes low by pressing the power button. Perhaps also controlled by pressing the on function on wireless controllers. TP17 is an unknown signal, connected to test pin TP17 on the RF module pcb Category:Xbox360_Hardware","title":"RF Module"},{"location":"Rawflash/","text":"General Info NFO place \"nandflash.bin\" on the root of a usb device start 2stage xell and shut off when prompted (replug power if you changed SMC) - by default it checks blocks before writing, and will NOT overwrite or erase any block with ecc/other issues (perfect for *** images with auto remaps) small change to libxenon was required to silence non-error messages tested on falcon, trinity and jasper 256 v4: fix page offsets for bad block checks on big blocks (fixes problems when nandmu is present) v3: re-re-refix bad block skipping so it skips it in both the dump and flash instead of just in the dump v2: add big block support v1: initial version Category:Xbox360_Homebrew_Software","title":"Rawflash"},{"location":"Rawflash/#general-info","text":"","title":"General Info"},{"location":"Rawflash/#nfo","text":"place \"nandflash.bin\" on the root of a usb device start 2stage xell and shut off when prompted (replug power if you changed SMC) - by default it checks blocks before writing, and will NOT overwrite or erase any block with ecc/other issues (perfect for *** images with auto remaps) small change to libxenon was required to silence non-error messages tested on falcon, trinity and jasper 256 v4: fix page offsets for bad block checks on big blocks (fixes problems when nandmu is present) v3: re-re-refix bad block skipping so it skips it in both the dump and flash instead of just in the dump v2: add big block support v1: initial version Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Reading_Out_nand/","text":"REDIRECT NAND_Reading","title":"Reading Out nand"},{"location":"Reset_Glitch_Hack/","text":"The Xbox 360 reset glitch hack tmbinc said it himself, software based approaches of running unsigned code on the 360 mostly don't work, it was designed to be secure from a software point of view. The processor starts running code from ROM (1bl) , which then starts loading a RSA signed and RC4 crypted piece of code from NAND (CB). CB then initialises the processor security engine, its task will be to do real time encryption and hash check of physical DRAM memory. From what we found, it's using AES128 for crypto and strong (Toeplitz ?) hashing. The crypto is different each boot because it is seeded at least from: A hash of the entire fuseset. The timebase counter value. A truly random value that comes from the hardware random number generator the processor embeds. on fats, that RNG could be electronically deactivated, but there's a check for \"apparent randomness\" (merely a count of 1 bits) in CB, it just waits for a seemingly proper random number. CB can then run some kind of simple bytecode based software engine whose task will mainly be to initialise DRAM, CB can then load the next bootloader (CD) from NAND into it, and run it. Basically, CD will load a base kernel from NAND, patch it and run it. That kernel contains a small privileged piece of code (hypervisor), when the console runs, this is the only code that would have enough rights to run unsigned code. In kernel versions 4532/4548, a critical flaw in it appeared, and all known 360 hacks needed to run one of those kernels and exploit that flaw to run unsigned code. On current 360s, CD contains a hash of those 2 kernels and will stop the boot process if you try to load them. The hypervisor is a relatively small piece of code to check for flaws and apparently no newer ones has any flaws that could allow running unsigned code. On the other hand, tmbinc said the 360 wasn't designed to withstand certain hardware attacks such as the timing attack and \"glitching\". Glitching here is basically the process of triggering processor bugs by electronical means. This is the way we used to be able to run unsigned code. The reset glitch in a few words We found that by sending a tiny reset pulse to the processor while it is slowed down does not reset it but instead changes the way the code runs, it seems it's very efficient at making bootloaders memcmp functions always return \"no differences\". memcmp is often used to check the next bootloader SHA hash against a stored one, allowing it to run if they are the same. So we can put a bootloader that would fail hash check in NAND, glitch the previous one and that bootloader will run, allowing almost any code to run. Details for the fat hack On fats, the bootloader we glitch is CB, so we can run the CD we want. cjak found that by asserting the CPU_PLL_BYPASS signal, the CPU clock is slowed down a lot, there's a test point on the motherboard that's a fraction of CPU speed, it's 200Mhz when the dash runs, 66.6Mhz when the console boots, and 520Khz when that signal is asserted. So it goes like that: We assert CPU_PLL_BYPASS around POST code 36 (hex). We wait for POST 39 start (POST 39 is the memcmp between stored hash and image hash), and start a counter. When that counter has reached a precise value (it's often around 62% of entire POST 39 length), we send a 100ns pulse on CPU_RESET. We wait some time and then we deassert CPU_PLL_BYPASS. The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error AD, the boot process continues and CB runs our custom CD. The NAND contains a zero-paired CB, our payload in a custom CD, and a modified SMC image. A glitch being unreliable by nature, we use a modified SMC image that reboots infinitely (ie stock images reboot 5 times and then go RROD) until the console has booted properly. In most cases, the glitch succeeds in less than 30 seconds from power on that way. Details for the slim hack The bootloader we glitch is CB_A, so we can run the CB_B we want. On slims, we weren't able to find a motherboard track for CPU_PLL_BYPASS. Our first idea was to remove the 27Mhz master 360 crystal and generate our own clock instead but it was a difficult modification and it didn't yield good results. We then looked for other ways to slow the CPU clock down and found that the HANA chip had configurable PLL registers for the 100Mhz clock that feeds CPU and GPU differential pairs. Apparently those registers are written by the SMC through an I2C bus. I2C bus can be freely accessed, it's even available on a header (J2C3). So the HANA chip will now become our weapon of choice to slow the CPU down (sorry tmbinc, you can't always be right, it isn't boring and it does sit on an interesting bus ;) So it goes like that: We send an i2c command to the HANA to slow down the CPU at POST code D8 . We wait for POST DA start (POST DA is the memcmp between stored hash and image hash), and start a counter. When that counter has reached a precise value, we send a 20ns pulse on CPU_RESET. We wait some time and then we send an i2c command to the HANA to restore regular CPU clock. The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error F2, the boot process continues and CB_A runs our custom CB_B. When CB_B starts, DRAM isn't initialised so we chose to only apply a few patches to it so that it can run any CD, the patches are: Always activate zero-paired mode, so that we can use a modified SMC image. Don't decrypt CD, instead expect a plaintext CD in NAND. Don't stop the boot process if CD hash isn't good. CB_B is RC4 crypted, the key comes from the CPU key, so how do we patch CB_B without knowing the CPU key? RC4 is basically: crypted = plaintext xor pseudo-random-keystream So if we know plaintext and crypted, we can get the keystream, and with the keystream, we can encrypt our own code. It goes like that: guessed-pseudo-random-keystream = crypted xor plaintext new-crypted = guessed-pseudo-random-keystream xor plaintext-patch You could think there's a chicken and egg problem, how did we get plaintext in the first place? Easy: we had plaintext CBs from fat consoles, and we thought the first few bytes of code would be the same as the new CB_B, so we could encrypt a tiny piece of code to dump the CPU key and decrypt CB_B! The NAND contains CB_A, a patched CB_B, our payload in a custom plaintext CD, and a modified SMC image. The SMC image is modified to have infinite reboot, and to prevent it from periodically sending I2C commands while we send ours. Now, maybe you haven't realised yet, but CB_A contains no checks on revocation fuses, so it's an unpatchable hack ! Caveats Nothing is ever perfect, so there are a few caveats to that hack: Even in the glitch we found is pretty reliable (25% success rate per try on average), it can take up to a few minutes to boot to unsigned code. That success rate seems to depend on something like the hash of the modified bootloader we want to run (CD for fats and CB_B for slims). It requires precise and fast hardware to be able to send the reset pulse. Our current implementation We used a Xilinx CoolRunner II CPLD (xc2c64a) board, because it's fast, precise, updatable, cheap and can work with 2 different voltage levels at the same time. We use the 48Mhz standby clock from the 360 for the glitch counter. For the slim hack, the counter even runs at 96Mhz (incremented on rising and falling edges of clock) The cpld code is written in VHDL. We need it to be aware of the current POST code, our first implementations used the whole 8 bits POST port for this, but we are now able to detect the changes of only 1 POST bit, making wiring easier. Finding the right timing Getting memcmp POST length in ticks First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check. An ARM7 based Olimex LPC-H2148 was used for this task. It could look like that: for(;;) { post = post_read(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); while( post_read() == MEMCMP_POST ); memcmp_post_length=get_tick()-t_start; print(memcmp_post_length); } prev_post=post; } Make sure you note memcmp post length ;) Using random timing over the full POST length Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length. It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = rand() % MEMCMP_POST_LENGTH; while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly. Make sure you note the timing that glitched ;) Refining the timing, accounting for bell-like curve So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = PREV_GLITCH_TIMING - 50 + (rand() % 100); while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve. Make sure ... you got it ;) PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity. Conclusion We tried not to include any MS copyrighted code in the released hack tools. The purpose of this hack is to run Xell and other free software, I (GliGli) did NOT do it to promote piracy or anything related, I just want to be able to do whatever I want with the hardware I bought, including running my own native code on it. HowTo (for slims) Required Software and Hardware Prerequisites Installed Xilinx Lab Tools Software Python and Pyton Crypto Impact (from Xilinx Lab Tools) NandPro (>= v2.0e) Hardware USB SPI Programmer to dump/flash the Xbox360's NAND XC2C64A CoolRunner-II CPLD (aka Digilent C-mod) Socket for the CPLD XilinX JTAG Programmer cable 1x 220pF capacitor Soldering material Dumping NAND Use the following diagram to solder your USB SPI Programmer to the Xbo360 motherboard. Open windows' command prompt and launch NandPro . Dump your nand twice by using the read command for 16MB NAND : nandpro usb : -r16 nanddumpname.bin Compare the two dumps with the following command (you canuse MD5 Checksums too) : fc /b nanddumpname.bin nanddumpname2.bin You should see something like FC : No difference found . If the two dumps don't match, do a new dump and check again. Installation of Python and Python Crypto Install Python 2.7 (32bit!) with the default settings : Install PyCrypto 2.3 with the default settings : To enable python in windows' command prompt, we will have to modify the environment variables . Go in Control Panel > System > Advanced system settings Click on environnement variables Click on new in system variable Add this for the name and the value of the variable : PYTHONPATH %PYTHONPATH%;C:\\Python2.7 ; Creating the Hackimage Download the gggggg-hack (Free60-Git Repository). Put your original NAND dump in the root of the gggggg-folder and create an create a folder named \" ouput \" (in the root aswell). Open windows' command prompt again and navigate to the gggggg-folder , then type this python command (don't forget to modify it with your NAND dump name) : python common\\imgbuild\\build.py nanddumpname.bin common\\cdxell\\CD common\\xell\\xell-gggggg.bin You should see the following The file image_00000000.ecc is located in the output folder now. Copy this file into your nandpro folder and navigate to the folder via commandprompt again Use the following command to flash the image to your console's NAND. nandpro usb : +w16 image_00000000.ecc /!\\ Pay attention that you have to use the +w16 switch and not the -w16 one /!\\ The flashed file has a size of 50 blocks so you should see 004F when the flashing is done. Programming the CPLD Power your CPLD with 3.3V on pin 20 and GND on pin 21 . There are many solution to do this ... here are some of them : Use an old DVD drive supply cable by cutting 5 and 6 cable (3.3V and GND) and connect it to the a CK or the motherboard drive socket OR Solder the pin 20 to the J2C1.8 point of the motherboard and pin 21 (GND) to a point of the motherboard like the legs of the various connector-metalcasing. Grab your LPT/USB XilinX JTAG programmer cable. Connect the cable to the PC and the CPLD . (If you don't have one, you can use GliGli's schematic to build a LPT JTAG Programmer) Launch \"iMPACT\" (from XilinX Lab Tools) and let's start the programming ... just follow the images. (You have to setup the compatibility mode only if your Programmer does not get detected right away) Wiring On the CPLD, remove the Resistor R2 and connect R2's upper pad to R1's lower pad . Place the CPLD on the motherboard like you see on the picture. We recommend to use double coated tape + material to isolate the CPLD . Use the following diagram to solder all needed connections. It's recommended to use a socket! ENJOY You can now start your console normally and see XeLL boot within 2 minutes. You can now enjoy unsigned code on your slim . CREDITS / THANKS GliGli, Tiros: Reverse engineering and hack development. cOz: Reverse engineering, beta testing. Razkar, tuxuser, Ced2911: beta testing. cjak, Redline99, SeventhSon, tmbinc, anyone I forgot... : Prior reverse engineering and/or hacking work on the 360. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"The Xbox 360 reset glitch hack"},{"location":"Reset_Glitch_Hack/#the-xbox-360-reset-glitch-hack","text":"tmbinc said it himself, software based approaches of running unsigned code on the 360 mostly don't work, it was designed to be secure from a software point of view. The processor starts running code from ROM (1bl) , which then starts loading a RSA signed and RC4 crypted piece of code from NAND (CB). CB then initialises the processor security engine, its task will be to do real time encryption and hash check of physical DRAM memory. From what we found, it's using AES128 for crypto and strong (Toeplitz ?) hashing. The crypto is different each boot because it is seeded at least from: A hash of the entire fuseset. The timebase counter value. A truly random value that comes from the hardware random number generator the processor embeds. on fats, that RNG could be electronically deactivated, but there's a check for \"apparent randomness\" (merely a count of 1 bits) in CB, it just waits for a seemingly proper random number. CB can then run some kind of simple bytecode based software engine whose task will mainly be to initialise DRAM, CB can then load the next bootloader (CD) from NAND into it, and run it. Basically, CD will load a base kernel from NAND, patch it and run it. That kernel contains a small privileged piece of code (hypervisor), when the console runs, this is the only code that would have enough rights to run unsigned code. In kernel versions 4532/4548, a critical flaw in it appeared, and all known 360 hacks needed to run one of those kernels and exploit that flaw to run unsigned code. On current 360s, CD contains a hash of those 2 kernels and will stop the boot process if you try to load them. The hypervisor is a relatively small piece of code to check for flaws and apparently no newer ones has any flaws that could allow running unsigned code. On the other hand, tmbinc said the 360 wasn't designed to withstand certain hardware attacks such as the timing attack and \"glitching\". Glitching here is basically the process of triggering processor bugs by electronical means. This is the way we used to be able to run unsigned code.","title":"The Xbox 360 reset glitch hack"},{"location":"Reset_Glitch_Hack/#the-reset-glitch-in-a-few-words","text":"We found that by sending a tiny reset pulse to the processor while it is slowed down does not reset it but instead changes the way the code runs, it seems it's very efficient at making bootloaders memcmp functions always return \"no differences\". memcmp is often used to check the next bootloader SHA hash against a stored one, allowing it to run if they are the same. So we can put a bootloader that would fail hash check in NAND, glitch the previous one and that bootloader will run, allowing almost any code to run.","title":"The reset glitch in a few words"},{"location":"Reset_Glitch_Hack/#details-for-the-fat-hack","text":"On fats, the bootloader we glitch is CB, so we can run the CD we want. cjak found that by asserting the CPU_PLL_BYPASS signal, the CPU clock is slowed down a lot, there's a test point on the motherboard that's a fraction of CPU speed, it's 200Mhz when the dash runs, 66.6Mhz when the console boots, and 520Khz when that signal is asserted. So it goes like that: We assert CPU_PLL_BYPASS around POST code 36 (hex). We wait for POST 39 start (POST 39 is the memcmp between stored hash and image hash), and start a counter. When that counter has reached a precise value (it's often around 62% of entire POST 39 length), we send a 100ns pulse on CPU_RESET. We wait some time and then we deassert CPU_PLL_BYPASS. The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error AD, the boot process continues and CB runs our custom CD. The NAND contains a zero-paired CB, our payload in a custom CD, and a modified SMC image. A glitch being unreliable by nature, we use a modified SMC image that reboots infinitely (ie stock images reboot 5 times and then go RROD) until the console has booted properly. In most cases, the glitch succeeds in less than 30 seconds from power on that way.","title":"Details for the fat hack"},{"location":"Reset_Glitch_Hack/#details-for-the-slim-hack","text":"The bootloader we glitch is CB_A, so we can run the CB_B we want. On slims, we weren't able to find a motherboard track for CPU_PLL_BYPASS. Our first idea was to remove the 27Mhz master 360 crystal and generate our own clock instead but it was a difficult modification and it didn't yield good results. We then looked for other ways to slow the CPU clock down and found that the HANA chip had configurable PLL registers for the 100Mhz clock that feeds CPU and GPU differential pairs. Apparently those registers are written by the SMC through an I2C bus. I2C bus can be freely accessed, it's even available on a header (J2C3). So the HANA chip will now become our weapon of choice to slow the CPU down (sorry tmbinc, you can't always be right, it isn't boring and it does sit on an interesting bus ;) So it goes like that: We send an i2c command to the HANA to slow down the CPU at POST code D8 . We wait for POST DA start (POST DA is the memcmp between stored hash and image hash), and start a counter. When that counter has reached a precise value, we send a 20ns pulse on CPU_RESET. We wait some time and then we send an i2c command to the HANA to restore regular CPU clock. The cpu speed goes back to normal, and with a bit of luck, instead of getting POST error F2, the boot process continues and CB_A runs our custom CB_B. When CB_B starts, DRAM isn't initialised so we chose to only apply a few patches to it so that it can run any CD, the patches are: Always activate zero-paired mode, so that we can use a modified SMC image. Don't decrypt CD, instead expect a plaintext CD in NAND. Don't stop the boot process if CD hash isn't good. CB_B is RC4 crypted, the key comes from the CPU key, so how do we patch CB_B without knowing the CPU key? RC4 is basically: crypted = plaintext xor pseudo-random-keystream So if we know plaintext and crypted, we can get the keystream, and with the keystream, we can encrypt our own code. It goes like that: guessed-pseudo-random-keystream = crypted xor plaintext new-crypted = guessed-pseudo-random-keystream xor plaintext-patch You could think there's a chicken and egg problem, how did we get plaintext in the first place? Easy: we had plaintext CBs from fat consoles, and we thought the first few bytes of code would be the same as the new CB_B, so we could encrypt a tiny piece of code to dump the CPU key and decrypt CB_B! The NAND contains CB_A, a patched CB_B, our payload in a custom plaintext CD, and a modified SMC image. The SMC image is modified to have infinite reboot, and to prevent it from periodically sending I2C commands while we send ours. Now, maybe you haven't realised yet, but CB_A contains no checks on revocation fuses, so it's an unpatchable hack !","title":"Details for the slim hack"},{"location":"Reset_Glitch_Hack/#caveats","text":"Nothing is ever perfect, so there are a few caveats to that hack: Even in the glitch we found is pretty reliable (25% success rate per try on average), it can take up to a few minutes to boot to unsigned code. That success rate seems to depend on something like the hash of the modified bootloader we want to run (CD for fats and CB_B for slims). It requires precise and fast hardware to be able to send the reset pulse.","title":"Caveats"},{"location":"Reset_Glitch_Hack/#our-current-implementation","text":"We used a Xilinx CoolRunner II CPLD (xc2c64a) board, because it's fast, precise, updatable, cheap and can work with 2 different voltage levels at the same time. We use the 48Mhz standby clock from the 360 for the glitch counter. For the slim hack, the counter even runs at 96Mhz (incremented on rising and falling edges of clock) The cpld code is written in VHDL. We need it to be aware of the current POST code, our first implementations used the whole 8 bits POST port for this, but we are now able to detect the changes of only 1 POST bit, making wiring easier.","title":"Our current implementation"},{"location":"Reset_Glitch_Hack/#finding-the-right-timing","text":"","title":"Finding the right timing"},{"location":"Reset_Glitch_Hack/#getting-memcmp-post-length-in-ticks","text":"First step is to know how long the memcmp POST will last while slowed down. No reset pulse should be sent for this. Using hardware that can read the POST bus and measure time in a precise way, measure the time between memcmp POST start and 'hash compare failed' final POST (eg on fats, between POST 39 and POST AD) with the next bootloader failing hash check. An ARM7 based Olimex LPC-H2148 was used for this task. It could look like that: for(;;) { post = post_read(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); while( post_read() == MEMCMP_POST ); memcmp_post_length=get_tick()-t_start; print(memcmp_post_length); } prev_post=post; } Make sure you note memcmp post length ;)","title":"Getting memcmp POST length in ticks"},{"location":"Reset_Glitch_Hack/#using-random-timing-over-the-full-post-length","text":"Now you need the hardware to send a reset pulse after a random amount of time in memcmp POST, but no more than previously found memcmp POST length. It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = rand() % MEMCMP_POST_LENGTH; while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } Using a hacked smc that reboots infinitely it will take a good amount of time, but it should end up glitching properly. Make sure you note the timing that glitched ;)","title":"Using random timing over the full POST length"},{"location":"Reset_Glitch_Hack/#refining-the-timing-accounting-for-bell-like-curve","text":"So now we have one timing that glitches, but we don't know if it's really the 'sweet spot' or if we were just lucky. What needs to be done now is to get the timing of some more successes, I think it's safe to use a smaller random range around previously found glitch timing. my get_tick() function runs at 60Mhz, I found it was safe to make the range -+50 ticks around previously found glitch timing It could look like that: for(;;) { post = read_post(); if (post == prev_post) then continue; if(post == MEMCMP_POST) { t_start = get_tick(); t_rand = PREV_GLITCH_TIMING - 50 + (rand() % 100); while( get_tick()< t_start+t_rand ); ppc_send_reset_pulse(); print(t_rand); } prev_post=post; } You'll need the timing of at least 20-30 successes. Averaging those timings should give you the sweet spot (aka final timing), because empirically we found that success rate vs timing is a bell-like curve. Make sure ... you got it ;) PS: Those pseudo-code examples don't show the slowdown code for the sake of clarity.","title":"Refining the timing, accounting for bell-like curve"},{"location":"Reset_Glitch_Hack/#conclusion","text":"We tried not to include any MS copyrighted code in the released hack tools. The purpose of this hack is to run Xell and other free software, I (GliGli) did NOT do it to promote piracy or anything related, I just want to be able to do whatever I want with the hardware I bought, including running my own native code on it.","title":"Conclusion"},{"location":"Reset_Glitch_Hack/#howto-for-slims","text":"","title":"HowTo (for slims)"},{"location":"Reset_Glitch_Hack/#required-software-and-hardware","text":"","title":"Required Software and Hardware"},{"location":"Reset_Glitch_Hack/#prerequisites","text":"Installed Xilinx Lab Tools","title":"Prerequisites"},{"location":"Reset_Glitch_Hack/#software","text":"Python and Pyton Crypto Impact (from Xilinx Lab Tools) NandPro (>= v2.0e)","title":"Software"},{"location":"Reset_Glitch_Hack/#hardware","text":"USB SPI Programmer to dump/flash the Xbox360's NAND XC2C64A CoolRunner-II CPLD (aka Digilent C-mod) Socket for the CPLD XilinX JTAG Programmer cable 1x 220pF capacitor Soldering material","title":"Hardware"},{"location":"Reset_Glitch_Hack/#dumping-nand","text":"Use the following diagram to solder your USB SPI Programmer to the Xbo360 motherboard. Open windows' command prompt and launch NandPro . Dump your nand twice by using the read command for 16MB NAND : nandpro usb : -r16 nanddumpname.bin Compare the two dumps with the following command (you canuse MD5 Checksums too) : fc /b nanddumpname.bin nanddumpname2.bin You should see something like FC : No difference found . If the two dumps don't match, do a new dump and check again.","title":"Dumping NAND"},{"location":"Reset_Glitch_Hack/#installation-of-python-and-python-crypto","text":"Install Python 2.7 (32bit!) with the default settings : Install PyCrypto 2.3 with the default settings : To enable python in windows' command prompt, we will have to modify the environment variables . Go in Control Panel > System > Advanced system settings Click on environnement variables Click on new in system variable Add this for the name and the value of the variable : PYTHONPATH %PYTHONPATH%;C:\\Python2.7 ;","title":"Installation of Python and Python Crypto"},{"location":"Reset_Glitch_Hack/#creating-the-hackimage","text":"Download the gggggg-hack (Free60-Git Repository). Put your original NAND dump in the root of the gggggg-folder and create an create a folder named \" ouput \" (in the root aswell). Open windows' command prompt again and navigate to the gggggg-folder , then type this python command (don't forget to modify it with your NAND dump name) : python common\\imgbuild\\build.py nanddumpname.bin common\\cdxell\\CD common\\xell\\xell-gggggg.bin You should see the following The file image_00000000.ecc is located in the output folder now. Copy this file into your nandpro folder and navigate to the folder via commandprompt again Use the following command to flash the image to your console's NAND. nandpro usb : +w16 image_00000000.ecc /!\\ Pay attention that you have to use the +w16 switch and not the -w16 one /!\\ The flashed file has a size of 50 blocks so you should see 004F when the flashing is done.","title":"Creating the Hackimage"},{"location":"Reset_Glitch_Hack/#programming-the-cpld","text":"Power your CPLD with 3.3V on pin 20 and GND on pin 21 . There are many solution to do this ... here are some of them : Use an old DVD drive supply cable by cutting 5 and 6 cable (3.3V and GND) and connect it to the a CK or the motherboard drive socket OR Solder the pin 20 to the J2C1.8 point of the motherboard and pin 21 (GND) to a point of the motherboard like the legs of the various connector-metalcasing. Grab your LPT/USB XilinX JTAG programmer cable. Connect the cable to the PC and the CPLD . (If you don't have one, you can use GliGli's schematic to build a LPT JTAG Programmer) Launch \"iMPACT\" (from XilinX Lab Tools) and let's start the programming ... just follow the images. (You have to setup the compatibility mode only if your Programmer does not get detected right away)","title":"Programming the CPLD"},{"location":"Reset_Glitch_Hack/#wiring","text":"On the CPLD, remove the Resistor R2 and connect R2's upper pad to R1's lower pad . Place the CPLD on the motherboard like you see on the picture. We recommend to use double coated tape + material to isolate the CPLD . Use the following diagram to solder all needed connections. It's recommended to use a socket!","title":"Wiring"},{"location":"Reset_Glitch_Hack/#enjoy","text":"You can now start your console normally and see XeLL boot within 2 minutes. You can now enjoy unsigned code on your slim .","title":"ENJOY"},{"location":"Reset_Glitch_Hack/#credits-thanks","text":"GliGli, Tiros: Reverse engineering and hack development. cOz: Reverse engineering, beta testing. Razkar, tuxuser, Ced2911: beta testing. cjak, Redline99, SeventhSon, tmbinc, anyone I forgot... : Prior reverse engineering and/or hacking work on the 360. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"CREDITS / THANKS"},{"location":"Reversing_the_bootloaders/","text":"Since there seems to be little to none documentation about this so I've decided to write up a guide to help all the up-and-coming hackers in the scene. Requirements IDA Pro (This costs money, it's recommended you buy a license) PPC Altivec plugin (ver. 1.8 is recommended) Decrypted loader (1BL/CB(_A)/CB_B/CD/CF) Kernel with symbols, find this at usual places (Also, match these up by the date modified and put the pdb in same folder as exe) Reversing Finding the entrypoint The entrypoint of the loader is located at offset 0x8-0xC in the loader header , once you've found the entrypoint the reversing can begin. Analyzing the loader Open the loader in IDA Pro and make sure it's loading as a binary file with the processor type set to PowerPC: ppc. Once you've done that a dialog should appear asking if you want it to be mapped to ROM or RAM, leave this screen as it is and just press OK. IDA will then notify you that since it's a binary file the entrypoint is unknown, so press G to show the go to address screen and put in the entrypoint you found earlier. Press C to turn this entrypoint into code and start IDA's analysis. This should only take a few seconds and then the entire bootloader should be fully analyzed. Finding functions I wasn't going to post this publicly for fear of MS updating their bootloaders to use different code, but I realized that keeping info back is for kids. Thankfully Microsoft use the same code for the most of the functions in the bootloaders as they do in the kernel, if you have a copy of the kernel and symbols (available in certain private SDKs..) you can just find the functions in the kernel, copy the hex code for them (make sure none of the branch instructions are in the code, as these use static offsets) and search for that hex in the bootloader. If you've done it correctly you should come across code in the bootloader which looks near identical to the code in the kernel. Just rename the sub to what it's called in the kernel and you've successfully \"reversed\" a section of the bootloader :D (also, before anyone complains to me about this I know this is the \"noob\" way of doing it, but its much easier then having to trawl through code) Functions used by the bootloaders Note, this list is incomplete, I've only included functions used for authentication/decompression here, also some loaders don't include all these functions. LDICreateDecompression LDIDecompress LZX_Decode LZX_DecodeInit LZX_DecodeNewGroup XeCryptBnDw_Copy XeCryptBnQwBeSigDifference XeCryptBnQwBeSigFormat XeCryptBnQwNeCompare XeCryptBnQwNeModInv XeCryptBnQwNeModMul XeCryptBnQw_Copy XeCryptHmacSha XeCryptHmacShaFinal XeCryptHmacShaInit XeCryptMemDiff XeCryptRc4Ecb XeCryptRc4Key XeCryptRotSum XeCryptRotSumSha XeCryptShaFinal XeCryptShaInit XeCryptShaTransform XeCryptShaUpdate Finding authentication procedures Almost all the authentication subs in the bootloaders use XeCryptRotSumSha, once you've managed to find that function you can just do \"Jump to xref to operand...\" to find them. The bootloader decryption routines all use XeCryptRc4Ecb, if you find that you can find the decryption routines quite easily. Tips If you see the value 0x3C0030 in the function, this is used during CF decryption/authentication. You've just found the function used to decrypt/auth CF. li r3, 0 is used to return that the decryption/auth failed, if theres any branches to code which has this then that means the branch is only used if a check fails, if you want to make it so you can run the next bootloader unauthenticated you could just nop (60 00 00 00) out all the branches to this code. Patching the call to XeCryptRc4Ecb with nop will disable encryption for the next loader, this is what the glitch hack build.py does to the CB_B of slims, along with patching out the branch to the panic function. All of the bootloaders have a function to handle post output during boot. If you find that function, you can follow its references and use the post codes from POST to step through each bootloader and figure out what each one is doing. Please keep in mind that the newest versions of the bootloaders had their post codes removed due to the RGH hack relying on them. Code Snippets panic panic: li r0, 0 # Load Immediate mtspr CTRL, r0 # Move to sprg, b panic # Branch post output #Sends the lowest byte of r4 to the post buffer post: sldi r4, r4, 56 std r4, 0(r3) blr Reversed Bootloaders The following bootloaders have already been reversed and posted: 1bl Code CB Code","title":"Reversing the bootloaders"},{"location":"Reversing_the_bootloaders/#requirements","text":"IDA Pro (This costs money, it's recommended you buy a license) PPC Altivec plugin (ver. 1.8 is recommended) Decrypted loader (1BL/CB(_A)/CB_B/CD/CF) Kernel with symbols, find this at usual places (Also, match these up by the date modified and put the pdb in same folder as exe)","title":"Requirements"},{"location":"Reversing_the_bootloaders/#reversing","text":"","title":"Reversing"},{"location":"Reversing_the_bootloaders/#finding-the-entrypoint","text":"The entrypoint of the loader is located at offset 0x8-0xC in the loader header , once you've found the entrypoint the reversing can begin.","title":"Finding the entrypoint"},{"location":"Reversing_the_bootloaders/#analyzing-the-loader","text":"Open the loader in IDA Pro and make sure it's loading as a binary file with the processor type set to PowerPC: ppc. Once you've done that a dialog should appear asking if you want it to be mapped to ROM or RAM, leave this screen as it is and just press OK. IDA will then notify you that since it's a binary file the entrypoint is unknown, so press G to show the go to address screen and put in the entrypoint you found earlier. Press C to turn this entrypoint into code and start IDA's analysis. This should only take a few seconds and then the entire bootloader should be fully analyzed.","title":"Analyzing the loader"},{"location":"Reversing_the_bootloaders/#finding-functions","text":"I wasn't going to post this publicly for fear of MS updating their bootloaders to use different code, but I realized that keeping info back is for kids. Thankfully Microsoft use the same code for the most of the functions in the bootloaders as they do in the kernel, if you have a copy of the kernel and symbols (available in certain private SDKs..) you can just find the functions in the kernel, copy the hex code for them (make sure none of the branch instructions are in the code, as these use static offsets) and search for that hex in the bootloader. If you've done it correctly you should come across code in the bootloader which looks near identical to the code in the kernel. Just rename the sub to what it's called in the kernel and you've successfully \"reversed\" a section of the bootloader :D (also, before anyone complains to me about this I know this is the \"noob\" way of doing it, but its much easier then having to trawl through code)","title":"Finding functions"},{"location":"Reversing_the_bootloaders/#functions-used-by-the-bootloaders","text":"Note, this list is incomplete, I've only included functions used for authentication/decompression here, also some loaders don't include all these functions. LDICreateDecompression LDIDecompress LZX_Decode LZX_DecodeInit LZX_DecodeNewGroup XeCryptBnDw_Copy XeCryptBnQwBeSigDifference XeCryptBnQwBeSigFormat XeCryptBnQwNeCompare XeCryptBnQwNeModInv XeCryptBnQwNeModMul XeCryptBnQw_Copy XeCryptHmacSha XeCryptHmacShaFinal XeCryptHmacShaInit XeCryptMemDiff XeCryptRc4Ecb XeCryptRc4Key XeCryptRotSum XeCryptRotSumSha XeCryptShaFinal XeCryptShaInit XeCryptShaTransform XeCryptShaUpdate","title":"Functions used by the bootloaders"},{"location":"Reversing_the_bootloaders/#finding-authentication-procedures","text":"Almost all the authentication subs in the bootloaders use XeCryptRotSumSha, once you've managed to find that function you can just do \"Jump to xref to operand...\" to find them. The bootloader decryption routines all use XeCryptRc4Ecb, if you find that you can find the decryption routines quite easily.","title":"Finding authentication procedures"},{"location":"Reversing_the_bootloaders/#tips","text":"If you see the value 0x3C0030 in the function, this is used during CF decryption/authentication. You've just found the function used to decrypt/auth CF. li r3, 0 is used to return that the decryption/auth failed, if theres any branches to code which has this then that means the branch is only used if a check fails, if you want to make it so you can run the next bootloader unauthenticated you could just nop (60 00 00 00) out all the branches to this code. Patching the call to XeCryptRc4Ecb with nop will disable encryption for the next loader, this is what the glitch hack build.py does to the CB_B of slims, along with patching out the branch to the panic function. All of the bootloaders have a function to handle post output during boot. If you find that function, you can follow its references and use the post codes from POST to step through each bootloader and figure out what each one is doing. Please keep in mind that the newest versions of the bootloaders had their post codes removed due to the RGH hack relying on them.","title":"Tips"},{"location":"Reversing_the_bootloaders/#code-snippets","text":"","title":"Code Snippets"},{"location":"Reversing_the_bootloaders/#panic","text":"panic: li r0, 0 # Load Immediate mtspr CTRL, r0 # Move to sprg, b panic # Branch","title":"panic"},{"location":"Reversing_the_bootloaders/#post-output","text":"#Sends the lowest byte of r4 to the post buffer post: sldi r4, r4, 56 std r4, 0(r3) blr","title":"post output"},{"location":"Reversing_the_bootloaders/#reversed-bootloaders","text":"The following bootloaders have already been reversed and posted: 1bl Code CB Code","title":"Reversed Bootloaders"},{"location":"Run_Code/","text":"This is outdated! Use JTAG Hack or Reset Glitch Hack ! Thanks to the work of \"Anonymous Hacker\" and \"Crawler360\", it is now possible to run your own code on an Xbox 360 with full (hypervisor) privileges. This page describes what you need in order to run your own code on your Xbox 360. Kernel Version You need an Xbox with a kernel version of 4532 or 4548. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version. If your kernel version is older, you can update to one of these versions. Do not update to a version newer than 4548! You won't be able to downgrade! If you already have a newer version, there is nothing you can do right now. If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it. If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip from somewhere, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. We are not linking to it here, but it is very easy to get. In any case, you should remove the resistor R6T3 on the mainboard, to prevent the efuse to be blown, which once blown is making downgrades to \\<4552 impossible. Modified Drive The DVD drive in your Xbox 360 needs to be modified to report non-game media as if it were game media. As this is the same modification that is needed for running copied games, it won't be reproduced here. A lot of good information on this is to be found elsewhere. Please note that besides the potential illegal (check your country's law!) modification of the drive's firmware, you can also hotswap the game disc after it has been authenticated. King Kong You need a modified version of the game \"King Kong\" (either PAL or NTSC version) on a DVD. Obviously, for legal reasons, you need to own the game. Fortunately, the game has been one of the launch games, and used copies are easily available and very affordable. Since the information on how to dump a game can be used for piracy, it won't be described here, but it is easily available elsewhere. There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable. There is a newer patch in the wild by xorloser, which allows booting directly from CDROM. The patcher currently does not work with the newer \"classics\" version of \"King Kong\" (barcode number 3 307210 240156), as it has a somewhat different structure but the patcher looks at \"hardcoded\" positions in the ISO - so it results in an \"ID error\" (you can check using a XDVDFS dump - the new one includes e.g. a file called \"GammaAdjust.raw\" which is not on the first and original DVD with barcode number 3 307210 206695 for the PAL version). Serial Cable The loader from Crawler360 requires a serial cable as described in Speedy22's docs. Note that the Xbox 360 serial port works with 3V levels and cannot be attached to a PC serial port directly. Even if you are working with xorloser's loader, a serial cable can be very useful for debugging purposes. Category:Xbox360_Development Category:Xbox360_Homebrew_Software Category:Xbox360_Hardware Category:Support","title":"Run Code"},{"location":"Run_Code/#kernel-version","text":"You need an Xbox with a kernel version of 4532 or 4548. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0.nnnn.0, where nnnn is your four digit kernel version. If your kernel version is older, you can update to one of these versions. Do not update to a version newer than 4548! You won't be able to downgrade! If you already have a newer version, there is nothing you can do right now. If you buy an Xbox, make sure that its manufacturing date is before 09 January 2007, so that the kernel version is 4548 or older. You can see the manufacturing date (\"MFR Date\") through the carton without opening it. If you have a pre-4532 kernel, you need to get the file HD_DVD_10-2006.zip from somewhere, check the MD5SUM to be cd4db8e2c94266ab73513c361dd5b8f6 (important!), burn it to a CD, and insert the CD into your Xbox 360. The program will update your machine to kernel version 4532. This file is an authentic Microsoft update application, but is not available on Microsoft's servers any more. If you own an Xbox, it should be legal for you to download and run this application. We are not linking to it here, but it is very easy to get. In any case, you should remove the resistor R6T3 on the mainboard, to prevent the efuse to be blown, which once blown is making downgrades to \\<4552 impossible.","title":"Kernel Version"},{"location":"Run_Code/#modified-drive","text":"The DVD drive in your Xbox 360 needs to be modified to report non-game media as if it were game media. As this is the same modification that is needed for running copied games, it won't be reproduced here. A lot of good information on this is to be found elsewhere. Please note that besides the potential illegal (check your country's law!) modification of the drive's firmware, you can also hotswap the game disc after it has been authenticated.","title":"Modified Drive"},{"location":"Run_Code/#king-kong","text":"You need a modified version of the game \"King Kong\" (either PAL or NTSC version) on a DVD. Obviously, for legal reasons, you need to own the game. Fortunately, the game has been one of the launch games, and used copies are easily available and very affordable. Since the information on how to dump a game can be used for piracy, it won't be described here, but it is easily available elsewhere. There are two King Kong patches available right now. The first was the one by Crawler360: Launch the modified game, press START on the title screen, and a very simple loader will be launched that allows uploading your code through a serial cable. There is a newer patch in the wild by xorloser, which allows booting directly from CDROM. The patcher currently does not work with the newer \"classics\" version of \"King Kong\" (barcode number 3 307210 240156), as it has a somewhat different structure but the patcher looks at \"hardcoded\" positions in the ISO - so it results in an \"ID error\" (you can check using a XDVDFS dump - the new one includes e.g. a file called \"GammaAdjust.raw\" which is not on the first and original DVD with barcode number 3 307210 206695 for the PAL version).","title":"King Kong"},{"location":"Run_Code/#serial-cable","text":"The loader from Crawler360 requires a serial cable as described in Speedy22's docs. Note that the Xbox 360 serial port works with 3V levels and cannot be attached to a PC serial port directly. Even if you are working with xorloser's loader, a serial cable can be very useful for debugging purposes. Category:Xbox360_Development Category:Xbox360_Homebrew_Software Category:Xbox360_Hardware Category:Support","title":"Serial Cable"},{"location":"SDLQuake/","text":"General Info NFO As a testbed, ive ported SDLQuake in parallel with libSDLXenon SDLQuake libXenon repository is located at https://github.com/lantus/sdlquake-libxenon Download the source and use 'make' to build SDLQuake. I've attached a binary with shareware quake as well. Enjoy :) Category:Xbox360_Homebrew_Software","title":"SDLQuake"},{"location":"SDLQuake/#general-info","text":"","title":"General Info"},{"location":"SDLQuake/#nfo","text":"As a testbed, ive ported SDLQuake in parallel with libSDLXenon SDLQuake libXenon repository is located at https://github.com/lantus/sdlquake-libxenon Download the source and use 'make' to build SDLQuake. I've attached a binary with shareware quake as well. Enjoy :) Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"SFCX/","text":"Category:Xbox360 System Software","title":"SFCX"},{"location":"SMBus_Controller/","text":"Overview All non-PC components of the Xbox console are connected through an I\u00b2C/SMbus interface. I\u00b2C/SMBus is a slow low-cost serial bus with each device having a unique 7-bit ID. (Wikipedia has informative articles about I\u00b2C (http://en.wikipedia.org/wiki/I2c) and SMBus (http://en.wikipedia.org/wiki/SMBus), you might want to check them out.) There are only two operations of an SMBus controller: write and read. Writing means that an 8 bit command code and an 8 or 16 bit operand are sent to an SMBus device. Reading means that an 8 bit command code is sent to the device and an 8 or 16 bit answer is expected. The controller for the SMBus interface in the Xbox is a PCI device with the DevID 01B4 and it is built into MPCX southbridge. SMBus Controller Port Layout Port Description 0xc000 Status bit 0: abort bit 1: collision bit 2: protocol error bit 3: busy bit 4: cycle complete bit 5: timeout 0xc002 Control bit 2-0: cycle type bit 3: start bit 4: enable interrupt bit 5: abort 0xc004 Address 0xc006 Data 0xc008 Command This is very similar (but not identical) to the AMD756/AMD766/AMD768 SMBus controllers. The lm_sensors project includes GPLed Linux kernel code for it since version 2.6.4 (kernel/busses/i2c-amd756.c). SMBus Controller Programming The following two routines illustrate how to read and write data from and to an SMBus device: int SMBusWriteCommand(unsigned char slave, unsigned char command, int isWord, unsigned short data) { again: _outp(0xc004, (slave<<1)&0xfe); _outp(0xc008, command); _outpw(0xc006, data); _outpw(0xc000, _inpw(0xc000)); _outp(0xc002, (isWord) ? 0x0b : 0x0a); while ((_inp(0xc000) & 8)); /* wait while busy */ if (_inp(0xc000) & 0x02) goto again; /* retry transmission */ if (_inp(0xc000) & 0x34) return 0; /* fatal error */ return 1; } int SMBusReadCommand(unsigned char slave, unsigned char command, int isWord, unsigned short *data) { again: _outp(0xc004, (slave<<1)|0x01); _outp(0xc008, command); _outpw(0xc000, _inpw(0xc000)); _outp(0xc002, (isWord) ? 0x0b : 0x0a); while ((_inp(0xc000) & 8)); /* wait while busy */ if (_inp(0xc000) & 0x02) goto again; /* retry transmission */ if (_inp(0xc000) & 0x34) return 0; /* fatal error */ *data = _inpw(0xc006); return 1; } To avoid busy waiting of the CPU, the SMBus controller can also issue an interrupt when the operation is complete, by setting bit #4 in the control port when initiating the transfer. Xbox SMBus Devices The following four devices are connected to the Xbox SMBus: Device Hardware Address Software Address PIC16LC 0x10 0x20 Conexant CX25871 Video Encoder 0x45 0x8a ADM1032 System Temperature Monitor 0x4c 0x98 Serial EEPROM 0x54 0xa8 Do not confuse the hardware with the software addresses: The software ID is the hardware ID shifted by one bit left. The code above expects the hardware ID. Actually, these addresses are not literally accurate; you find that the hardware address is 0x54 for the EEPROM: the actual address of the EEPROM on the i2c bus is 1010 (0xa), however, you will also notice that 0x54 is 1010100 in binary, and it seems that this 100 is also appended onto the other devices as well (although their software address is naturally read as say 10101000 - obviously because of the left shifting, however, it could be speculated that it would be possible to communicate with devices over the SMBus that are connected via i2c, so long as you knew their base address. Retrieved from \" http://www.xbox-linux.org/wiki/SMBus_Controller \" Category:Xbox_Hardware","title":"Overview"},{"location":"SMBus_Controller/#overview","text":"All non-PC components of the Xbox console are connected through an I\u00b2C/SMbus interface. I\u00b2C/SMBus is a slow low-cost serial bus with each device having a unique 7-bit ID. (Wikipedia has informative articles about I\u00b2C (http://en.wikipedia.org/wiki/I2c) and SMBus (http://en.wikipedia.org/wiki/SMBus), you might want to check them out.) There are only two operations of an SMBus controller: write and read. Writing means that an 8 bit command code and an 8 or 16 bit operand are sent to an SMBus device. Reading means that an 8 bit command code is sent to the device and an 8 or 16 bit answer is expected. The controller for the SMBus interface in the Xbox is a PCI device with the DevID 01B4 and it is built into MPCX southbridge.","title":"Overview"},{"location":"SMBus_Controller/#smbus-controller-port-layout","text":"Port Description 0xc000 Status bit 0: abort bit 1: collision bit 2: protocol error bit 3: busy bit 4: cycle complete bit 5: timeout 0xc002 Control bit 2-0: cycle type bit 3: start bit 4: enable interrupt bit 5: abort 0xc004 Address 0xc006 Data 0xc008 Command This is very similar (but not identical) to the AMD756/AMD766/AMD768 SMBus controllers. The lm_sensors project includes GPLed Linux kernel code for it since version 2.6.4 (kernel/busses/i2c-amd756.c).","title":"SMBus Controller Port Layout"},{"location":"SMBus_Controller/#smbus-controller-programming","text":"The following two routines illustrate how to read and write data from and to an SMBus device: int SMBusWriteCommand(unsigned char slave, unsigned char command, int isWord, unsigned short data) { again: _outp(0xc004, (slave<<1)&0xfe); _outp(0xc008, command); _outpw(0xc006, data); _outpw(0xc000, _inpw(0xc000)); _outp(0xc002, (isWord) ? 0x0b : 0x0a); while ((_inp(0xc000) & 8)); /* wait while busy */ if (_inp(0xc000) & 0x02) goto again; /* retry transmission */ if (_inp(0xc000) & 0x34) return 0; /* fatal error */ return 1; } int SMBusReadCommand(unsigned char slave, unsigned char command, int isWord, unsigned short *data) { again: _outp(0xc004, (slave<<1)|0x01); _outp(0xc008, command); _outpw(0xc000, _inpw(0xc000)); _outp(0xc002, (isWord) ? 0x0b : 0x0a); while ((_inp(0xc000) & 8)); /* wait while busy */ if (_inp(0xc000) & 0x02) goto again; /* retry transmission */ if (_inp(0xc000) & 0x34) return 0; /* fatal error */ *data = _inpw(0xc006); return 1; } To avoid busy waiting of the CPU, the SMBus controller can also issue an interrupt when the operation is complete, by setting bit #4 in the control port when initiating the transfer.","title":"SMBus Controller Programming"},{"location":"SMBus_Controller/#xbox-smbus-devices","text":"The following four devices are connected to the Xbox SMBus: Device Hardware Address Software Address PIC16LC 0x10 0x20 Conexant CX25871 Video Encoder 0x45 0x8a ADM1032 System Temperature Monitor 0x4c 0x98 Serial EEPROM 0x54 0xa8 Do not confuse the hardware with the software addresses: The software ID is the hardware ID shifted by one bit left. The code above expects the hardware ID. Actually, these addresses are not literally accurate; you find that the hardware address is 0x54 for the EEPROM: the actual address of the EEPROM on the i2c bus is 1010 (0xa), however, you will also notice that 0x54 is 1010100 in binary, and it seems that this 100 is also appended onto the other devices as well (although their software address is naturally read as say 10101000 - obviously because of the left shifting, however, it could be speculated that it would be possible to communicate with devices over the SMBus that are connected via i2c, so long as you knew their base address. Retrieved from \" http://www.xbox-linux.org/wiki/SMBus_Controller \" Category:Xbox_Hardware","title":"Xbox SMBus Devices"},{"location":"SMC/","text":"The System Management Controller (SMC) is an 8051/8052 core inside the Southbridge . It manages the power sequencing, and is always active when the Xbox 360 has (standby or full) power applied. It controls the frontpanel, has a Realtime clock, decodes IR, manages temperatures, fans, DVDROM tray and a bunch of other things. It talks with the frontpanel board to set the LEDs. When the system is running, the kernel can communicate with the SMC, for example to query the realtime clock, open the dvd-tray etc. The FIFO Sending a Message Communication between kernel and SMC happens over a bidirectional FIFO (at ea001080 / ea001090). All messages and replies are 16 byte long and have the command id in the first byte. void smc_send(void *msg) { while (!(readl(0xea001084) & 4)) // wait for FIFO ready cpu_relax(); writel(4, 0xea001084); // start message writesl(0xea001080, msg, 4); // send 16 bytes writel(0, 0xea001084); // end message } Receiving a Reply Some messages have replies, which will be returned as 16 byte sequence similar to the message (they also have the command id in the first byte). int smc_read_reply(void *msg) { if (!(readl(0xea001094) & 4)) // do we have a reply? return 0; writel(4, 0xea001094); // start reply readsl(0xea001090, msg, 4); // read 16 bytes writel(0, 0xea001094); // end reply return 1; } Command Messages ID Len Example Purpose 0x82 2-3 \"\\x82\\0x04\\0x31\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set standby/power 0x85 ? ? set real time clock 0x88 ? ? set fan algorithm 0x89 ? ? set fan speed (cpu/gpu?) 0x8b ? \"\\x8b\\0x62\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray 0x8c 3 \"\\x8c\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set power led 0x8d 2 \"\\x8d\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set audio mute 0x94 ? ? set fan speed (cpu/gpu?) 0x95 ? ? set ir address 0x98 1 \"\\x98\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray secure 0x99 3 \"\\x99\\0x01\\0x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set ring of light 0x9a ? ? set rtc wake Query Messages ID Len Example Query Example Reply Purpose 0x01 1:6 \"\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 01 12 00 00 00 00 power on type 0x04 1:11 \"\\x04\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 04 602f 212223 01 00000000 real time clock 0x07 1:10 \"\\x07\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 07ff 241b 2fa4 2cfa 262c read temps 0x0a 1:2 \"\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 0a 60 request tray state 0x0f 1:2 \"\\x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 0f 54 request AV pack type 0x11 6:2 \"\\x11\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 11 02 read ana 0x12 1:6 \"\\x12\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 1241 0203 0000 request SMC version 0x16 1:2 \"\\x16\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 16 0f query IR address 0x17 1:2 \"\\x17\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 17 00 query tilt sensor Event Messages ID Len Example Message Purpose 0x83 2 83 64 SMC event Category:Xbox360_Hardware","title":"SMC"},{"location":"SMC/#the-fifo","text":"","title":"The FIFO"},{"location":"SMC/#sending-a-message","text":"Communication between kernel and SMC happens over a bidirectional FIFO (at ea001080 / ea001090). All messages and replies are 16 byte long and have the command id in the first byte. void smc_send(void *msg) { while (!(readl(0xea001084) & 4)) // wait for FIFO ready cpu_relax(); writel(4, 0xea001084); // start message writesl(0xea001080, msg, 4); // send 16 bytes writel(0, 0xea001084); // end message }","title":"Sending a Message"},{"location":"SMC/#receiving-a-reply","text":"Some messages have replies, which will be returned as 16 byte sequence similar to the message (they also have the command id in the first byte). int smc_read_reply(void *msg) { if (!(readl(0xea001094) & 4)) // do we have a reply? return 0; writel(4, 0xea001094); // start reply readsl(0xea001090, msg, 4); // read 16 bytes writel(0, 0xea001094); // end reply return 1; }","title":"Receiving a Reply"},{"location":"SMC/#command-messages","text":"ID Len Example Purpose 0x82 2-3 \"\\x82\\0x04\\0x31\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set standby/power 0x85 ? ? set real time clock 0x88 ? ? set fan algorithm 0x89 ? ? set fan speed (cpu/gpu?) 0x8b ? \"\\x8b\\0x62\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray 0x8c 3 \"\\x8c\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set power led 0x8d 2 \"\\x8d\\0x01\\0x00\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set audio mute 0x94 ? ? set fan speed (cpu/gpu?) 0x95 ? ? set ir address 0x98 1 \"\\x98\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set dvd tray secure 0x99 3 \"\\x99\\0x01\\0x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" set ring of light 0x9a ? ? set rtc wake","title":"Command Messages"},{"location":"SMC/#query-messages","text":"ID Len Example Query Example Reply Purpose 0x01 1:6 \"\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 01 12 00 00 00 00 power on type 0x04 1:11 \"\\x04\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 04 602f 212223 01 00000000 real time clock 0x07 1:10 \"\\x07\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 07ff 241b 2fa4 2cfa 262c read temps 0x0a 1:2 \"\\x0a\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 0a 60 request tray state 0x0f 1:2 \"\\x0f\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 0f 54 request AV pack type 0x11 6:2 \"\\x11\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 11 02 read ana 0x12 1:6 \"\\x12\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 1241 0203 0000 request SMC version 0x16 1:2 \"\\x16\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 16 0f query IR address 0x17 1:2 \"\\x17\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\" 17 00 query tilt sensor","title":"Query Messages"},{"location":"SMC/#event-messages","text":"ID Len Example Message Purpose 0x83 2 83 64 SMC event Category:Xbox360_Hardware","title":"Event Messages"},{"location":"SMC_Command_0x01/","text":"Query Power On Type The reply to the SMC command 0x01 will contain some information about the event which caused the X360 to power up. Message: 01 Reply: 01 WW 00 XX YY ZZ Data Source Meaning WW @63h Type of power up Event XX @3fh ?? YY.0 @2bh.1 ?? ZZ @3eh ?? # Event Type 0x11 power button 0x12 eject button 0x15 rtc wakeup 0x16 ??? 0x20 power IR 0x21 eject IR 0x22 xenon IR 0x24 MCE IR 0x30 power cycle 0x31 reset cycle 0x41 ??? 0x51 kiosk 0x55 argon (RF) 0x56 gameport 1 0x57 gameport 2 0x5a expansion resume","title":"SMC Command 0x01"},{"location":"SMC_Command_0x01/#query-power-on-type","text":"The reply to the SMC command 0x01 will contain some information about the event which caused the X360 to power up. Message: 01 Reply: 01 WW 00 XX YY ZZ Data Source Meaning WW @63h Type of power up Event XX @3fh ?? YY.0 @2bh.1 ?? ZZ @3eh ?? # Event Type 0x11 power button 0x12 eject button 0x15 rtc wakeup 0x16 ??? 0x20 power IR 0x21 eject IR 0x22 xenon IR 0x24 MCE IR 0x30 power cycle 0x31 reset cycle 0x41 ??? 0x51 kiosk 0x55 argon (RF) 0x56 gameport 1 0x57 gameport 2 0x5a expansion resume","title":"Query Power On Type"},{"location":"SMC_Command_0x82/","text":"Set Standby/Power Off/Reboot This Command Message triggers various power management operations. Message: 82 XX YY ZZ XX YY ZZ Meaning 01 00 -- Power Off (@3dh=1, @64h=#5a) 01 32 -- Power Off (@3dh=0, Clears RTC?) 04 31 ?? Reboot (@3dh=1, @64h=#01, Soft Reset) 04 30 ?? Reboot (@3dh=0, @64h=#03, Power Cycle) 04 33 -- Clear (@3dh=0)","title":"SMC Command 0x82"},{"location":"SMC_Command_0x82/#set-standbypower-offreboot","text":"This Command Message triggers various power management operations. Message: 82 XX YY ZZ XX YY ZZ Meaning 01 00 -- Power Off (@3dh=1, @64h=#5a) 01 32 -- Power Off (@3dh=0, Clears RTC?) 04 31 ?? Reboot (@3dh=1, @64h=#01, Soft Reset) 04 30 ?? Reboot (@3dh=0, @64h=#03, Power Cycle) 04 33 -- Clear (@3dh=0)","title":"Set Standby/Power Off/Reboot"},{"location":"SMC_Hack/","text":"The JTAG/SMC Hack There is a new hack which can boot homebrew code in less than 5 seconds. See at the end of this document for a description how the hack works. For now, all we need to know is that this is a new way to exploit the well-known 4532 kernel, in a way which also works on updated machines, unless they have been updated by the summer '09 update. It also works on all hardware types. This document is a technical description meant for people who want to undestand the hack. If you don't understand a word, calm down - there probably will be future releaes, howtos etc. Please also notice that from a functional side, the result will be the same as the KK-hack; it's just much faster, works on more hardware and is more reliable. So it replaces the KK-hack, not less and not more. Technical details are available here . Required Soldering The SMC Hack requires bridging 3 points on the motherboard (for trigger the exploit by JTAG), as well as having a way to read and write with your Nand Flash - The JTAG points are available for a number of consoles Xenon : Falcon , Zephyr , Opus & ' Jasper ': Falcon , Zephyr , Opus & ' Jasper ' Reverse Jtag: - To read and write the Nand Flash (using SPI protocol by LPT and a printer cable), there is a friendly tutorial at NAND Reading There are other ways to read and write the Nand Flash that are valid (such as infectus modchip) All the diodes used in SPI and JTAG are \"switching diodes\" proposed are: BAT41, 1N4148, or 1N4153 Building a Homebrew-Kernel From scratch What you need Latest build.py Script from GIT CB/CD-files matching for your Xbox Revision (called CB.xxxx/CD.xxxx here, where xxxx is the version) -Xenon: 1921 -Zephyr: 4558 -Falcon: 5770 -Jasper: 6712, 6723 Hacked SMC Code matching your Xbox Revision (called smc_hacked.bin here) ATM only available for XENON / falcon / zephyr / opus(as of recently) The 1888 Basekernel (called 1888image.bin here) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532-Update Compiled XELL (xell-1f.bin, also the same file named xell-backup.bin) How-to 1. Check out the latest free60-tools with GIT git clone 2. Extract xboxupd.bin with WxPirs from the unzipped 4532-Dashboard-Update 3. Copy the files xboxupd.bin, 1888image.bin, CB.xxxx/CB.xxxx, smc.hacked and the two XeLL files xell-1f.bin and xell-backup.bin to /tools/imgbuild/input (you need to create the folder first). Also create a folder \"output\" in /tools/imgbuild/ 4. Edit build.py to contain the Secret 1BL Key in this format (Example-Key: 010F0E0C0ED669E7B56794FB68563EFA) secret_1BL = \"\\x01\\x0F\\x0E\\x0C\\x0E\\xD6\\x69\\xE7\\xB5\\x67\\x94\\xFB\\x68\\x56\\x3E\\xFA\" 5. Start build.py with the following command python build.py input/1888image.bin input/CB.xxxx input/CD.xxxx input/xboxupd.bin input/xell-backup.bin input/xell-1f.bin input/smc_hacked.bin If everything works out the Script should output something similar to this * found flash image, unpacking and decrypting... ECC'ed - will unecc. Found 2BL (build 1888) at 00008000 Found 4BL (build 1888) at 0000e1e0 Found 5BL (build 1888) at 000138d0 * found (hopefully) decrypted CB * found (hopefully) raw CD * found update Found 6BL (build 4532) at 00000000 Found 7BL (build 4532) at 000044c0 * found XeLL binary, must be linked to 1c000000 * found XeLL binary, must be linked to 1c000000 * found decrypted SMC * we found the following parts: CB: 1921 CD: 1921 CE: 1888 CF: 4532 CG: 4532 * checking if all files decrypted properly... ok * checking required versions... ok * Fixing up the hacked SMC code with the target address * this image will be valid *only* for: xenon * zero-pairing... * constructing new image... * base size: 70000 * compiling payload stub * Flash Layout: 0x00000000..0x000001ff (0x00000200 bytes) Header 0x00000200..0x000003ff (0x00000200 bytes) Exploit 0x00000400..0x00000fff (0x00000c00 bytes) Padding 0x00001000..0x00003fff (0x00003000 bytes) SMC 0x00004000..0x00007fff (0x00004000 bytes) Keyvault 0x00008000..0x000117ff (0x00009800 bytes) CB 1921 0x00011800..0x00016ebf (0x000056c0 bytes) CD 1921 0x00016ec0..0x0006cf2f (0x00056070 bytes) CE 1888 0x0006cf30..0x0006ffff (0x000030d0 bytes) Padding 0x00070000..0x000744bf (0x000044c0 bytes) CF 4532 0x000744c0..0x000a33ff (0x0002ef40 bytes) CG 4532 0x000a3400..0x000bffff (0x0001cc00 bytes) Padding 0x000c0000..0x000fffff (0x00040000 bytes) Xell (backup) 0x00100000..0x0013ffff (0x00040000 bytes) Xell (main) * Encoding ECC... Written into output/image_00000000.ecc ! please flash output/image_*.ecc, and setup your JTAG device to do the DMA read from 00000200 6. Finished! Your ready-to-be-flashed Image is located in the output-folder, called image_00000000.ecc Updating a hacked image What you need Latest build.py Script from GIT Hacked Kernel-Image (hacked-image.bin) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532-Update Compiled XELL (xell-1f.bin) How-to 1. Checkout free60-tools, extract xboxupd.bin as described above. 2. Copy files hacked-image.bin, xboxupd.bin and xell-1f.bin to /tools/imgbuild/ and create a folder \"output\" there. 3. Start build.py with following command: python build.py hacked-image.bin xboxupd.bin xell-1f.bin 4. Finished! Your updated hacked-image was written into the output directory and is ready to be flashed. Alternative If you are using XeLL-compile after 31. August 09 you could use the USB-Update feauture. How-to 1. Format a compatible USB Drive to FAT16/32. 2. Put 'xell-1f.bin' renamed to 'updxell.bin' into the Root of the USB Drive. 3. Turn on XeLL-Xbox 360 with attached USB Drive. 4. XeLL should recognize USB Drive and tell you '* found XeLL update. press power NOW if you don't want to update.' 5. Wait for XeLL to tell you '*update done ' and unplug the USB Drive so it won't upgrade on the next startup. 6. Reboot Xbox 360 and enjoy a fresh XeLL. Extracting SMC/CB/CD from a hacked image What you need Latest build.py Script from GIT Hacked Kernel-Image (hacked-image.bin) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532 Update How-to 1. Checkout free60-tools, extract xboxupd.bin as described above 2. Copy files hacked-image.bin and xboxupd.bin to /tools/imgbuild/ and create a folder \"output\" there 3. Start build.py with following command python build.py hacked-image.bin xboxupd.bin 4. Finished! Decrypted SMC, CB and CD data was written into the output directory Build a full 16MB Image out of the small one created by build-script Just use this simple command (input/backup.ecc is your nand backup, and output/full.ecc is a 16MB image you can flash) cp input/backup.ecc output/full.ecc; dd if=output/image_00000000.ecc of=output/full.ecc conv=notrunc Using the 1920to1921 script What you need Latest 1920to1921.py Script from GIT decrypted 1921 CB (2BL) decrypted 1920 CD (4BL) How-to 1. Rename 1921 CB file to CB.1921 (no file extension) and 1920 CD to CD.1920 2. Move both files to /tools/imgbuild/input/ 3. Start 1920to1921.py with following command: python 1920to1921.py xxxx (where xxxx is the CD Version you want to create, i.e 1921, 4558, 5770) 4. Finished! Script should tell you \"great, hash matches!\" and write the appropriative CD to the input folder. Technical details To understand this new hack, let's first look at what made the KK exploit possible: A fatal bug in the Hypervisor's Syscall Handler, introduced in the 4532 kernel update. For more details, take a look at http://www.securityfocus.com/archive/1/461489/30/0/threaded which explains the problem in great detail. The KK exploit exploited the kernel bug by modifying an unsigned shader to do a series of so-called memory exports, an operation where the GPU can write the results of a pixel or vertex shader into physical memory. The shader was written to overwrite the Idle-thread context to make the kernel jump at a certain position in memory, with some registers nder our control. In order to control all registers, a second step was necessary, this time by jumping into the interrupt restore handler. This finally allows all CPU general purpose registers to be filled with etermined values. The program counter could be restored to a syscall instruction in the kernel, with register values prefilled so that they would trigger the exploit. The exploit basically allows jumping into any 32-bit address in hypervisor space. To jump into an arbitrary location, we just used a \"mtctr, bctr\"-register pair in hypervisor, which would redirect execution low into any 64-bit address. This is important, since we need to clear the upper 32bit (i.e.,set the MSB to disable the HRMO), since the code we want to jump to is in unencrypted memory. This code would usually load a second-stage loader, for example XeLL, into memory, and start it. XeLL would then attempt to catch all cpu threads (because just the primary thread is affected by our exploit), and load the user code, for example from DVD. So, the following memory areas are involved: Idle Thread context, at 00130360 in physical memory This stores the stack pointer (and some other stuff) when the idle thread was suspended. By changing the stack pointer, and then waiting for the kernel to switch to the idle thread, the stack pointer can be brought into our control. Part of the context switch is also a context restore, based on the new stack pointer. Context restore, part 1, arbitrary location, KK expl. uses 80130AF0 The thread-context restore doesn't restore all registers, but let's us control the NIP (the \"next instruction\" pointer). We setup NIP to point to the interrupt context restore, which does a SP-relative load of most registers. Context restore, part 2, same base location as part 1 We just re-use the same stack pointer, because the areas where the first context restore and the interrupt context restore load from do not overlap. The second context restore allows us to pre-set all registers with arbitrary 64 bit values. The HV offset, at 00002080 for syscall 0x46 on 4532 Because of the HV bug, we can write this offset into unencrypted memory, giving us the possibility to jump into any location in the hypervisor space (i.e. with a certain \"encryption prefix\"). We usually write 00000350 here, which points to a \"mtctr %r4; bctr\" instruction pair in hypervisor, which lets us jump to %r4. Our loader code, at an arbitrary location This code will be executed from hypervisor. It's the first of our code which will be executed. %r4 on the syscall entry has to point to this code. Only the idle thread context and the HV offset have fixed addresses. It's easily possible to merge this so that only two distinct blocks needs to be written into memory, but it's not possible to merge this into a single block. Fortunately, the NAND controller allows doing DMA reads where the payload data is split from the \"ECC\"-data. Each page has 512 bytes of payload, and 16 bytes of ECC data. Thus, a single DMA read can be used to load all required memory addresses. We chose the Payload to read the Idle Thread Context, the Context Restores and the loader code. The ECC data will carry the HV offset. To do a DMA read, the following NAND registers need to be written: ea00c01c Address for Payload ea00c020 Adresss for ECC ea00c00c address inside NAND ea00c008 command: read DMA (07) The System Management Controller (SMC) is a 8051 core inside the Southbridge. It manages the power sequencing, and is always active when the Xbox 360 has (standby or full) power applied. It controls the frontpanel buttons, has a Realtime clock, decodes IR, controls temperatures and fans and the DVDROM tray. It talks with the frontpanel board to set the LEDs. When the system is running, the kernel can communicate with the SMC, for example to query the realtime clock, open the dvd-tray etc. This happens over a bidirectional FIFO (at ea001080 / ea001090). See the XeLL SMC code for details. The SMC can read the NAND, because it requires access to a special NAND page which contains a SMC config block. This block contains calibration information for the thermal diodes, and the thermal targets etc. The 8051 core has access to NAND registers, which are mapped into the 8051 SFRs. It uses the same protocol as the kernel uses, so it writes an address, does a \"READ\" command, and then reads the data out of the \"DATA\" registers. It could also do a \"READ (DMA)\"-command. So by hacking the SMC, we could make the box do the exploit, without any shader - the SMC can access the NAND controller all the time, even when the kernel is running (though it will likely interfere with the kernel). So, we just trigger the DMA read when the kernel has been loaded, and everything is fine. Right? Well, that would be too easy. While most NAND registers are mapped, the DMA address registers (1c, 20) are not. We can DMA, but only to the default address of zero (or wherever the kernel last DMAed into). Fail. The GPU, the (H)ANA (the \"scaler\" - which in fact doesn't scale at all, it's \"just\" a set of DACs, and, since Zephyr, a DVI/HDMI encoder), the Southbridge and the CPU have their JTAG ports exposed on the board. They are unpopulated headers, but the signals are there. CPU JTAG is a different (complex) story, and SB JTAG doesn't offset much funcationality. ANA JTAG is boring since the ANA doesn't sit on any interesting bus. That leaves GPU JTAG. GPU JTAG was reverse-engineered until a point where arbitrary PCI writes are possible, up to a certain point. So that makes it possible to talk to each PCI device in the system, including the NAND controller. So we can simply use THAT instead of the SMC to start the DMA? Right? Well, not quite. The problem is that the \"VM code\", the code which does a lot of system initialization, like the memory (that code is also responsible for generating the 01xx \"RROD\"-Errors), sets a certain bit in some GPU register, which disables the JTAG interface. The VM code is executed way before the kernel is active. So this is fail, too. But the combination works - by programming the DMA target address via JTAG, and launching the attack via SMC. The attack can be launched as soon as the kernel is running, and quite early, it does query the SMC for the RTC. We abuse this call to start the attack instead, which is a perfect point for us. But how do we run an exploitable kernel at all? Most machines are updated already. Let me refresh your knowledge about the boot process again: 1BL (Bootrom) Buried deep inside the CPU die, this ~32kb of ROM code is responsible for reading the 2BL from NAND-flash and decrypts it into the embedded SRAM in the CPU. It verifies the hash of the decrypted image with a signed block at the beginning of the 2BL, and will stop execution if this hash mismatches. This code also contains a number of test functions, which can be activated by pulling the 5 \"POST IN\"-pins, which are available on the backside of the PCB. None of these tests looks particulary interesting (from an exploitation perspective) - they mostly seem to be related to the FSB (the bus between CPU and GPU). This code is fixed, and all systems use identical code here. 2BL (\"CB\") This code is usually located at 0x8000 in NAND flash. It's decrypted by 1BL, and runs from internal SRAM. It does a basic hardware initialization, and contains the \"fuse check code\", which verifies the \"2BL version\". The fuses store the expected version. The 2BL stores a \"Version\" and a \"AllowedMask\" (=bitfield), and this is usually stored at address 0x3B1 / 0x3B2..0x3B3. Xenon Zephyr Falcon Jasper 2 0003 1888, 1901, 1902 4 1920 \"new zeropair code\" 5 0010 1921 4558 5760,5761,5770 6712 TA-fixed It then verifies the pairing information stored in the 2BL header. Part of this verification is a checksum check of the NAND area which was used to load the SMC code from. It also contains a virtual machine and some code to run on this machine. The virtual machine code, which is pretty complicated, does the following things: Initialisation of the PCI-Bridge Disable the GPU PCIE JTAG test port initialize the serial port talk to the SMC to clear the \"handshake\"-bit initialize memory hopefully not: generate RROD if memory init fails After that, the external (512MB) memory will be initialized and usable. 2BL then decrypts the 4BL into this memory. Memory encryption will already be enabled - no executable code is *ever* written unencrypted. 4BL (\"CD\") This code is responsible for checking and unpacking 5BL, as well as applying update patches. First, the fuses are read to determine the console \"Update Sequence\", a number which basically counts the number of updates installed. Since updates are, in the same way as 2BL, paired to a console, this allows to configure the console in a way that no old update will be used. So each update slot stores the maximum value of burned fuses (well, essentially the exact value). The base kernel also has an associated value, usually zero, but this can be changed in the 2BL pairing data block. This is what the timing-attack increments, in order to revert to the 1888 kernel. 5BL (\"HV/Kernel\") The HV and kernel are merged into a single image, which is compressed with a proprietary algorithm (LDIC). 6BL (\"CF\"), 7BL (\"CG\") This is part of a system upgrade. Each console has a so-called \"Base Kernel\", which is the 1888 kernel which was available on launch back in 2005. Then there are two \"update slots\" - areas of 64k each (128k on Jasper), which contain a 6BL and 7BL. 6BL is code which applies the update, using a clever delta-compression. 7BL is the actual delta-compressed update, essentially a binary diff. Oh, updates are >64k. So only the first 64k are actually stored in the update slots, the rest is stored in the filesystem as a special file. Since 6BL doesn't contain a filesystem parser, a blockmap is added in 6BL which points to the sectors which contain the rest of the update. Zero-Pairing Now there is a special situation: If the 2BL pairing block is all-zero, the pairing block will not be checked. However, a bit is set so that the kernel doesn't boot the dashboard binary, but a special binary called \"MfgBootLauncher\", where \"Mfg\" probably stands for \"Manufacturing\". So this is a leftover of the production process, where the flash image is used on all hardware, probably also before any CPU-key has been programmed. By abusing this feature, this allows us easily to produce a flash image which runs on all hardware. However, 4BL won't look at update slots when it detects this mode, so we end up in the 1888 base kernel. And we can't run the dashboard, so it's impossible to escape this mode. Previously, this has been deemed very uninteresting, because first the 1888 isn't exploitable by the KK exploit, and second because it's impossible to run the KK game anyway. However, starting with 2BL version 1920, an interesting thing happened: The encryption key for 4BL is generated with the help of the CPU-key now. That means that without the CPU-key, it's not possible to decrypt the 4BL anymore. Note that each 2BL has exactly a single valid 4BL binary - 2BL contains a hardcoded hash for the 4BL, and doesn't use RSA. However, zero'ed pairing data is detected, the CPU-key is NOT used in this process, like it was previously. That also means that you cannot just zero-out the pairing data anymore - the 4BL would be decrypted with the wrong key then. Instead you need to decrypt the 4BL (which requires knowing the CPU key), and re-encrypt it with the old algorithm. However, 1920 was suspectible to the timing attack - so a CPU-key recovery was possible on one console, which allowed us to decrypt the 1920 4BL. That 4BL shows a very intersting change: Whenever zero-pairing is detected, the update slots are not ignored anymore. Instead, if the update-slots are zero-paired as well, they are applied. This change allows us to boot any kernel, provided we have a (1920 and up) 2BL/4BL set which runs on that machine. This is very important, because we can build up an image now which runs into the 4532 kernel, regardless on how many update fuses are set. However, the 2BL revocation process must be passed, so we are not completely independent of the fuses, still. But since we use zero-pairing, the SMC hash doesn't matter anymore (there are other ways to work around the SMC hash problem, like the TA, but we get this for free). Still, we boot into the MfgBootLauncher (into the 4532 version now, which does a red/green blinking thingie - you'll notice once you see it, it's very unique and doesn't look like any RROD or so). But thanks to the SMC/JTAG hack described above, this allows us to launch our attack from this state. Newer consoles (which have the TA fix) don't run 1920 anymore. They run, for example, 1921. The problem is that we cannot run HV code on these machines, so we don't know the CPU key. However, when comparing the 1921 and 1920 2BL (which we can still decrypt), the only change is the addition of the timing attack fix (i.e. replacing two memcmp instances with a memdiff function). Also, we know the expected hash value of the decrypted 4BL. Based on a 1920 4BL, and the guess what has changed functionally, and the new size of the 4BL, we were able to guess the modifications, which yields an image which passes the 2BL hash check. Note that this is not a hash collision - we did merely derive the exact image by applying the changes between 1920 2BL and 1921 2BL into 1920 4BL, yielding the 1921 4BL. The 1921 2BL theoretically runs on all machines so far, even TA-proof ones. But it crashes on Zephyr, Falcon and Jasper. The reason is the VM code, which doesn't cover the different GPUs (Xenon has 90nm GPU, Zephyr and Falcon have 80nm, Jasper has 60nm, so there are 3 GPU revisions in total). But the step from 1921 to, say, 4558, is even smaller. It's just the different version number, plus a slight difference in the memcpy code, which again can be ported over from 2BL. Jasper's 67xx is a different thing, since this code adds support for the largeblock flash used in \"Arcade\"-Jasper units. We have used some magic to retrieve this code. So we now have ALL 4BL versions. Isn't that great? It means that ALL machines can run the 4532 kernel. The good news is also that the 4532 kernel supports falcon consoles, and runs long enough to also work on jasper consoles (because we exploit way before the different GPU is touched at all). Troubleshooting Q: \"The power supply goes red when plugging in power!\" A: You shorted a power pin, probably V33_SB, the one attached to the NAND flash. Carefully look for solder residues. Use a lot of flux and a properly-heated soldering iron. Q: \"The power supply stays yellow when I press the power button, and nothing else happens.\" A: The SMC code is invalid. This can be a misconnected flashrom, an illegal image, a bad flash or simply a bad SMC code. Verify: Electrical connections first. Did you flash with the proper ECC settings? The flash images we are working with usually contain raw ECC information, i.e. 512+16 bytes per sector. Make sure your flash programmer is not modifying these 16 bytes, but writing those as they are. Have you used the right SMC image? Q: \"The fans run at full speed immediately.\" A: This is very likely a bad SMC config sector. Did you flash all the parts generated by the image creation tool at the proper position? Note that offsets are given as payload offsets, not counting ECC bytes. Usually this matches what your average NAND programmer tells you, but in case you re-assembled these into a single image, take care to properly convert the offsets. Q: \"I get E79\" A: This means that, congratulations, your console is still booting into a kernel, and just cannot go further (which was to be exepcted, given that there is no filesystem anymore). You're almost there, but for some reasons, the DMA attack didn't run. This can be either that you didn't used a patched SMC, or that the target address wasn't inserted properly. Q: \"Console powers on, but I get a black screen.\" A: Well, there are many reasons here again. First, wait some time (~1 minute), and see if you get a RROD. If you do, the VM code failed to handshake with the SMC (error code XXXX), which usually means that it crashed, and the SMC watchdog triggered until it retried too often. Did you use the proper 2BL/4BL image for your machine type? Did you use a recent enough SMC version? Since the VM code took more and more time (from roughly a half second in 1888 to several seconds in 1920), the SMC code was modified to time out later. Be sure to use a known-good SMC version, if possible, based on the version which was installed before. If you don't get a RROD, please try checking your POST code. You can do this via CPU jtag, or by measuring the 8 POST pins. Post code 6C: The exploit failed, somehow. Post code 10: Our code is running! That's great, but it failed copying the XeLL-payload from flash. Try booting into the alternate loader (see below in the \"exploit loader\" section), or reflash. Post code 11: Exploit code ran, and jumped into XeLL. XeLL crashed. Try alternate loader, or do serial upload for recovery, if you really screwed up both the primary and secondary loader. (You failed, in that case.) Post codes >= 0x80: Those are errors from the bootloader. Please check the disassembly of those loaders to see what's wrong exactly. It shouldn't happen unless you have a bad flash. Post code 0xA0: Your 2BL didn't want to run on your hardware due to the 2BL revocation fuses. Use a more recent 2BL/4BL set for your hardware. If you're already running {1921, 4558, 5770, 6712} then you're out of luck. Your box was already updated to a newer 2BL, which likely fixed what we used to exploit. Restore R6T3, restore the flash image, and use this console for playing games. Get another console, and try again. Please note that some hardware elements are not properly initialized at the early time of the exploit. This affects: CPU: The CPU is initialized in low-power mode, where it runs at quarter-speed. Setting the CPU power mode is possible, of course, but needs to be reverse-engineered from the corresponding hypervisor syscall. GPU: A full screen setup is required, including the programming of the ANA-chip. Code is available for setting up a 640x480 VGA mode, support for other resolutions needs to be added. EDRAM must be \"trained\". This is what fails when the E-74 error is displayed. The code is rather complex, and has been reverse-enginnered, but doesn't run properly yet. However, it has been shown to work a bit, and can likely be tweaked to work properly. SATA: SATA likely needs some reset sequence. Linux kernel does this fine, but XeLL doesn't work. All of these issues are expected to be fixed. This hack can also be used to reboot into a Microsoft kernel, in order to keep the possibility of playing games locally. This is not within the scope of this document, and is actually not related to this hack at all. This hack allows you the execution of software - and YOU decide what software that should be. It could be linux, your favourite emulator, or a rebooter. Note that we do not support patching the Microsoft kernel for piracy under any circumstances. Also, playing on LIVE with a modified console won't be possible without getting banned, ever. There are already challenges in place which detect any unauthorized modification. We urge you to not abuse this hack for piracy. EXPLOIT LOADER The first own code which is executed is a small loader, which operates in the following way: If a character is present on the serial port, it will be read. if that character is '@', we will enter serial upload mode. if that character is ' ', we will use the backup bootloader if not serial upload mode: POST 0x10 read bootloader from flash (either backup or normal) POST 0x11 run serial upload mode: output '>' receive characters after 10 consecutive 'x', stop upload output '!' run This allows some kind of recovery if you want to update the in-flash bootloader. The used addresses are the following: FLASH_BASE is the location in flash of the backup bootloader, FLASH_BASE + 0x40000 is the location of the main bootloader, CODE_BASE is the memory address of the bootloader in ram. By default, the following memory map is used: 00000000..00100000: SMC, KV, CB, CD, CE, CF, CG, backup bootloader 00100000..00140000: main bootloader 00140000..00f7c000: empty space 00f7c000 : smc config block 00ffc000 : exploit buffer But this can be tweaked. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"The JTAG/SMC Hack"},{"location":"SMC_Hack/#the-jtagsmc-hack","text":"There is a new hack which can boot homebrew code in less than 5 seconds. See at the end of this document for a description how the hack works. For now, all we need to know is that this is a new way to exploit the well-known 4532 kernel, in a way which also works on updated machines, unless they have been updated by the summer '09 update. It also works on all hardware types. This document is a technical description meant for people who want to undestand the hack. If you don't understand a word, calm down - there probably will be future releaes, howtos etc. Please also notice that from a functional side, the result will be the same as the KK-hack; it's just much faster, works on more hardware and is more reliable. So it replaces the KK-hack, not less and not more. Technical details are available here .","title":"The JTAG/SMC Hack"},{"location":"SMC_Hack/#required-soldering","text":"The SMC Hack requires bridging 3 points on the motherboard (for trigger the exploit by JTAG), as well as having a way to read and write with your Nand Flash - The JTAG points are available for a number of consoles Xenon : Falcon , Zephyr , Opus & ' Jasper ': Falcon , Zephyr , Opus & ' Jasper ' Reverse Jtag: - To read and write the Nand Flash (using SPI protocol by LPT and a printer cable), there is a friendly tutorial at NAND Reading There are other ways to read and write the Nand Flash that are valid (such as infectus modchip) All the diodes used in SPI and JTAG are \"switching diodes\" proposed are: BAT41, 1N4148, or 1N4153","title":"Required Soldering"},{"location":"SMC_Hack/#building-a-homebrew-kernel","text":"","title":"Building a Homebrew-Kernel"},{"location":"SMC_Hack/#from-scratch","text":"","title":"From scratch"},{"location":"SMC_Hack/#what-you-need","text":"Latest build.py Script from GIT CB/CD-files matching for your Xbox Revision (called CB.xxxx/CD.xxxx here, where xxxx is the version) -Xenon: 1921 -Zephyr: 4558 -Falcon: 5770 -Jasper: 6712, 6723 Hacked SMC Code matching your Xbox Revision (called smc_hacked.bin here) ATM only available for XENON / falcon / zephyr / opus(as of recently) The 1888 Basekernel (called 1888image.bin here) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532-Update Compiled XELL (xell-1f.bin, also the same file named xell-backup.bin)","title":"What you need"},{"location":"SMC_Hack/#how-to","text":"1. Check out the latest free60-tools with GIT git clone 2. Extract xboxupd.bin with WxPirs from the unzipped 4532-Dashboard-Update 3. Copy the files xboxupd.bin, 1888image.bin, CB.xxxx/CB.xxxx, smc.hacked and the two XeLL files xell-1f.bin and xell-backup.bin to /tools/imgbuild/input (you need to create the folder first). Also create a folder \"output\" in /tools/imgbuild/ 4. Edit build.py to contain the Secret 1BL Key in this format (Example-Key: 010F0E0C0ED669E7B56794FB68563EFA) secret_1BL = \"\\x01\\x0F\\x0E\\x0C\\x0E\\xD6\\x69\\xE7\\xB5\\x67\\x94\\xFB\\x68\\x56\\x3E\\xFA\" 5. Start build.py with the following command python build.py input/1888image.bin input/CB.xxxx input/CD.xxxx input/xboxupd.bin input/xell-backup.bin input/xell-1f.bin input/smc_hacked.bin If everything works out the Script should output something similar to this * found flash image, unpacking and decrypting... ECC'ed - will unecc. Found 2BL (build 1888) at 00008000 Found 4BL (build 1888) at 0000e1e0 Found 5BL (build 1888) at 000138d0 * found (hopefully) decrypted CB * found (hopefully) raw CD * found update Found 6BL (build 4532) at 00000000 Found 7BL (build 4532) at 000044c0 * found XeLL binary, must be linked to 1c000000 * found XeLL binary, must be linked to 1c000000 * found decrypted SMC * we found the following parts: CB: 1921 CD: 1921 CE: 1888 CF: 4532 CG: 4532 * checking if all files decrypted properly... ok * checking required versions... ok * Fixing up the hacked SMC code with the target address * this image will be valid *only* for: xenon * zero-pairing... * constructing new image... * base size: 70000 * compiling payload stub * Flash Layout: 0x00000000..0x000001ff (0x00000200 bytes) Header 0x00000200..0x000003ff (0x00000200 bytes) Exploit 0x00000400..0x00000fff (0x00000c00 bytes) Padding 0x00001000..0x00003fff (0x00003000 bytes) SMC 0x00004000..0x00007fff (0x00004000 bytes) Keyvault 0x00008000..0x000117ff (0x00009800 bytes) CB 1921 0x00011800..0x00016ebf (0x000056c0 bytes) CD 1921 0x00016ec0..0x0006cf2f (0x00056070 bytes) CE 1888 0x0006cf30..0x0006ffff (0x000030d0 bytes) Padding 0x00070000..0x000744bf (0x000044c0 bytes) CF 4532 0x000744c0..0x000a33ff (0x0002ef40 bytes) CG 4532 0x000a3400..0x000bffff (0x0001cc00 bytes) Padding 0x000c0000..0x000fffff (0x00040000 bytes) Xell (backup) 0x00100000..0x0013ffff (0x00040000 bytes) Xell (main) * Encoding ECC... Written into output/image_00000000.ecc ! please flash output/image_*.ecc, and setup your JTAG device to do the DMA read from 00000200 6. Finished! Your ready-to-be-flashed Image is located in the output-folder, called image_00000000.ecc","title":"How-to"},{"location":"SMC_Hack/#updating-a-hacked-image","text":"","title":"Updating a hacked image"},{"location":"SMC_Hack/#what-you-need_1","text":"Latest build.py Script from GIT Hacked Kernel-Image (hacked-image.bin) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532-Update Compiled XELL (xell-1f.bin)","title":"What you need"},{"location":"SMC_Hack/#how-to_1","text":"1. Checkout free60-tools, extract xboxupd.bin as described above. 2. Copy files hacked-image.bin, xboxupd.bin and xell-1f.bin to /tools/imgbuild/ and create a folder \"output\" there. 3. Start build.py with following command: python build.py hacked-image.bin xboxupd.bin xell-1f.bin 4. Finished! Your updated hacked-image was written into the output directory and is ready to be flashed.","title":"How-to"},{"location":"SMC_Hack/#alternative","text":"If you are using XeLL-compile after 31. August 09 you could use the USB-Update feauture.","title":"Alternative"},{"location":"SMC_Hack/#how-to_2","text":"1. Format a compatible USB Drive to FAT16/32. 2. Put 'xell-1f.bin' renamed to 'updxell.bin' into the Root of the USB Drive. 3. Turn on XeLL-Xbox 360 with attached USB Drive. 4. XeLL should recognize USB Drive and tell you '* found XeLL update. press power NOW if you don't want to update.' 5. Wait for XeLL to tell you '*update done ' and unplug the USB Drive so it won't upgrade on the next startup. 6. Reboot Xbox 360 and enjoy a fresh XeLL.","title":"How-to"},{"location":"SMC_Hack/#extracting-smccbcd-from-a-hacked-image","text":"","title":"Extracting SMC/CB/CD from a hacked image"},{"location":"SMC_Hack/#what-you-need_2","text":"Latest build.py Script from GIT Hacked Kernel-Image (hacked-image.bin) Xbox 360 Dashboard Update Version 4532 (HD_DVD_10-2006.zip) wxPirs to extract xboxupd.bin from 4532 Update","title":"What you need"},{"location":"SMC_Hack/#how-to_3","text":"1. Checkout free60-tools, extract xboxupd.bin as described above 2. Copy files hacked-image.bin and xboxupd.bin to /tools/imgbuild/ and create a folder \"output\" there 3. Start build.py with following command python build.py hacked-image.bin xboxupd.bin 4. Finished! Decrypted SMC, CB and CD data was written into the output directory","title":"How-to"},{"location":"SMC_Hack/#build-a-full-16mb-image-out-of-the-small-one-created-by-build-script","text":"Just use this simple command (input/backup.ecc is your nand backup, and output/full.ecc is a 16MB image you can flash) cp input/backup.ecc output/full.ecc; dd if=output/image_00000000.ecc of=output/full.ecc conv=notrunc","title":"Build a full 16MB Image out of the small one created by build-script"},{"location":"SMC_Hack/#using-the-1920to1921-script","text":"","title":"Using the 1920to1921 script"},{"location":"SMC_Hack/#what-you-need_3","text":"Latest 1920to1921.py Script from GIT decrypted 1921 CB (2BL) decrypted 1920 CD (4BL)","title":"What you need"},{"location":"SMC_Hack/#how-to_4","text":"1. Rename 1921 CB file to CB.1921 (no file extension) and 1920 CD to CD.1920 2. Move both files to /tools/imgbuild/input/ 3. Start 1920to1921.py with following command: python 1920to1921.py xxxx (where xxxx is the CD Version you want to create, i.e 1921, 4558, 5770) 4. Finished! Script should tell you \"great, hash matches!\" and write the appropriative CD to the input folder.","title":"How-to"},{"location":"SMC_Hack/#technical-details","text":"To understand this new hack, let's first look at what made the KK exploit possible: A fatal bug in the Hypervisor's Syscall Handler, introduced in the 4532 kernel update. For more details, take a look at http://www.securityfocus.com/archive/1/461489/30/0/threaded which explains the problem in great detail. The KK exploit exploited the kernel bug by modifying an unsigned shader to do a series of so-called memory exports, an operation where the GPU can write the results of a pixel or vertex shader into physical memory. The shader was written to overwrite the Idle-thread context to make the kernel jump at a certain position in memory, with some registers nder our control. In order to control all registers, a second step was necessary, this time by jumping into the interrupt restore handler. This finally allows all CPU general purpose registers to be filled with etermined values. The program counter could be restored to a syscall instruction in the kernel, with register values prefilled so that they would trigger the exploit. The exploit basically allows jumping into any 32-bit address in hypervisor space. To jump into an arbitrary location, we just used a \"mtctr, bctr\"-register pair in hypervisor, which would redirect execution low into any 64-bit address. This is important, since we need to clear the upper 32bit (i.e.,set the MSB to disable the HRMO), since the code we want to jump to is in unencrypted memory. This code would usually load a second-stage loader, for example XeLL, into memory, and start it. XeLL would then attempt to catch all cpu threads (because just the primary thread is affected by our exploit), and load the user code, for example from DVD. So, the following memory areas are involved: Idle Thread context, at 00130360 in physical memory This stores the stack pointer (and some other stuff) when the idle thread was suspended. By changing the stack pointer, and then waiting for the kernel to switch to the idle thread, the stack pointer can be brought into our control. Part of the context switch is also a context restore, based on the new stack pointer. Context restore, part 1, arbitrary location, KK expl. uses 80130AF0 The thread-context restore doesn't restore all registers, but let's us control the NIP (the \"next instruction\" pointer). We setup NIP to point to the interrupt context restore, which does a SP-relative load of most registers. Context restore, part 2, same base location as part 1 We just re-use the same stack pointer, because the areas where the first context restore and the interrupt context restore load from do not overlap. The second context restore allows us to pre-set all registers with arbitrary 64 bit values. The HV offset, at 00002080 for syscall 0x46 on 4532 Because of the HV bug, we can write this offset into unencrypted memory, giving us the possibility to jump into any location in the hypervisor space (i.e. with a certain \"encryption prefix\"). We usually write 00000350 here, which points to a \"mtctr %r4; bctr\" instruction pair in hypervisor, which lets us jump to %r4. Our loader code, at an arbitrary location This code will be executed from hypervisor. It's the first of our code which will be executed. %r4 on the syscall entry has to point to this code. Only the idle thread context and the HV offset have fixed addresses. It's easily possible to merge this so that only two distinct blocks needs to be written into memory, but it's not possible to merge this into a single block. Fortunately, the NAND controller allows doing DMA reads where the payload data is split from the \"ECC\"-data. Each page has 512 bytes of payload, and 16 bytes of ECC data. Thus, a single DMA read can be used to load all required memory addresses. We chose the Payload to read the Idle Thread Context, the Context Restores and the loader code. The ECC data will carry the HV offset. To do a DMA read, the following NAND registers need to be written: ea00c01c Address for Payload ea00c020 Adresss for ECC ea00c00c address inside NAND ea00c008 command: read DMA (07) The System Management Controller (SMC) is a 8051 core inside the Southbridge. It manages the power sequencing, and is always active when the Xbox 360 has (standby or full) power applied. It controls the frontpanel buttons, has a Realtime clock, decodes IR, controls temperatures and fans and the DVDROM tray. It talks with the frontpanel board to set the LEDs. When the system is running, the kernel can communicate with the SMC, for example to query the realtime clock, open the dvd-tray etc. This happens over a bidirectional FIFO (at ea001080 / ea001090). See the XeLL SMC code for details. The SMC can read the NAND, because it requires access to a special NAND page which contains a SMC config block. This block contains calibration information for the thermal diodes, and the thermal targets etc. The 8051 core has access to NAND registers, which are mapped into the 8051 SFRs. It uses the same protocol as the kernel uses, so it writes an address, does a \"READ\" command, and then reads the data out of the \"DATA\" registers. It could also do a \"READ (DMA)\"-command. So by hacking the SMC, we could make the box do the exploit, without any shader - the SMC can access the NAND controller all the time, even when the kernel is running (though it will likely interfere with the kernel). So, we just trigger the DMA read when the kernel has been loaded, and everything is fine. Right? Well, that would be too easy. While most NAND registers are mapped, the DMA address registers (1c, 20) are not. We can DMA, but only to the default address of zero (or wherever the kernel last DMAed into). Fail. The GPU, the (H)ANA (the \"scaler\" - which in fact doesn't scale at all, it's \"just\" a set of DACs, and, since Zephyr, a DVI/HDMI encoder), the Southbridge and the CPU have their JTAG ports exposed on the board. They are unpopulated headers, but the signals are there. CPU JTAG is a different (complex) story, and SB JTAG doesn't offset much funcationality. ANA JTAG is boring since the ANA doesn't sit on any interesting bus. That leaves GPU JTAG. GPU JTAG was reverse-engineered until a point where arbitrary PCI writes are possible, up to a certain point. So that makes it possible to talk to each PCI device in the system, including the NAND controller. So we can simply use THAT instead of the SMC to start the DMA? Right? Well, not quite. The problem is that the \"VM code\", the code which does a lot of system initialization, like the memory (that code is also responsible for generating the 01xx \"RROD\"-Errors), sets a certain bit in some GPU register, which disables the JTAG interface. The VM code is executed way before the kernel is active. So this is fail, too. But the combination works - by programming the DMA target address via JTAG, and launching the attack via SMC. The attack can be launched as soon as the kernel is running, and quite early, it does query the SMC for the RTC. We abuse this call to start the attack instead, which is a perfect point for us. But how do we run an exploitable kernel at all? Most machines are updated already. Let me refresh your knowledge about the boot process again:","title":"Technical details"},{"location":"SMC_Hack/#1bl-bootrom","text":"Buried deep inside the CPU die, this ~32kb of ROM code is responsible for reading the 2BL from NAND-flash and decrypts it into the embedded SRAM in the CPU. It verifies the hash of the decrypted image with a signed block at the beginning of the 2BL, and will stop execution if this hash mismatches. This code also contains a number of test functions, which can be activated by pulling the 5 \"POST IN\"-pins, which are available on the backside of the PCB. None of these tests looks particulary interesting (from an exploitation perspective) - they mostly seem to be related to the FSB (the bus between CPU and GPU). This code is fixed, and all systems use identical code here.","title":"1BL (Bootrom)"},{"location":"SMC_Hack/#2bl-cb","text":"This code is usually located at 0x8000 in NAND flash. It's decrypted by 1BL, and runs from internal SRAM. It does a basic hardware initialization, and contains the \"fuse check code\", which verifies the \"2BL version\". The fuses store the expected version. The 2BL stores a \"Version\" and a \"AllowedMask\" (=bitfield), and this is usually stored at address 0x3B1 / 0x3B2..0x3B3. Xenon Zephyr Falcon Jasper 2 0003 1888, 1901, 1902 4 1920 \"new zeropair code\" 5 0010 1921 4558 5760,5761,5770 6712 TA-fixed It then verifies the pairing information stored in the 2BL header. Part of this verification is a checksum check of the NAND area which was used to load the SMC code from. It also contains a virtual machine and some code to run on this machine. The virtual machine code, which is pretty complicated, does the following things: Initialisation of the PCI-Bridge Disable the GPU PCIE JTAG test port initialize the serial port talk to the SMC to clear the \"handshake\"-bit initialize memory hopefully not: generate RROD if memory init fails After that, the external (512MB) memory will be initialized and usable. 2BL then decrypts the 4BL into this memory. Memory encryption will already be enabled - no executable code is *ever* written unencrypted.","title":"2BL (\"CB\")"},{"location":"SMC_Hack/#4bl-cd","text":"This code is responsible for checking and unpacking 5BL, as well as applying update patches. First, the fuses are read to determine the console \"Update Sequence\", a number which basically counts the number of updates installed. Since updates are, in the same way as 2BL, paired to a console, this allows to configure the console in a way that no old update will be used. So each update slot stores the maximum value of burned fuses (well, essentially the exact value). The base kernel also has an associated value, usually zero, but this can be changed in the 2BL pairing data block. This is what the timing-attack increments, in order to revert to the 1888 kernel.","title":"4BL (\"CD\")"},{"location":"SMC_Hack/#5bl-hvkernel","text":"The HV and kernel are merged into a single image, which is compressed with a proprietary algorithm (LDIC).","title":"5BL (\"HV/Kernel\")"},{"location":"SMC_Hack/#6bl-cf-7bl-cg","text":"This is part of a system upgrade. Each console has a so-called \"Base Kernel\", which is the 1888 kernel which was available on launch back in 2005. Then there are two \"update slots\" - areas of 64k each (128k on Jasper), which contain a 6BL and 7BL. 6BL is code which applies the update, using a clever delta-compression. 7BL is the actual delta-compressed update, essentially a binary diff. Oh, updates are >64k. So only the first 64k are actually stored in the update slots, the rest is stored in the filesystem as a special file. Since 6BL doesn't contain a filesystem parser, a blockmap is added in 6BL which points to the sectors which contain the rest of the update.","title":"6BL (\"CF\"), 7BL (\"CG\")"},{"location":"SMC_Hack/#zero-pairing","text":"Now there is a special situation: If the 2BL pairing block is all-zero, the pairing block will not be checked. However, a bit is set so that the kernel doesn't boot the dashboard binary, but a special binary called \"MfgBootLauncher\", where \"Mfg\" probably stands for \"Manufacturing\". So this is a leftover of the production process, where the flash image is used on all hardware, probably also before any CPU-key has been programmed. By abusing this feature, this allows us easily to produce a flash image which runs on all hardware. However, 4BL won't look at update slots when it detects this mode, so we end up in the 1888 base kernel. And we can't run the dashboard, so it's impossible to escape this mode. Previously, this has been deemed very uninteresting, because first the 1888 isn't exploitable by the KK exploit, and second because it's impossible to run the KK game anyway. However, starting with 2BL version 1920, an interesting thing happened: The encryption key for 4BL is generated with the help of the CPU-key now. That means that without the CPU-key, it's not possible to decrypt the 4BL anymore. Note that each 2BL has exactly a single valid 4BL binary - 2BL contains a hardcoded hash for the 4BL, and doesn't use RSA. However, zero'ed pairing data is detected, the CPU-key is NOT used in this process, like it was previously. That also means that you cannot just zero-out the pairing data anymore - the 4BL would be decrypted with the wrong key then. Instead you need to decrypt the 4BL (which requires knowing the CPU key), and re-encrypt it with the old algorithm. However, 1920 was suspectible to the timing attack - so a CPU-key recovery was possible on one console, which allowed us to decrypt the 1920 4BL. That 4BL shows a very intersting change: Whenever zero-pairing is detected, the update slots are not ignored anymore. Instead, if the update-slots are zero-paired as well, they are applied. This change allows us to boot any kernel, provided we have a (1920 and up) 2BL/4BL set which runs on that machine. This is very important, because we can build up an image now which runs into the 4532 kernel, regardless on how many update fuses are set. However, the 2BL revocation process must be passed, so we are not completely independent of the fuses, still. But since we use zero-pairing, the SMC hash doesn't matter anymore (there are other ways to work around the SMC hash problem, like the TA, but we get this for free). Still, we boot into the MfgBootLauncher (into the 4532 version now, which does a red/green blinking thingie - you'll notice once you see it, it's very unique and doesn't look like any RROD or so). But thanks to the SMC/JTAG hack described above, this allows us to launch our attack from this state. Newer consoles (which have the TA fix) don't run 1920 anymore. They run, for example, 1921. The problem is that we cannot run HV code on these machines, so we don't know the CPU key. However, when comparing the 1921 and 1920 2BL (which we can still decrypt), the only change is the addition of the timing attack fix (i.e. replacing two memcmp instances with a memdiff function). Also, we know the expected hash value of the decrypted 4BL. Based on a 1920 4BL, and the guess what has changed functionally, and the new size of the 4BL, we were able to guess the modifications, which yields an image which passes the 2BL hash check. Note that this is not a hash collision - we did merely derive the exact image by applying the changes between 1920 2BL and 1921 2BL into 1920 4BL, yielding the 1921 4BL. The 1921 2BL theoretically runs on all machines so far, even TA-proof ones. But it crashes on Zephyr, Falcon and Jasper. The reason is the VM code, which doesn't cover the different GPUs (Xenon has 90nm GPU, Zephyr and Falcon have 80nm, Jasper has 60nm, so there are 3 GPU revisions in total). But the step from 1921 to, say, 4558, is even smaller. It's just the different version number, plus a slight difference in the memcpy code, which again can be ported over from 2BL. Jasper's 67xx is a different thing, since this code adds support for the largeblock flash used in \"Arcade\"-Jasper units. We have used some magic to retrieve this code. So we now have ALL 4BL versions. Isn't that great? It means that ALL machines can run the 4532 kernel. The good news is also that the 4532 kernel supports falcon consoles, and runs long enough to also work on jasper consoles (because we exploit way before the different GPU is touched at all).","title":"Zero-Pairing"},{"location":"SMC_Hack/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"SMC_Hack/#q-the-power-supply-goes-red-when-plugging-in-power","text":"A: You shorted a power pin, probably V33_SB, the one attached to the NAND flash. Carefully look for solder residues. Use a lot of flux and a properly-heated soldering iron.","title":"Q: \"The power supply goes red when plugging in power!\""},{"location":"SMC_Hack/#q-the-power-supply-stays-yellow-when-i-press-the-power-button-and-nothing-else-happens","text":"A: The SMC code is invalid. This can be a misconnected flashrom, an illegal image, a bad flash or simply a bad SMC code. Verify: Electrical connections first. Did you flash with the proper ECC settings? The flash images we are working with usually contain raw ECC information, i.e. 512+16 bytes per sector. Make sure your flash programmer is not modifying these 16 bytes, but writing those as they are. Have you used the right SMC image?","title":"Q: \"The power supply stays yellow when I press the power button, and nothing else happens.\""},{"location":"SMC_Hack/#q-the-fans-run-at-full-speed-immediately","text":"A: This is very likely a bad SMC config sector. Did you flash all the parts generated by the image creation tool at the proper position? Note that offsets are given as payload offsets, not counting ECC bytes. Usually this matches what your average NAND programmer tells you, but in case you re-assembled these into a single image, take care to properly convert the offsets.","title":"Q: \"The fans run at full speed immediately.\""},{"location":"SMC_Hack/#q-i-get-e79","text":"A: This means that, congratulations, your console is still booting into a kernel, and just cannot go further (which was to be exepcted, given that there is no filesystem anymore). You're almost there, but for some reasons, the DMA attack didn't run. This can be either that you didn't used a patched SMC, or that the target address wasn't inserted properly.","title":"Q: \"I get E79\""},{"location":"SMC_Hack/#q-console-powers-on-but-i-get-a-black-screen","text":"A: Well, there are many reasons here again. First, wait some time (~1 minute), and see if you get a RROD. If you do, the VM code failed to handshake with the SMC (error code XXXX), which usually means that it crashed, and the SMC watchdog triggered until it retried too often. Did you use the proper 2BL/4BL image for your machine type? Did you use a recent enough SMC version? Since the VM code took more and more time (from roughly a half second in 1888 to several seconds in 1920), the SMC code was modified to time out later. Be sure to use a known-good SMC version, if possible, based on the version which was installed before. If you don't get a RROD, please try checking your POST code. You can do this via CPU jtag, or by measuring the 8 POST pins. Post code 6C: The exploit failed, somehow. Post code 10: Our code is running! That's great, but it failed copying the XeLL-payload from flash. Try booting into the alternate loader (see below in the \"exploit loader\" section), or reflash. Post code 11: Exploit code ran, and jumped into XeLL. XeLL crashed. Try alternate loader, or do serial upload for recovery, if you really screwed up both the primary and secondary loader. (You failed, in that case.) Post codes >= 0x80: Those are errors from the bootloader. Please check the disassembly of those loaders to see what's wrong exactly. It shouldn't happen unless you have a bad flash. Post code 0xA0: Your 2BL didn't want to run on your hardware due to the 2BL revocation fuses. Use a more recent 2BL/4BL set for your hardware. If you're already running {1921, 4558, 5770, 6712} then you're out of luck. Your box was already updated to a newer 2BL, which likely fixed what we used to exploit. Restore R6T3, restore the flash image, and use this console for playing games. Get another console, and try again. Please note that some hardware elements are not properly initialized at the early time of the exploit. This affects: CPU: The CPU is initialized in low-power mode, where it runs at quarter-speed. Setting the CPU power mode is possible, of course, but needs to be reverse-engineered from the corresponding hypervisor syscall. GPU: A full screen setup is required, including the programming of the ANA-chip. Code is available for setting up a 640x480 VGA mode, support for other resolutions needs to be added. EDRAM must be \"trained\". This is what fails when the E-74 error is displayed. The code is rather complex, and has been reverse-enginnered, but doesn't run properly yet. However, it has been shown to work a bit, and can likely be tweaked to work properly. SATA: SATA likely needs some reset sequence. Linux kernel does this fine, but XeLL doesn't work. All of these issues are expected to be fixed. This hack can also be used to reboot into a Microsoft kernel, in order to keep the possibility of playing games locally. This is not within the scope of this document, and is actually not related to this hack at all. This hack allows you the execution of software - and YOU decide what software that should be. It could be linux, your favourite emulator, or a rebooter. Note that we do not support patching the Microsoft kernel for piracy under any circumstances. Also, playing on LIVE with a modified console won't be possible without getting banned, ever. There are already challenges in place which detect any unauthorized modification. We urge you to not abuse this hack for piracy.","title":"Q: \"Console powers on, but I get a black screen.\""},{"location":"SMC_Hack/#exploit-loader","text":"The first own code which is executed is a small loader, which operates in the following way: If a character is present on the serial port, it will be read. if that character is '@', we will enter serial upload mode. if that character is ' ', we will use the backup bootloader if not serial upload mode: POST 0x10 read bootloader from flash (either backup or normal) POST 0x11 run serial upload mode: output '>' receive characters after 10 consecutive 'x', stop upload output '!' run This allows some kind of recovery if you want to update the in-flash bootloader. The used addresses are the following: FLASH_BASE is the location in flash of the backup bootloader, FLASH_BASE + 0x40000 is the location of the main bootloader, CODE_BASE is the memory address of the bootloader in ram. By default, the following memory map is used: 00000000..00100000: SMC, KV, CB, CD, CE, CF, CG, backup bootloader 00100000..00140000: main bootloader 00140000..00f7c000: empty space 00f7c000 : smc config block 00ffc000 : exploit buffer But this can be tweaked. Category:Xbox360 System Software Category:Xbox360_Hardware","title":"EXPLOIT LOADER"},{"location":"SMS_Plus/","text":"REDIRECT Sega Master System Plus","title":"SMS Plus"},{"location":"SPA/","text":"SPA files are contained inside XEX files or within Updates or DLC. They are just a XDBF file, they are used by the dashboard for GPD creation and Xbox LIVE information. Record Table Record Namespaces Value Description 1 Metadata 2 Images 3 String Tables Record Structures Metadata Each record here is set out differently depending on there magic. XACH This is just a table of Achievements. Offset Length Type Information 0 4 string Magic (XACH) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size (- Magic) 0xC 0x2 unsigned short Achievement Count 0xE Achievement Count * 36 (0x24) achievement structure (see below) Achievements Achievement Structure Offset Length Type Information 0x0 0x2 unsigned short Achievement ID 0x2 0x2 unsigned short Title String ID 0x4 0x2 unsigned short Unlocked Description ID 0x6 0x2 unsigned short Locked Description ID 0x8 0x4 unsigned int Image ID 0xC 0x2 unsigned short Gamerscore 0xE 0x2 unsigned short Unused 0x10 0x4 unsigned int Flags 0x14 0x4 unsigned int Unused 0x18 0x4 unsigned int Unused 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused XCXT TODO: what this stores Offset Length Type Information 0 4 string Magic (XCXT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 16 Record structure (see below) Records Record Structure Offset Length Type Information 0 4 UInt32 Unknown 4 4 UInt32 Unknown 8 4 UInt32 Unknown 12 4 UInt32 Unknown TODO: Unknown XITB This record just stores the ImagePath + ID's. Offset Length Type Information 0 4 string Magic (XITB) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Image Count 16 Image Count * 16 Image structure (see below) Images Image Structure Offset Length Type Information 0 4 UInt32 ImageID 4 4 UInt32 Name Length 8 Name Length String Image Path XMAT TODO: What this stores Offset Length Type Information 0 4 string Magic (XMAT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown TODO: Unknown XPBM TODO: What this stores Offset Length Type Information 0 4 string Magic (XPBM) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown TODO: Unknown XPRP TODO: what this stores Offset Length Type Information 0 4 string Magic (XPRP) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 8 Record structure (see below) Records Record Structure Offset Length Type Information 0 8 Byte[] Unknown TODO: Unknown, (2 int32's?) XRPT This record just stores a series of XPMB files. Offset Length Type Information 0 4 string Magic (XRPT) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 XPMB XPBM 2 UInt16 XPBM Count XPBM[XPBM Count] Sub XPBMs XSRC This file is something todo with xlast, (a source file?) Offset Length Type Information 0 4 string Magic (XSRC) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 4 UInt32 NameLength 16 NameLength String (original?)filename 16 + NameLength Structure Size - 8 Byte[] Unknown(compressed?) TODO:Unknown XSTC TODO: What this stores Offset Length Type Information 0 4 string Magic (XSTC) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Unknown TODO: Unknown XTHD Offset Length Type Information 0 4 unsigned int Magic (XTHD) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size 0xC 0x4 unsigned int Title ID 0x10 0x4 unsigned int Title Type (0 = system, 1 = full, 2 = demo, 3 = download) 0x14 0x2 unsigned short Project Version Major 0x16 0x2 unsigned short Project Version Minor 0x18 0x2 unsigned short Project Version Build 0x1A 0x2 unsigned short Project Version Revision 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused 0x24 0x4 unsigned int Unused 0x28 0x4 unsigned int Unused Is StructureSize null for anyone else? only in this record. XVC2 This record just stores a series of XPBM files, and (TODO:Unknown). Offset Length Type Information 0 4 string Magic (XVC2) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 2 UInt16 XPBM Count 14 204 Byte[] Unknown 208 XPBM[] XPBM's TODO: Unknown Images Image entries are composed of a PNG image. String Tables XSTR All these records are set out the same however some have a unknown byte[] after the string. Offset Length Type Information 0 4 string Magic (XSTR) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt16 String Count 16 String structure (see below) Strings String Structure Offset Length Type Information 0 2 UInt16 String ID 2 2 UInt16 String Length 4 String Length String String Category:Xbox360_System_Software","title":"SPA"},{"location":"SPA/#record-table","text":"","title":"Record Table"},{"location":"SPA/#record-namespaces","text":"Value Description 1 Metadata 2 Images 3 String Tables","title":"Record Namespaces"},{"location":"SPA/#record-structures","text":"","title":"Record Structures"},{"location":"SPA/#metadata","text":"Each record here is set out differently depending on there magic.","title":"Metadata"},{"location":"SPA/#xach","text":"This is just a table of Achievements. Offset Length Type Information 0 4 string Magic (XACH) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size (- Magic) 0xC 0x2 unsigned short Achievement Count 0xE Achievement Count * 36 (0x24) achievement structure (see below) Achievements","title":"XACH"},{"location":"SPA/#achievement-structure","text":"Offset Length Type Information 0x0 0x2 unsigned short Achievement ID 0x2 0x2 unsigned short Title String ID 0x4 0x2 unsigned short Unlocked Description ID 0x6 0x2 unsigned short Locked Description ID 0x8 0x4 unsigned int Image ID 0xC 0x2 unsigned short Gamerscore 0xE 0x2 unsigned short Unused 0x10 0x4 unsigned int Flags 0x14 0x4 unsigned int Unused 0x18 0x4 unsigned int Unused 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused","title":"Achievement Structure"},{"location":"SPA/#xcxt","text":"TODO: what this stores Offset Length Type Information 0 4 string Magic (XCXT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 16 Record structure (see below) Records","title":"XCXT"},{"location":"SPA/#record-structure","text":"Offset Length Type Information 0 4 UInt32 Unknown 4 4 UInt32 Unknown 8 4 UInt32 Unknown 12 4 UInt32 Unknown TODO: Unknown","title":"Record Structure"},{"location":"SPA/#xitb","text":"This record just stores the ImagePath + ID's. Offset Length Type Information 0 4 string Magic (XITB) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Image Count 16 Image Count * 16 Image structure (see below) Images","title":"XITB"},{"location":"SPA/#image-structure","text":"Offset Length Type Information 0 4 UInt32 ImageID 4 4 UInt32 Name Length 8 Name Length String Image Path","title":"Image Structure"},{"location":"SPA/#xmat","text":"TODO: What this stores Offset Length Type Information 0 4 string Magic (XMAT) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown TODO: Unknown","title":"XMAT"},{"location":"SPA/#xpbm","text":"TODO: What this stores Offset Length Type Information 0 4 string Magic (XPBM) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 Structure Size - 8 Byte[] Unknown TODO: Unknown","title":"XPBM"},{"location":"SPA/#xprp","text":"TODO: what this stores Offset Length Type Information 0 4 string Magic (XPRP) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Record Count 16 Record Count * 8 Record structure (see below) Records","title":"XPRP"},{"location":"SPA/#record-structure_1","text":"Offset Length Type Information 0 8 Byte[] Unknown TODO: Unknown, (2 int32's?)","title":"Record Structure"},{"location":"SPA/#xrpt","text":"This record just stores a series of XPMB files. Offset Length Type Information 0 4 string Magic (XRPT) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 XPMB XPBM 2 UInt16 XPBM Count XPBM[XPBM Count] Sub XPBMs","title":"XRPT"},{"location":"SPA/#xsrc","text":"This file is something todo with xlast, (a source file?) Offset Length Type Information 0 4 string Magic (XSRC) 4 4 UInt32 Version 8 4 UInt32 Structure Size 12 4 UInt32 NameLength 16 NameLength String (original?)filename 16 + NameLength Structure Size - 8 Byte[] Unknown(compressed?) TODO:Unknown","title":"XSRC"},{"location":"SPA/#xstc","text":"TODO: What this stores Offset Length Type Information 0 4 string Magic (XSTC) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt32 Unknown TODO: Unknown","title":"XSTC"},{"location":"SPA/#xthd","text":"Offset Length Type Information 0 4 unsigned int Magic (XTHD) 0x4 0x4 unsigned int Structure Version 0x8 0x4 unsigned int Structure Size 0xC 0x4 unsigned int Title ID 0x10 0x4 unsigned int Title Type (0 = system, 1 = full, 2 = demo, 3 = download) 0x14 0x2 unsigned short Project Version Major 0x16 0x2 unsigned short Project Version Minor 0x18 0x2 unsigned short Project Version Build 0x1A 0x2 unsigned short Project Version Revision 0x1C 0x4 unsigned int Unused 0x20 0x4 unsigned int Unused 0x24 0x4 unsigned int Unused 0x28 0x4 unsigned int Unused Is StructureSize null for anyone else? only in this record.","title":"XTHD"},{"location":"SPA/#xvc2","text":"This record just stores a series of XPBM files, and (TODO:Unknown). Offset Length Type Information 0 4 string Magic (XVC2) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 2 UInt16 XPBM Count 14 204 Byte[] Unknown 208 XPBM[] XPBM's TODO: Unknown","title":"XVC2"},{"location":"SPA/#images","text":"Image entries are composed of a PNG image.","title":"Images"},{"location":"SPA/#string-tables","text":"","title":"String Tables"},{"location":"SPA/#xstr","text":"All these records are set out the same however some have a unknown byte[] after the string. Offset Length Type Information 0 4 string Magic (XSTR) 4 4 UInt32 Version 8 4 UInt32 Structure Size (- Magic) 12 4 UInt16 String Count 16 String structure (see below) Strings","title":"XSTR"},{"location":"SPA/#string-structure","text":"Offset Length Type Information 0 2 UInt16 String ID 2 2 UInt16 String Length 4 String Length String String Category:Xbox360_System_Software","title":"String Structure"},{"location":"SPI/","text":"General The SPI bus (Serial Peripheral Interface) on the Xbox360 is mainly used for communicating with the NAND-Flash Controller (SFCX) , a SPI Programmer is needed for this. The bus consists of the following signals: Name Description MOSI Master out, Slave in SS Slave Select SCK Serial Clock MISO Master in, Slave out XEJ Eject XXX ? FAT Motherboard The Diagram matches following Xbox360 Motherboard-revisions: Xenon , Zephyr , Falcon , Opus , Jasper . SLIM Motherboard The Diagram can be used for Xbox360 Motherboard-revision: Trinity","title":"General"},{"location":"SPI/#general","text":"The SPI bus (Serial Peripheral Interface) on the Xbox360 is mainly used for communicating with the NAND-Flash Controller (SFCX) , a SPI Programmer is needed for this. The bus consists of the following signals: Name Description MOSI Master out, Slave in SS Slave Select SCK Serial Clock MISO Master in, Slave out XEJ Eject XXX ?","title":"General"},{"location":"SPI/#fat-motherboard","text":"The Diagram matches following Xbox360 Motherboard-revisions: Xenon , Zephyr , Falcon , Opus , Jasper .","title":"FAT Motherboard"},{"location":"SPI/#slim-motherboard","text":"The Diagram can be used for Xbox360 Motherboard-revision: Trinity","title":"SLIM Motherboard"},{"location":"SPI_Programmer/","text":"General To communicate with the Flash Controller you need a device which is captable of the Xbox 360's SPI Protocol . There are ready-to-use devices you can buy or, if you aren't afraid of soldering your own hardware, DIY homebrew devices. Basicly: Get the device programmed (if needed) and solder it according to the Diagram to your Xbox's mainboard - you can start reading/writing to your NAND after installing the needed drivers. DIY / Homebrew LPT SPI Programmer This type of programmer isn't really recommended as it's awfully slow and can probably cause high failure rates. Description coming later... USB SPI Programmer Needed material: 1x 50X100 PCB 1x 12 MHz Resonator 1x 220nF Capacitor 1x 100nF Capacitor 1x 10 kOhm Resistor 6x 100 Ohm Resistor 1x 1 Row x 10 Pin - 2,54mm Pin Headers (male) 1x 1 Row x 10 Pin - 2,54mm Pin Headers (female) 1x PIC 18F2455-I/SP 1x USB Conector (female) 1x Matching USB Cable Wire Program the PIC with your favorite PIC Programmer (Can be build or bought - for building one yourself the \"ART2003\" is recommended) with the latest \"Picflash\" HEX file. LPC2148 Description coming later... AT90USB162 Programmer Description coming later... Ready to use There are several ready-to-use professional products like: Team Xecuter NAND-X, Maximus 360NandFlasher, Matrix SPI Programmer etc. They arrive preprogrammed and can be used directly with Software like NANDPro to interact with the NAND Flash.","title":"General"},{"location":"SPI_Programmer/#general","text":"To communicate with the Flash Controller you need a device which is captable of the Xbox 360's SPI Protocol . There are ready-to-use devices you can buy or, if you aren't afraid of soldering your own hardware, DIY homebrew devices. Basicly: Get the device programmed (if needed) and solder it according to the Diagram to your Xbox's mainboard - you can start reading/writing to your NAND after installing the needed drivers.","title":"General"},{"location":"SPI_Programmer/#diy-homebrew","text":"","title":"DIY / Homebrew"},{"location":"SPI_Programmer/#lpt-spi-programmer","text":"This type of programmer isn't really recommended as it's awfully slow and can probably cause high failure rates. Description coming later...","title":"LPT SPI Programmer"},{"location":"SPI_Programmer/#usb-spi-programmer","text":"Needed material: 1x 50X100 PCB 1x 12 MHz Resonator 1x 220nF Capacitor 1x 100nF Capacitor 1x 10 kOhm Resistor 6x 100 Ohm Resistor 1x 1 Row x 10 Pin - 2,54mm Pin Headers (male) 1x 1 Row x 10 Pin - 2,54mm Pin Headers (female) 1x PIC 18F2455-I/SP 1x USB Conector (female) 1x Matching USB Cable Wire Program the PIC with your favorite PIC Programmer (Can be build or bought - for building one yourself the \"ART2003\" is recommended) with the latest \"Picflash\" HEX file.","title":"USB SPI Programmer"},{"location":"SPI_Programmer/#lpc2148","text":"Description coming later...","title":"LPC2148"},{"location":"SPI_Programmer/#at90usb162-programmer","text":"Description coming later...","title":"AT90USB162 Programmer"},{"location":"SPI_Programmer/#ready-to-use","text":"There are several ready-to-use professional products like: Team Xecuter NAND-X, Maximus 360NandFlasher, Matrix SPI Programmer etc. They arrive preprogrammed and can be used directly with Software like NANDPro to interact with the NAND Flash.","title":"Ready to use"},{"location":"STFS/","text":"STFS (Secure Transacted File System) is the file system used by the Xbox 360 for all packages created and downloaded by the system. It is protected using a series of SHA1 hashes and a RSA signature. STFS is commonly found in Xbox 360 Content Packages (XContent), but is not limited to those only as the PEC (Profile Embedded Content) files employ STFS. The two known categories for STFS are read-only and writeable. Read-only content packages are found with a PIRS/LIVE signed header and writeable content packages are console signed (CON). STFS The 360 uses packages to transfer saves/content/games/pictures and more. Most packages start with the strings PIRS, LIVE or \"CON \", some are even embedded inside gamer profiles (using the PEC format described below). All of these are STFS content packages which hold the real files along with metadata that the dashboard reads like the title, the licenses and the RSA signature which is used to verify the package. The acronym STFS stands for Secure Transacted File System, which shows how the packages are secure (signature and hashes) and transacted (multiple file / directory revisions) LIVE and PIRS files come from Xbox Live, these are signed using a private key that only Microsoft has. The console uses a public key which is hardcoded inside it to verify the package and make sure the person is allowed to use it. CON files are created by the console for saves and profiles. The console uses its own private key to sign CON files. Many editors are available for saves and profiles which can be used with no modification to the console. Throughout an STFS package, there is a series of SHA1 hashes used to verify the package, and help with downloads (if a block isn't valid, it can be redownloaded). The hashes are located at certain parts of the file, a way of calculating where is (will be!) down below. Volume Descriptor There are 2 types of volume descriptor a content file may have, one for STFS packages and another for SVOD STFS Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Reserved 0x02 0x01 byte Block Seperation 0x03 0x02 signed short File Table Block Count 0x05 0x03 signed int24 File Table Block Number 0x08 0x14 byte[] Top Hash Table Hash 0x1C 0x04 signed int Total Allocated Block Count 0x20 0x04 signed int Total Unallocated Block Count SVOD Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Block Cache Element Count 0x02 0x01 byte Worker Thread Processor 0x03 0x01 byte Worker Thread Priority 0x04 0x14 byte[] Hash 0x18 0x01 byte Device features 0x19 0x03 uint24 Data block count 0x1C 0x03 uint24 Data block offset 0x1F 0x05 byte[] Padding/reserved Content Packages Header Offset Length Type Information 0x0 0x4 ascii string Magic The magic can be one of the following: Signature Type Information \"CON \" Signed by a console. Found on many files such as cache files, profiles, saved games. PIRS Signed by Microsoft. Found on files delivered by Microsoft through non-Xbox Live means such as system updates. LIVE Signed by Microsoft. Found on files delivered over Xbox Live such as items from the Marketplace like themes. The following is used for Console Signed (\"CON \") packages, and is used by the Xbox as the format for signatures generated by it: Offset Length Type Information 0x4 0x2 bytes Public Key Certificate Size 0x6 0x5 bytes Certificate Owner Console ID 0xB 0x14 ascii string Certificate Owner Console Part Number 0x1F 0x1 byte Certificate Owner Console Type (1 for devkit, 2 for retail) 0x20 0x8 ascii string Certificate Date of Generation 0x28 0x4 bytes Public Exponent 0x2C 0x80 bytes Public Modulus 0xAC 0x100 bytes Certificate Signature 0x1AC 0x80 bytes Signature and for remotely signed (LIVE/PIRS) packages: Offset Length Type Information 0x4 0x100 bytes Package Signature 0x104 0x128 bytes Padding The Package Signature is generated using the value at 0x32C (Content ID/Header SHA1). Metadata Offset Length Type Information 0x22C 0x100 license entries (see below) Licensing Data (used to check package owner) 0x32C 0x14 bytes Header SHA1 Hash (from 0x344 to first hash table) 0x340 0x4 unsigned int HeaderSize 0x344 0x4 signed int Content Type (see below) 0x348 0x4 signed int Metadata Version (see below) 0x34C 0x8 signed long Content Size 0x354 0x4 unsigned int Media ID 0x358 0x4 signed int Version (system/title updates) 0x35C 0x4 signed int Base Version (system/title updates) 0x360 0x4 unsigned int Title ID 0x364 0x1 byte Platform (Xbox 360 = 2/PC = 4) 0x365 0x1 byte Executable Type 0x366 0x1 byte Disc Number 0x367 0x1 byte Disc In Set 0x368 0x4 unsigned int Save Game ID 0x36C 0x5 bytes Console ID 0x371 0x8 bytes Profile ID 0x379 0x24 [[STFS#Volume_Descriptor Volume Descriptor]] 0x39D 0x4 signed int Data File Count 0x3A1 0x8 signed long Data File Combined Size 937 4 int32(STFS = 0, SVOD = 1) Descriptor type 941 4 int32 Reserved 0x3B1 0x4C bytes Padding 0x3FD 0x14 bytes Device ID 0x411 0x900 (each 0x80 = different locale) unicode string Display Name 0xD11 0x900 (each 0x80 = different locale) unicode string Display Description 0x1611 0x80 unicode string Publisher Name 0x1691 0x80 unicode string Title Name 0x1711 0x1 byte Transfer Flags (see below) 0x1712 0x4 signed int Thumbnail Image Size 0x1716 0x4 signed int Title Thumbnail Image Size 0x171A 0x4000 (thumbnail size) image Thumbnail Image 0x571A 0x4000 (title thumbnail size) image Title Thumbnail Image Version 2 If the Metadata Version field is set to 2, the format is slightly changed: Offset Length Type Information 0x3B1 0x10 bytes Series ID 0x3C1 0x10 bytes Season ID 0x3D1 0x2 signed short Season Number 0x3D5 0x2 signed short Episode Number 0x3D5 0x28 bytes Padding 0x171A 0x3D00 (thumbnail size) image Thumbnail Image 0x541A 0x300 (each 0x80 = different locale) image Additional Display Names 0x571A 0x3D00 (title thumbnail size) image Title Thumbnail Image 0x941A 0x300 (each 0x80 = different locale) image Additional Display Descriptions License Entries For every entry in the license data field: Offset Length Type Information 0x0 0x8 signed long License ID (XUID / PUID / console id) 0x8 0x4 signed int License Bits 0xC 0x4 signed int License Flags Content Types Value Description 0xD0000 Arcade Title 0x9000 Avatar Item 0x40000 Cache File 0x2000000 Community Game 0x80000 Game Demo 0x7000 Game on Demand 0x20000 Gamer Picture 0xA0000 Game Title 0xC0000 Game Trailer 0x400000 Game Video 0x4000 Installed Game 0xB0000 Installer 0x2000 IPTV Pause Buffer 0xF0000 License Store 0x2 Marketplace Content 0x100000 Movie 0x300000 Music Video 0x500000 Podcast Video 0x10000 Profile 0x3 Publisher 0x1 Saved Game 0x50000 Storage Download 0x30000 Theme 0x200000 TV 0x90000 Video 0x600000 Viral Video 0x70000 Xbox Download 0x5000 Xbox Original Game 0x60000 Xbox Saved Game 0x1000 Xbox 360 Title 0x5000 Xbox Title 0xE0000 XNA Transfer Flags Value Description 0x00 DeviceID and ProfileID Transfer 0x20 Move Only Transfer 0x40 DeviceID Transfer 0x80 ProfileID Transfer 0xC0 None These are bit flags, dunno why everyone treats like enum. Bit0: None(Yet?) Bit1: None Bit2: Deep Link Supported Bit3: Disable Network Storage Bit4: Kinect Enabled Bit5: Move Only Transfer Bit6: Device Transfer Bit7: Profile Transfer Profile Embedded Content (PEC) When extra security is needed for content which is already using STFS, PEC files may be used to add an extra layer on top. PEC files use the STFS descriptor and algorithms, but has no similarity with content packages. PEC files are only currently used for avatar items/clothing. Block 0 starts at 0x3000, and hash table 0 at 0x1000/0x2000. Header Offset Length Type Information 0x0 0x228 [[Console_Security_Certificate Console Security Certificate]] 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 [[STFS#STFS_2 Volume Descriptor (STFS)]] 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID File Listing The value at 0x37E (File Table Block Number on the structure above) determines where the file table begins. As it is a block number, you will have to convert it to an offset. Here is some code in C# for converting: internal int BlockToOffset(int xBlock) { int xReturn = 0; if (xBlock > 0xFFFFFF) xReturn = -1; else xReturn = (((MetaData.HeaderSize + 0xFFF) & 0xF000) + (xBlock << 12)); return xReturn; } internal int ComputeDataBlockNumber(int xBlock) { int xBlockShift; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockShift = 1; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockShift = 0; else xBlockShift = 1; int xBase = ((xBlock + 0xAA) / 0xAA); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xBase = (xBase << xBlockShift); int xReturn = (xBase + xBlock); if (xBlock > 0xAA) { xBase = ((xBlock + 0x70E4) / 0x70E4); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xBase = (xBase << xBlockShift); xReturn += xBase; if (xBlock > 0x70E4) { xBase = ((xBlock + 0x4AF768) / 0x4AF768); if (this.Header.Magic == xBlockShift) xBase = (xBase << 1); xReturn = (xReturn + xBase); } } return xReturn; } Each embedded file starts at a 4096 byte boundary. The optional space between embedded files is filled with null bytes. The file listing consists of entries which have the format below. The listing ends with an entry consisting of only null bytes. Offset Length Type Information 0x0 0x28 ascii string File name, null-padded 0x28 0x1 byte Length of file name, plus flags 0x29 0x3 signed int24 Number of blocks allocated for file (little endian) 0x2C 0x3 signed int24 Copy of 0x29 0x2F 0x3 signed int24 Starting block number of file (little endian) 0x32 0x2 signed short Path indicator (big endian) 0x34 0x4 unsigned int Size of file in bytes (big endian) 0x38 0x4 signed int Update date/time stamp of file 0x3C 0x4 signed int Access date/time stamp of file Byte 0x28 also has two flags: bit 6 and bit 7. If bit 6 is set it means that all of the blocks in the file are consecutive. Bit 7 indicates that the file is a directory. The first 6 bits 0-5, are the length of the filename. public System.Boolean IsDirectory//bit 7 { get { return (Flags & 128) == 128; } set { if (value != IsDirectory) { Flags ^= 128; } } } //public System.Boolean IsUnknown//bit 6 //{ // get // { // return (Flags & 64) == 64; // } // set // { // if (value != IsUnknown) // { // Flags ^= 64; // } // } //} public System.Byte NameLength//first 6 bits { get { return (System.Byte)(Flags & 63); } set { Flags ^= (System.Byte)(value ^ NameLength); } } The path indicator indicates the path of the file. -1 (0xFFFF) means that the file is in the root directory, any other value V refers to the (sub)directory which is listed as the Vth entry in the listing (counting from 0). Directories can nest. The FAT format is used for the date/time stamps of the files. Hash Tables / Block Offsets A block is 0x1000 (4096) bytes and the first block is located at 0xC000. Every 0xAA (170) blocks there is a block that contains a hash of each block and every 0xAA*0xAA (0x70E4) blocks there is another table (presumably hashing the 0xAA table blocks). This means that when using a block number from a file listing you need to account for the hash tables which are not included in the block numbering system. For example block 171 is actually located where you would expect block 172 to reside ((171 + int(171/170)) * 0x1000 + 0xC000). Offset Length Type Information 0x0 0x14 byte Hash(SHA1) 0x14 0x1 byte Status byte 0x15 0x3 Int24 Next block The status byte is very important when injecting files into a package. Here are the meanings of them. Value Meaning 0x00 Unused Block 0x40 Free Block (previously used) 0x80 Used Block 0x80 Used Block 0xC0 Newly Allocated Block Files are not always stored in consecutive blocks, you have to find the corresponding hash table record and read the next block number (similar to cluster maps in FAT). Here is some C# code for converting a block to it's hash table position( it may not work perfectly! ): internal int ComputeLevelNHashBlockNumber(int xBlock, int xLevel) { int xBlockShift; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockShift = 1; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockShift = 0; else xBlockShift = 1; int[] xBlockStep; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockStep = new[] { 0xAC, 0x723A }; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockStep = new[] { 0xAB, 0x718F }; else xBlockStep = new[] { 0xAC, 0x723A }; int xReturn; int xBase; int xStep = xBlockStep[1]; if (xLevel == 0) { xReturn = (xBlock / 0xAA); xStep = (xReturn * xBlockStep[0]); if (xReturn != 0) { xReturn = (xBlock / 0x70E4); xBase = (xReturn + 1); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xStep += (xBase << xBlockShift); else xStep += xBase; if (xReturn == 0) return xStep; else { if (this.Header.Magic == XContent_Header.Header_Magic.CON) return (xStep + (1 << xBlockShift)); else return (xStep + 1); } } else return xStep; } else if (xLevel == 1) { xReturn = (xBlock / 0x70E4); xBase = (xReturn * xStep); if (xReturn != 0) { if (this.Header.Magic == XContent_Header.Header_Magic.CON) return (xBase + (1 << xBlockShift)); else return (xBase + 1); } else return (xBase + xBlockStep[0]); } else if (xLevel == 2) { return xStep; } else { throw new Exception(\"Level Unknown: \" + xLevel.ToString()); return 0xFFFFFF; } } Tools An (old) tool (Python 2.5 required) to analyze and extract these archive files is available at extract360.py (2008-08-03, 23056 bytes, MD5 = 3aa517c83d01c618927b78d0ca665d02) wxPirs 1.1 can extract from LIVE/PIRS files fine, but as it doesn't use hash tables properly it doesn't work well with CON files. A newer tool was released by DJ Shepherd called Le Fluffie , which can create and extract from CON/LIVE/PIRS files (but it has some problems with creation, some prefer to use XLAST) XLAST inside the Xbox 360 SDK can create LIVE/PIRS packages, but it is illegal to share it. A new python library py360 can read STFS files Category:Xbox360 System Software","title":"STFS"},{"location":"STFS/#stfs","text":"The 360 uses packages to transfer saves/content/games/pictures and more. Most packages start with the strings PIRS, LIVE or \"CON \", some are even embedded inside gamer profiles (using the PEC format described below). All of these are STFS content packages which hold the real files along with metadata that the dashboard reads like the title, the licenses and the RSA signature which is used to verify the package. The acronym STFS stands for Secure Transacted File System, which shows how the packages are secure (signature and hashes) and transacted (multiple file / directory revisions) LIVE and PIRS files come from Xbox Live, these are signed using a private key that only Microsoft has. The console uses a public key which is hardcoded inside it to verify the package and make sure the person is allowed to use it. CON files are created by the console for saves and profiles. The console uses its own private key to sign CON files. Many editors are available for saves and profiles which can be used with no modification to the console. Throughout an STFS package, there is a series of SHA1 hashes used to verify the package, and help with downloads (if a block isn't valid, it can be redownloaded). The hashes are located at certain parts of the file, a way of calculating where is (will be!) down below.","title":"STFS"},{"location":"STFS/#volume-descriptor","text":"There are 2 types of volume descriptor a content file may have, one for STFS packages and another for SVOD","title":"Volume Descriptor"},{"location":"STFS/#stfs_1","text":"Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Reserved 0x02 0x01 byte Block Seperation 0x03 0x02 signed short File Table Block Count 0x05 0x03 signed int24 File Table Block Number 0x08 0x14 byte[] Top Hash Table Hash 0x1C 0x04 signed int Total Allocated Block Count 0x20 0x04 signed int Total Unallocated Block Count","title":"STFS"},{"location":"STFS/#svod","text":"Offset Length Type Information 0x00 0x01 byte Volume descriptor size (0x24) 0x01 0x01 byte Block Cache Element Count 0x02 0x01 byte Worker Thread Processor 0x03 0x01 byte Worker Thread Priority 0x04 0x14 byte[] Hash 0x18 0x01 byte Device features 0x19 0x03 uint24 Data block count 0x1C 0x03 uint24 Data block offset 0x1F 0x05 byte[] Padding/reserved","title":"SVOD"},{"location":"STFS/#content-packages","text":"","title":"Content Packages"},{"location":"STFS/#header","text":"Offset Length Type Information 0x0 0x4 ascii string Magic The magic can be one of the following: Signature Type Information \"CON \" Signed by a console. Found on many files such as cache files, profiles, saved games. PIRS Signed by Microsoft. Found on files delivered by Microsoft through non-Xbox Live means such as system updates. LIVE Signed by Microsoft. Found on files delivered over Xbox Live such as items from the Marketplace like themes. The following is used for Console Signed (\"CON \") packages, and is used by the Xbox as the format for signatures generated by it: Offset Length Type Information 0x4 0x2 bytes Public Key Certificate Size 0x6 0x5 bytes Certificate Owner Console ID 0xB 0x14 ascii string Certificate Owner Console Part Number 0x1F 0x1 byte Certificate Owner Console Type (1 for devkit, 2 for retail) 0x20 0x8 ascii string Certificate Date of Generation 0x28 0x4 bytes Public Exponent 0x2C 0x80 bytes Public Modulus 0xAC 0x100 bytes Certificate Signature 0x1AC 0x80 bytes Signature and for remotely signed (LIVE/PIRS) packages: Offset Length Type Information 0x4 0x100 bytes Package Signature 0x104 0x128 bytes Padding The Package Signature is generated using the value at 0x32C (Content ID/Header SHA1).","title":"Header"},{"location":"STFS/#metadata","text":"Offset Length Type Information 0x22C 0x100 license entries (see below) Licensing Data (used to check package owner) 0x32C 0x14 bytes Header SHA1 Hash (from 0x344 to first hash table) 0x340 0x4 unsigned int HeaderSize 0x344 0x4 signed int Content Type (see below) 0x348 0x4 signed int Metadata Version (see below) 0x34C 0x8 signed long Content Size 0x354 0x4 unsigned int Media ID 0x358 0x4 signed int Version (system/title updates) 0x35C 0x4 signed int Base Version (system/title updates) 0x360 0x4 unsigned int Title ID 0x364 0x1 byte Platform (Xbox 360 = 2/PC = 4) 0x365 0x1 byte Executable Type 0x366 0x1 byte Disc Number 0x367 0x1 byte Disc In Set 0x368 0x4 unsigned int Save Game ID 0x36C 0x5 bytes Console ID 0x371 0x8 bytes Profile ID 0x379 0x24 [[STFS#Volume_Descriptor Volume Descriptor]] 0x39D 0x4 signed int Data File Count 0x3A1 0x8 signed long Data File Combined Size 937 4 int32(STFS = 0, SVOD = 1) Descriptor type 941 4 int32 Reserved 0x3B1 0x4C bytes Padding 0x3FD 0x14 bytes Device ID 0x411 0x900 (each 0x80 = different locale) unicode string Display Name 0xD11 0x900 (each 0x80 = different locale) unicode string Display Description 0x1611 0x80 unicode string Publisher Name 0x1691 0x80 unicode string Title Name 0x1711 0x1 byte Transfer Flags (see below) 0x1712 0x4 signed int Thumbnail Image Size 0x1716 0x4 signed int Title Thumbnail Image Size 0x171A 0x4000 (thumbnail size) image Thumbnail Image 0x571A 0x4000 (title thumbnail size) image Title Thumbnail Image","title":"Metadata"},{"location":"STFS/#version-2","text":"If the Metadata Version field is set to 2, the format is slightly changed: Offset Length Type Information 0x3B1 0x10 bytes Series ID 0x3C1 0x10 bytes Season ID 0x3D1 0x2 signed short Season Number 0x3D5 0x2 signed short Episode Number 0x3D5 0x28 bytes Padding 0x171A 0x3D00 (thumbnail size) image Thumbnail Image 0x541A 0x300 (each 0x80 = different locale) image Additional Display Names 0x571A 0x3D00 (title thumbnail size) image Title Thumbnail Image 0x941A 0x300 (each 0x80 = different locale) image Additional Display Descriptions","title":"Version 2"},{"location":"STFS/#license-entries","text":"For every entry in the license data field: Offset Length Type Information 0x0 0x8 signed long License ID (XUID / PUID / console id) 0x8 0x4 signed int License Bits 0xC 0x4 signed int License Flags","title":"License Entries"},{"location":"STFS/#content-types","text":"Value Description 0xD0000 Arcade Title 0x9000 Avatar Item 0x40000 Cache File 0x2000000 Community Game 0x80000 Game Demo 0x7000 Game on Demand 0x20000 Gamer Picture 0xA0000 Game Title 0xC0000 Game Trailer 0x400000 Game Video 0x4000 Installed Game 0xB0000 Installer 0x2000 IPTV Pause Buffer 0xF0000 License Store 0x2 Marketplace Content 0x100000 Movie 0x300000 Music Video 0x500000 Podcast Video 0x10000 Profile 0x3 Publisher 0x1 Saved Game 0x50000 Storage Download 0x30000 Theme 0x200000 TV 0x90000 Video 0x600000 Viral Video 0x70000 Xbox Download 0x5000 Xbox Original Game 0x60000 Xbox Saved Game 0x1000 Xbox 360 Title 0x5000 Xbox Title 0xE0000 XNA","title":"Content Types"},{"location":"STFS/#transfer-flags","text":"Value Description 0x00 DeviceID and ProfileID Transfer 0x20 Move Only Transfer 0x40 DeviceID Transfer 0x80 ProfileID Transfer 0xC0 None These are bit flags, dunno why everyone treats like enum. Bit0: None(Yet?) Bit1: None Bit2: Deep Link Supported Bit3: Disable Network Storage Bit4: Kinect Enabled Bit5: Move Only Transfer Bit6: Device Transfer Bit7: Profile Transfer","title":"Transfer Flags"},{"location":"STFS/#profile-embedded-content-pec","text":"When extra security is needed for content which is already using STFS, PEC files may be used to add an extra layer on top. PEC files use the STFS descriptor and algorithms, but has no similarity with content packages. PEC files are only currently used for avatar items/clothing. Block 0 starts at 0x3000, and hash table 0 at 0x1000/0x2000.","title":"Profile Embedded Content (PEC)"},{"location":"STFS/#header_1","text":"Offset Length Type Information 0x0 0x228 [[Console_Security_Certificate Console Security Certificate]] 0x228 0x14 bytes SHA1 hash from 0x23C-0x1000 0x23C 0x8 signed long Unknown 0x244 0x24 [[STFS#STFS_2 Volume Descriptor (STFS)]] 0x268 0x4 signed int Unknown 0x26C 0x8 bytes Profile ID 0x274 0x1 byte Unknown 0x275 0x5 bytes Console ID","title":"Header"},{"location":"STFS/#file-listing","text":"The value at 0x37E (File Table Block Number on the structure above) determines where the file table begins. As it is a block number, you will have to convert it to an offset. Here is some code in C# for converting: internal int BlockToOffset(int xBlock) { int xReturn = 0; if (xBlock > 0xFFFFFF) xReturn = -1; else xReturn = (((MetaData.HeaderSize + 0xFFF) & 0xF000) + (xBlock << 12)); return xReturn; } internal int ComputeDataBlockNumber(int xBlock) { int xBlockShift; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockShift = 1; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockShift = 0; else xBlockShift = 1; int xBase = ((xBlock + 0xAA) / 0xAA); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xBase = (xBase << xBlockShift); int xReturn = (xBase + xBlock); if (xBlock > 0xAA) { xBase = ((xBlock + 0x70E4) / 0x70E4); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xBase = (xBase << xBlockShift); xReturn += xBase; if (xBlock > 0x70E4) { xBase = ((xBlock + 0x4AF768) / 0x4AF768); if (this.Header.Magic == xBlockShift) xBase = (xBase << 1); xReturn = (xReturn + xBase); } } return xReturn; } Each embedded file starts at a 4096 byte boundary. The optional space between embedded files is filled with null bytes. The file listing consists of entries which have the format below. The listing ends with an entry consisting of only null bytes. Offset Length Type Information 0x0 0x28 ascii string File name, null-padded 0x28 0x1 byte Length of file name, plus flags 0x29 0x3 signed int24 Number of blocks allocated for file (little endian) 0x2C 0x3 signed int24 Copy of 0x29 0x2F 0x3 signed int24 Starting block number of file (little endian) 0x32 0x2 signed short Path indicator (big endian) 0x34 0x4 unsigned int Size of file in bytes (big endian) 0x38 0x4 signed int Update date/time stamp of file 0x3C 0x4 signed int Access date/time stamp of file Byte 0x28 also has two flags: bit 6 and bit 7. If bit 6 is set it means that all of the blocks in the file are consecutive. Bit 7 indicates that the file is a directory. The first 6 bits 0-5, are the length of the filename. public System.Boolean IsDirectory//bit 7 { get { return (Flags & 128) == 128; } set { if (value != IsDirectory) { Flags ^= 128; } } } //public System.Boolean IsUnknown//bit 6 //{ // get // { // return (Flags & 64) == 64; // } // set // { // if (value != IsUnknown) // { // Flags ^= 64; // } // } //} public System.Byte NameLength//first 6 bits { get { return (System.Byte)(Flags & 63); } set { Flags ^= (System.Byte)(value ^ NameLength); } } The path indicator indicates the path of the file. -1 (0xFFFF) means that the file is in the root directory, any other value V refers to the (sub)directory which is listed as the Vth entry in the listing (counting from 0). Directories can nest. The FAT format is used for the date/time stamps of the files.","title":"File Listing"},{"location":"STFS/#hash-tables-block-offsets","text":"A block is 0x1000 (4096) bytes and the first block is located at 0xC000. Every 0xAA (170) blocks there is a block that contains a hash of each block and every 0xAA*0xAA (0x70E4) blocks there is another table (presumably hashing the 0xAA table blocks). This means that when using a block number from a file listing you need to account for the hash tables which are not included in the block numbering system. For example block 171 is actually located where you would expect block 172 to reside ((171 + int(171/170)) * 0x1000 + 0xC000). Offset Length Type Information 0x0 0x14 byte Hash(SHA1) 0x14 0x1 byte Status byte 0x15 0x3 Int24 Next block The status byte is very important when injecting files into a package. Here are the meanings of them. Value Meaning 0x00 Unused Block 0x40 Free Block (previously used) 0x80 Used Block 0x80 Used Block 0xC0 Newly Allocated Block Files are not always stored in consecutive blocks, you have to find the corresponding hash table record and read the next block number (similar to cluster maps in FAT). Here is some C# code for converting a block to it's hash table position( it may not work perfectly! ): internal int ComputeLevelNHashBlockNumber(int xBlock, int xLevel) { int xBlockShift; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockShift = 1; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockShift = 0; else xBlockShift = 1; int[] xBlockStep; if (((MetaData.HeaderSize + 0xFFF) & 0xF000) == 0xB000) xBlockStep = new[] { 0xAC, 0x723A }; else if ((MetaData.Descriptor.BlockSeperation & 1) == 1) xBlockStep = new[] { 0xAB, 0x718F }; else xBlockStep = new[] { 0xAC, 0x723A }; int xReturn; int xBase; int xStep = xBlockStep[1]; if (xLevel == 0) { xReturn = (xBlock / 0xAA); xStep = (xReturn * xBlockStep[0]); if (xReturn != 0) { xReturn = (xBlock / 0x70E4); xBase = (xReturn + 1); if (this.Header.Magic == XContent_Header.Header_Magic.CON) xStep += (xBase << xBlockShift); else xStep += xBase; if (xReturn == 0) return xStep; else { if (this.Header.Magic == XContent_Header.Header_Magic.CON) return (xStep + (1 << xBlockShift)); else return (xStep + 1); } } else return xStep; } else if (xLevel == 1) { xReturn = (xBlock / 0x70E4); xBase = (xReturn * xStep); if (xReturn != 0) { if (this.Header.Magic == XContent_Header.Header_Magic.CON) return (xBase + (1 << xBlockShift)); else return (xBase + 1); } else return (xBase + xBlockStep[0]); } else if (xLevel == 2) { return xStep; } else { throw new Exception(\"Level Unknown: \" + xLevel.ToString()); return 0xFFFFFF; } }","title":"Hash Tables / Block Offsets"},{"location":"STFS/#tools","text":"An (old) tool (Python 2.5 required) to analyze and extract these archive files is available at extract360.py (2008-08-03, 23056 bytes, MD5 = 3aa517c83d01c618927b78d0ca665d02) wxPirs 1.1 can extract from LIVE/PIRS files fine, but as it doesn't use hash tables properly it doesn't work well with CON files. A newer tool was released by DJ Shepherd called Le Fluffie , which can create and extract from CON/LIVE/PIRS files (but it has some problems with creation, some prefer to use XLAST) XLAST inside the Xbox 360 SDK can create LIVE/PIRS packages, but it is illegal to share it. A new python library py360 can read STFS files Category:Xbox360 System Software","title":"Tools"},{"location":"Sandbox/","text":"Category:Template documentation","title":"Sandbox"},{"location":"Secure_Transacted_File_System/","text":"REDIRECT STFS","title":"Secure Transacted File System"},{"location":"Sega_Genesis_Plus_GX/","text":"General Info NFO genesis_plus 0.98 first public version merry xmas release :D Category:Xbox360_Homebrew_Software","title":"Sega Genesis Plus GX"},{"location":"Sega_Genesis_Plus_GX/#general-info","text":"","title":"General Info"},{"location":"Sega_Genesis_Plus_GX/#nfo","text":"genesis_plus 0.98 first public version merry xmas release :D Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Sega_Master_System_Plus/","text":"General Info Source: http://www.multiupload.com/62T7RVYB5A NFO Introduction: SMS Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles. Changelog: v140909a: Fixed controller bug v140909: Sound is now fully working greats to tmbinc Back to menu with select key Contact: [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr Thanks: Tmbinc Charles MacDonald Category:Xbox360_Homebrew_Software","title":"Sega Master System Plus"},{"location":"Sega_Master_System_Plus/#general-info","text":"Source: http://www.multiupload.com/62T7RVYB5A","title":"General Info"},{"location":"Sega_Master_System_Plus/#nfo","text":"Introduction: SMS Plus is a freeware, open-source, portable emulator for the Sega Master System and Game Gear consoles. Changelog: v140909a: Fixed controller bug v140909: Sound is now fully working greats to tmbinc Back to menu with select key Contact: [http://ced2911.wata.fr](https://web.archive.org/web/20110108141423/http://ced2911.wata.fr:80/) | cedric2911@free.fr Thanks: Tmbinc Charles MacDonald Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Serial_Console/","text":"REDIRECT UART","title":"Serial Console"},{"location":"Shadowboot/","text":"General Information Development kits have an undocumented, internal feature called 'shadow booting' which allows them to enter an alternate boot chain during the boot process . By placing a specially crafted file titled 'xboxromw2d.bin' on the root of the system's hard disk, on bootup the system will start, begin the process, then reboot again, finally completing the boot sequence having loaded from the bootloaders from the file on disk. Shadowbooting allows you to apply patches to any part of the system software stack from the 2BL up without reflashing the NAND. Once booted from shadowboot, the alternate bootloaders are loaded into memory just the same as a normal boot sequence: analyzing a NAND dump from a live shadow booted system (the flash dumped while the system is running) shows the SB, SD, and SE bootloaders on the system. Shadow booting has long been held a closely guarded secret within the community, where only recently have its existence become widely known due to their use with Xbox Live challenge bypass services. Test Kits Unlike full development kits, test kits are limited in their ability to do kernel debugging among other restrictions. Test kits run on a different software stack than dev kits, and as such require their own shadowboot during updates. ISO recoveries contain two shadowboot ROMs, 'xboxromw2d.bin' and 'xboxromtw2d.bin', which will initiate shadowboot on dev and test kits, respectively. Obtaining a shadowboot ROM Shadowbooting is used in the recovery process. ISO Recoveries Open an ISO recovery with an archiver and you will find the xboxromw2.bin and xboxromtw2.bin files. These are the \"clean\" shadowboot sources from which we base our modifications. Remote Recoveries Remote recoveries also contain many shadowboot files (60 files) of varying sizes. File Structure Found in recovery images, shadowboot files are binaries titled 'xboxromw2d.bin' and 'xboxromtw2d.bin'. Full development kits will find and boot from xboxromw2d.bin and test kits xboxromtw2d.bin. Shadowboot files are always 832KB (851,968 bytes). Structurally, shadowboot files are nearly identical to flash dumps , but for obvious reasons they do not contain mobiles or filesystems. File Structure Section File Header SMC Keyvault 2BL 3BL 4BL 5BL File Header File Header Section Magic bytes Major Build QFE? Flags SB offset CF1 offset/Size? Microsoft copyright Padding KV size? CF1 offset? Patch slots KV version KV offset Patch slot size? Metadata style? (360FlashTool) SMC config offset SMC length SMC offset On shadowboot ROMs the build number will be the major XDK flash version (ie. 21250). On the hacked 16547 shadowboot ROM it is 16547 On a cold flash dump, the build number will always be 1888. On xboxromtw2 shadowboot ROMs, the SB offset is 0xc0000 whereas on both normal ROMs and NAND dumps it is 0x8000 On NAND dumps the CF1 offset is 0x080000 while on shadowboot ROMs it is 0x0d000 The Microsoft copyright notice is as follows (ASCII) followed by a null byte terminator (0x00) \u00a9 2004-2011 Microsoft Corporation. All rights reserved. Note that later NAND dumps may have updated the years in this string. The unknown flag at 0x70 reads 0x0002(0000) on the NAND dump and 0x0001(0000) on the shadowboot ROMs The 360FlashTool changelog notes the value at offset 0x71 as the 'metadata style,' where \"0 = Original, 1 = New 16MB, 2 = Large Block\" I am unsure about the size of all of the data after the copyright notice, and especially unsure of everything near 0x70. Keyvault The keyvault data section is entirely zeroed through, meaning that there is no keyvault. The KV data is probably loaded into RAM on the first startup sequence using the console's native bootloader's and may remain untouched by the shadowboot bootloader. Boot Process Development kernels contain a series of subroutines to find, validate and execute shadowboot ROMs found on various media. The first subroutine in this shadowboot process is ExpTryToShadowBoot , followed by ExpTryToBootMediaKernel , KiShadowBoot , KiQuiesce , and finally HvxShadowBoot . The fact that these subroutines cannot be find in bootloaders prior to SE implies that the system must fully reach the kernel before rebooting into the shadow kernel. Media The shadowboot process will attempt to boot from media in the following order Remote - ExpMediaKernelKdRemoteBuffer - \"host:\\\\xboxromw2d.bin\" CDRROM - ExpMediaKernelCdRom0Buffer \"\\\\Device\\\\CdRom0\\\\xboxromw2d.bin\" Flash - Flash media kernelExpMediaKernelFlashBuffer \"\\\\Device\\\\FlashFs\\\\xboxromw2d.bin\" Hard disk - ExpMediaKernelHd0Buffer \"\\\\Device\\\\Harddisk0\\\\Partition1\\\\xboxromw2d.bin\" Security Measures Encryption Schema Shadowboot bootloaders use a very similar encryption schema to retails with CB \\<=1920 but for the presence of SC. Beginning with CB 1920, the retail CD bootloader encryption key also uses the CPU key, whereas SD on shadowboot ROMs does not. RC4 Key Each bootloader holds a random 'salt' value that is used in the calculation of its RC4 key. The key is derived from a 'secret' from the previous bootloader's key, originating from the hardcoded key in the 1BL. The key is the 16 (0x10) byte truncated HMAC-SHA1 digest of the secret appended with a random salt. key = HMAC-SHA(previous_key + salt)[0:0x10] The bootloader's 'payload' (everything after 0x20 for SB/CB, SC,SD/CD,SE/CE,CG everything after 0x30 for CF) is encrypted with RC4. The decryption process looks like: decrypted = encrypted[0:0x10] + key + decrypt_RC4(key, encrypted[0x20:] 2BL Key As an example, you calculate the 2BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 1BL key as the secret. The RC4 key is the first 0x10 bytes of this digest. 3BL Key The 3BL (SC) is the exception to the rule. Its key is not generated using the RC4 key from the 2BL, but its secret is instead 0x10 null bytes. 4BL Key Calculate the 4BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 3BL RC4 key as the secret. The 4BL RC4 key is the first 0x10 bytes of this digest. 5BL Key Calculate the 5BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 4BL RC4 key as the secret. The 5BL RC4 key is the first 0x10 bytes of this digest. Signature There is a common misconception to shadowbooting where we are able to replace everything from the 2BL onward. While shadowboot ROMs contain a nearly complete NAND image, the 2BL (and subsequently the 3BL) are still protected by signature checks with the 2BL private key. The fundamental difference in bootloader security between retail and devkit is the replacement of precomputed hashes in retail bootloaders, where the only signature checks occur on 2BL, CB, and the 6BL, CF; on devkits, most of these hash checks are instead replaced with signature checks. On both the cold boot as well as shadowboot, the 2BL is verified with a signature check, which subsequently verifies SD with a signature check. Category:Xbox360 System Software","title":"General Information"},{"location":"Shadowboot/#general-information","text":"Development kits have an undocumented, internal feature called 'shadow booting' which allows them to enter an alternate boot chain during the boot process . By placing a specially crafted file titled 'xboxromw2d.bin' on the root of the system's hard disk, on bootup the system will start, begin the process, then reboot again, finally completing the boot sequence having loaded from the bootloaders from the file on disk. Shadowbooting allows you to apply patches to any part of the system software stack from the 2BL up without reflashing the NAND. Once booted from shadowboot, the alternate bootloaders are loaded into memory just the same as a normal boot sequence: analyzing a NAND dump from a live shadow booted system (the flash dumped while the system is running) shows the SB, SD, and SE bootloaders on the system. Shadow booting has long been held a closely guarded secret within the community, where only recently have its existence become widely known due to their use with Xbox Live challenge bypass services.","title":"General Information"},{"location":"Shadowboot/#test-kits","text":"Unlike full development kits, test kits are limited in their ability to do kernel debugging among other restrictions. Test kits run on a different software stack than dev kits, and as such require their own shadowboot during updates. ISO recoveries contain two shadowboot ROMs, 'xboxromw2d.bin' and 'xboxromtw2d.bin', which will initiate shadowboot on dev and test kits, respectively.","title":"Test Kits"},{"location":"Shadowboot/#obtaining-a-shadowboot-rom","text":"Shadowbooting is used in the recovery process.","title":"Obtaining a shadowboot ROM"},{"location":"Shadowboot/#iso-recoveries","text":"Open an ISO recovery with an archiver and you will find the xboxromw2.bin and xboxromtw2.bin files. These are the \"clean\" shadowboot sources from which we base our modifications.","title":"ISO Recoveries"},{"location":"Shadowboot/#remote-recoveries","text":"Remote recoveries also contain many shadowboot files (60 files) of varying sizes.","title":"Remote Recoveries"},{"location":"Shadowboot/#file-structure","text":"Found in recovery images, shadowboot files are binaries titled 'xboxromw2d.bin' and 'xboxromtw2d.bin'. Full development kits will find and boot from xboxromw2d.bin and test kits xboxromtw2d.bin. Shadowboot files are always 832KB (851,968 bytes). Structurally, shadowboot files are nearly identical to flash dumps , but for obvious reasons they do not contain mobiles or filesystems. File Structure Section File Header SMC Keyvault 2BL 3BL 4BL 5BL","title":"File Structure"},{"location":"Shadowboot/#file-header","text":"File Header Section Magic bytes Major Build QFE? Flags SB offset CF1 offset/Size? Microsoft copyright Padding KV size? CF1 offset? Patch slots KV version KV offset Patch slot size? Metadata style? (360FlashTool) SMC config offset SMC length SMC offset On shadowboot ROMs the build number will be the major XDK flash version (ie. 21250). On the hacked 16547 shadowboot ROM it is 16547 On a cold flash dump, the build number will always be 1888. On xboxromtw2 shadowboot ROMs, the SB offset is 0xc0000 whereas on both normal ROMs and NAND dumps it is 0x8000 On NAND dumps the CF1 offset is 0x080000 while on shadowboot ROMs it is 0x0d000 The Microsoft copyright notice is as follows (ASCII) followed by a null byte terminator (0x00) \u00a9 2004-2011 Microsoft Corporation. All rights reserved. Note that later NAND dumps may have updated the years in this string. The unknown flag at 0x70 reads 0x0002(0000) on the NAND dump and 0x0001(0000) on the shadowboot ROMs The 360FlashTool changelog notes the value at offset 0x71 as the 'metadata style,' where \"0 = Original, 1 = New 16MB, 2 = Large Block\" I am unsure about the size of all of the data after the copyright notice, and especially unsure of everything near 0x70.","title":"File Header"},{"location":"Shadowboot/#keyvault","text":"The keyvault data section is entirely zeroed through, meaning that there is no keyvault. The KV data is probably loaded into RAM on the first startup sequence using the console's native bootloader's and may remain untouched by the shadowboot bootloader.","title":"Keyvault"},{"location":"Shadowboot/#boot-process","text":"Development kernels contain a series of subroutines to find, validate and execute shadowboot ROMs found on various media. The first subroutine in this shadowboot process is ExpTryToShadowBoot , followed by ExpTryToBootMediaKernel , KiShadowBoot , KiQuiesce , and finally HvxShadowBoot . The fact that these subroutines cannot be find in bootloaders prior to SE implies that the system must fully reach the kernel before rebooting into the shadow kernel.","title":"Boot Process"},{"location":"Shadowboot/#media","text":"The shadowboot process will attempt to boot from media in the following order Remote - ExpMediaKernelKdRemoteBuffer - \"host:\\\\xboxromw2d.bin\" CDRROM - ExpMediaKernelCdRom0Buffer \"\\\\Device\\\\CdRom0\\\\xboxromw2d.bin\" Flash - Flash media kernelExpMediaKernelFlashBuffer \"\\\\Device\\\\FlashFs\\\\xboxromw2d.bin\" Hard disk - ExpMediaKernelHd0Buffer \"\\\\Device\\\\Harddisk0\\\\Partition1\\\\xboxromw2d.bin\"","title":"Media"},{"location":"Shadowboot/#security-measures","text":"","title":"Security Measures"},{"location":"Shadowboot/#encryption-schema","text":"Shadowboot bootloaders use a very similar encryption schema to retails with CB \\<=1920 but for the presence of SC. Beginning with CB 1920, the retail CD bootloader encryption key also uses the CPU key, whereas SD on shadowboot ROMs does not.","title":"Encryption Schema"},{"location":"Shadowboot/#rc4-key","text":"Each bootloader holds a random 'salt' value that is used in the calculation of its RC4 key. The key is derived from a 'secret' from the previous bootloader's key, originating from the hardcoded key in the 1BL. The key is the 16 (0x10) byte truncated HMAC-SHA1 digest of the secret appended with a random salt. key = HMAC-SHA(previous_key + salt)[0:0x10] The bootloader's 'payload' (everything after 0x20 for SB/CB, SC,SD/CD,SE/CE,CG everything after 0x30 for CF) is encrypted with RC4. The decryption process looks like: decrypted = encrypted[0:0x10] + key + decrypt_RC4(key, encrypted[0x20:]","title":"RC4 Key"},{"location":"Shadowboot/#2bl-key","text":"As an example, you calculate the 2BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 1BL key as the secret. The RC4 key is the first 0x10 bytes of this digest.","title":"2BL Key"},{"location":"Shadowboot/#3bl-key","text":"The 3BL (SC) is the exception to the rule. Its key is not generated using the RC4 key from the 2BL, but its secret is instead 0x10 null bytes.","title":"3BL Key"},{"location":"Shadowboot/#4bl-key","text":"Calculate the 4BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 3BL RC4 key as the secret. The 4BL RC4 key is the first 0x10 bytes of this digest.","title":"4BL Key"},{"location":"Shadowboot/#5bl-key","text":"Calculate the 5BL RC4 key by reading out its salt from 0x10 to 0x20. Calculate the HMAC SHA of this salt using the 4BL RC4 key as the secret. The 5BL RC4 key is the first 0x10 bytes of this digest.","title":"5BL Key"},{"location":"Shadowboot/#signature","text":"There is a common misconception to shadowbooting where we are able to replace everything from the 2BL onward. While shadowboot ROMs contain a nearly complete NAND image, the 2BL (and subsequently the 3BL) are still protected by signature checks with the 2BL private key. The fundamental difference in bootloader security between retail and devkit is the replacement of precomputed hashes in retail bootloaders, where the only signature checks occur on 2BL, CB, and the 6BL, CF; on devkits, most of these hash checks are instead replaced with signature checks. On both the cold boot as well as shadowboot, the 2BL is verified with a signature check, which subsequently verifies SD with a signature check. Category:Xbox360 System Software","title":"Signature"},{"location":"Snes9x-Gx/","text":"General Info NFO ******************************************************************************* ____ _ _ _____ ____ _____ __ ______ __ __ __ / ___|| \\ | | ____/ ___|/ _ \\ \\/ / / ___\\ \\/ / \\ \\/ /___ _ __ ___ _ __ ___ \\| \\| | _| ___ \\ (_) \\ / | | _ \\ / \\ // _ \\ '_ \\ / _ \\| '_ \\ ___) | |\\ | |___ ___) __, / \\ | |_| |/ \\ / \\ __/ | | | (_) | | | | |____/|_| _|_____|____/ /_/_/_\\ ____/_/_\\ /_/____|_| |_|___/|_| |_| ******************************************************************************* ------------------------------------------------------------------------------- General Information ------------------------------------------------------------------------------- Filename.............: Snes9x-Gx-Beta001 Type.................: Emulator Platform.............: Xbox 360 Release Date.........: 2009/09/08 By...................: TMBINC Webpage..............: www.free60.org ------------------------------------------------------------------------------- Change Log / Fixes ------------------------------------------------------------------------------- Filename: Snes9x-Gx-Beta001 - Fixed Ticking Sound. - Swapped B & A buttons around. Filename: Snes9x-Gx-Beta - Sound Support Added. - Wireless Pad Support Added. - Full CPU Core Support Added. Filename: Snes9x-Gx-Alpha - The emu looks for a static rom filename - SNES9X.SMC - Some USB storage devices might not work. - Only the composite, component and VGA AVPACK are supported. - PAL60 is used instead of NTSC on composite. - VGA is hardcoded to 1024x768. - No VSYNC. - Only first wired controller is supported. - CPU is running at 800Mhz, only one core/thread is used. - No sound. ------------------------------------------------------------------------------- Known Bugs / To Do List ------------------------------------------------------------------------------- - Screen Tearing - Improve Wireless Pad Support (Might be abit laggy compared to wired) - No Sram Support Yet - Graphical Interface / Menu - Lots More To List ------------------------------------------------------------------------------- Release Notes ------------------------------------------------------------------------------- This is the first SNES emulator to run natively on the xbox 360 using the new Xell hack released by the guys over at www.free60.org Build based off the sources from http://code.google.com/p/snes9x-gx/ & compiled using LibXenon found at https://github.com/LibxenonProject All Code used to create LibXenon & to compile this port, is opensourse & contains no Microsoft XDK code making it legal to distribute the .ELF files. Currently only running on the xenon xell hack. Support for other chipsets is in the works! ------------------------------------------------------------------------------- Install Notes ------------------------------------------------------------------------------- Copy Xenon.elf to the root of your mem stick along with any rom which has been renamed as SNES9X.SMC Insert mem stick into xbox 360 & power on. THIS ONLY WORKS WITH HACKED 360 RUNNING XELL ------------------------------------------------------------------------------- License ------------------------------------------------------------------------------- Snes9x homepage: http://www.snes9x.com Snes9x GX homepage: http://code.google.com/p/snes9x-gx/ Permission to use, copy, modify and/or distribute Snes9x in both binary and source form, for non-commercial purposes, is hereby granted without fee, providing that this license information and copyright notice appear with all copies and any derived work. This software is provided 'as-is', without any express or implied warranty. In no event shall the authors be held liable for any damages arising from the use of this software or it's derivatives. Snes9x is freeware for PERSONAL USE only. Commercial users should seek permission of the copyright holders first. Commercial use includes, but is not limited to, charging money for Snes9x or software derived from Snes9x, including Snes9x or derivatives in commercial game bundles, and/or using Snes9x as a promotion for your commercial product. The copyright holders request that bug fixes and improvements to the code should be forwarded to them so everyone can benefit from the modifications in future versions. Super NES and Super Nintendo Entertainment System are trademarks of Nintendo Co., Limited and its subsidiary companies. ------------------------------------------------------------------------------- Greetz & Shoutouts ------------------------------------------------------------------------------- Thanks to TMBINC - XBH - Free60 - And the rest of the crew!!!! NFO Created By HoRnEyDvL 2009 ------------------------------------------------------------------------------- ------------------------------------------------------------------------------- Category:Xbox360_Homebrew_Software","title":"Snes9x Gx"},{"location":"Snes9x-Gx/#general-info","text":"","title":"General Info"},{"location":"Snes9x-Gx/#nfo","text":"******************************************************************************* ____ _ _ _____ ____ _____ __ ______ __ __ __ / ___|| \\ | | ____/ ___|/ _ \\ \\/ / / ___\\ \\/ / \\ \\/ /___ _ __ ___ _ __ ___ \\| \\| | _| ___ \\ (_) \\ / | | _ \\ / \\ // _ \\ '_ \\ / _ \\| '_ \\ ___) | |\\ | |___ ___) __, / \\ | |_| |/ \\ / \\ __/ | | | (_) | | | | |____/|_| _|_____|____/ /_/_/_\\ ____/_/_\\ /_/____|_| |_|___/|_| |_| ******************************************************************************* ------------------------------------------------------------------------------- General Information ------------------------------------------------------------------------------- Filename.............: Snes9x-Gx-Beta001 Type.................: Emulator Platform.............: Xbox 360 Release Date.........: 2009/09/08 By...................: TMBINC Webpage..............: www.free60.org ------------------------------------------------------------------------------- Change Log / Fixes ------------------------------------------------------------------------------- Filename: Snes9x-Gx-Beta001 - Fixed Ticking Sound. - Swapped B & A buttons around. Filename: Snes9x-Gx-Beta - Sound Support Added. - Wireless Pad Support Added. - Full CPU Core Support Added. Filename: Snes9x-Gx-Alpha - The emu looks for a static rom filename - SNES9X.SMC - Some USB storage devices might not work. - Only the composite, component and VGA AVPACK are supported. - PAL60 is used instead of NTSC on composite. - VGA is hardcoded to 1024x768. - No VSYNC. - Only first wired controller is supported. - CPU is running at 800Mhz, only one core/thread is used. - No sound. ------------------------------------------------------------------------------- Known Bugs / To Do List ------------------------------------------------------------------------------- - Screen Tearing - Improve Wireless Pad Support (Might be abit laggy compared to wired) - No Sram Support Yet - Graphical Interface / Menu - Lots More To List ------------------------------------------------------------------------------- Release Notes ------------------------------------------------------------------------------- This is the first SNES emulator to run natively on the xbox 360 using the new Xell hack released by the guys over at www.free60.org Build based off the sources from http://code.google.com/p/snes9x-gx/ & compiled using LibXenon found at https://github.com/LibxenonProject All Code used to create LibXenon & to compile this port, is opensourse & contains no Microsoft XDK code making it legal to distribute the .ELF files. Currently only running on the xenon xell hack. Support for other chipsets is in the works! ------------------------------------------------------------------------------- Install Notes ------------------------------------------------------------------------------- Copy Xenon.elf to the root of your mem stick along with any rom which has been renamed as SNES9X.SMC Insert mem stick into xbox 360 & power on. THIS ONLY WORKS WITH HACKED 360 RUNNING XELL ------------------------------------------------------------------------------- License ------------------------------------------------------------------------------- Snes9x homepage: http://www.snes9x.com Snes9x GX homepage: http://code.google.com/p/snes9x-gx/ Permission to use, copy, modify and/or distribute Snes9x in both binary and source form, for non-commercial purposes, is hereby granted without fee, providing that this license information and copyright notice appear with all copies and any derived work. This software is provided 'as-is', without any express or implied warranty. In no event shall the authors be held liable for any damages arising from the use of this software or it's derivatives. Snes9x is freeware for PERSONAL USE only. Commercial users should seek permission of the copyright holders first. Commercial use includes, but is not limited to, charging money for Snes9x or software derived from Snes9x, including Snes9x or derivatives in commercial game bundles, and/or using Snes9x as a promotion for your commercial product. The copyright holders request that bug fixes and improvements to the code should be forwarded to them so everyone can benefit from the modifications in future versions. Super NES and Super Nintendo Entertainment System are trademarks of Nintendo Co., Limited and its subsidiary companies. ------------------------------------------------------------------------------- Greetz & Shoutouts ------------------------------------------------------------------------------- Thanks to TMBINC - XBH - Free60 - And the rest of the crew!!!! NFO Created By HoRnEyDvL 2009 ------------------------------------------------------------------------------- ------------------------------------------------------------------------------- Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Southbridge/","text":"Category:Xbox360_Hardware","title":"Southbridge"},{"location":"Starting_Homebrew_Development/","text":"Requirements Linux/MAC OS/Mingw (a virtual machine will just do fine) Installed Xenon Toolchain and LibXenon of course LibXenon pulled from Free60 Git Repository Knowledge of C/C++ Getting into it A little tutorial which explains how to setup NetBeans in Linux to develop LibXenon applications: Setup your PC for LibXenon Programming PDF You could start looking at a code example and write a program which (almost) everbody starts with: Hello World :) Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"Starting Homebrew Development"},{"location":"Starting_Homebrew_Development/#requirements","text":"Linux/MAC OS/Mingw (a virtual machine will just do fine) Installed Xenon Toolchain and LibXenon of course LibXenon pulled from Free60 Git Repository Knowledge of C/C++","title":"Requirements"},{"location":"Starting_Homebrew_Development/#getting-into-it","text":"A little tutorial which explains how to setup NetBeans in Linux to develop LibXenon applications: Setup your PC for LibXenon Programming PDF You could start looking at a code example and write a program which (almost) everbody starts with: Hello World :) Category:Xbox360_Homebrew_Software Category:Xbox360_Development","title":"Getting into it"},{"location":"Stereo_DAC/","text":"The Xbox 360 uses a WOLFSON WM8517HCGED Stereo DAC With Integrated Output Stage for 1.7Vrms LINE OUT, which is pin compatible (and otherwise quite similar) to the WM8521 (which has 2Vrms). This is a DAC with built in output stage and derives its clock signal from the 360's master clock, the only one of the mother board. The output has small SMD Ceramic's presumably for DC blocking. The local decoupling on the Digital and Analogue supply pins and 'CAP' pin (reference) are also small Ceramic SMD's. Output traces are very very thin. Voltage regs are miles away and have other components deriving power from the same rail's, which also has really thin traces. Category:Xbox360_Hardware","title":"Stereo DAC"},{"location":"System_Calls/","text":"The means for unprivileged code to query the Hypervisor for privileged tasks. Making a System Call Anywhere in unprivileged code you can make a system call by loading r0 with the call ID and executing the 'sc' instruction. Some system calls take additional parameters in r3-r9 # Send 0xFF to POST output li r3, 0xFF li r0, 0xD sc blr System Call Table File Structure ID 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5A 0x5B 0x5C 0x5D 0x5E 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6A 0x6B 0x6C 0x6D 0x6E 0x6F 0x70 0x71 0x72 0x73 0x74 0x75 0x76","title":"System Calls"},{"location":"System_Calls/#making-a-system-call","text":"Anywhere in unprivileged code you can make a system call by loading r0 with the call ID and executing the 'sc' instruction. Some system calls take additional parameters in r3-r9 # Send 0xFF to POST output li r3, 0xFF li r0, 0xD sc blr","title":"Making a System Call"},{"location":"System_Calls/#system-call-table","text":"File Structure ID 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07 0x08 0x09 0x0A 0x0B 0x0C 0x0D 0x0E 0x0F 0x10 0x11 0x12 0x13 0x14 0x15 0x16 0x17 0x18 0x19 0x1A 0x1B 0x1C 0x1D 0x1E 0x1F 0x20 0x21 0x22 0x23 0x24 0x25 0x26 0x27 0x28 0x29 0x2A 0x2B 0x2C 0x2D 0x2E 0x2F 0x30 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x3A 0x3B 0x3C 0x3D 0x3E 0x3F 0x40 0x41 0x42 0x43 0x44 0x45 0x46 0x47 0x48 0x49 0x4A 0x4B 0x4C 0x4D 0x4E 0x4F 0x50 0x51 0x52 0x53 0x54 0x55 0x56 0x57 0x58 0x59 0x5A 0x5B 0x5C 0x5D 0x5E 0x5F 0x60 0x61 0x62 0x63 0x64 0x65 0x66 0x67 0x68 0x69 0x6A 0x6B 0x6C 0x6D 0x6E 0x6F 0x70 0x71 0x72 0x73 0x74 0x75 0x76","title":"System Call Table"},{"location":"Tanks_360/","text":"General Info NFO This is going to get flushed out more. For now, i decided to work on creating an engine / game from scratch made in and from libxenon and lzx. This is still very basic much more to come. Thanks to libxenon team. Thanks to Ced2911, Cancerous, Tuxuser for Libxenon / LZX / Encouragement Thanks to Blackwolf for the upcoming music Thanks to Mattie for the idea Thanks to STK50 for all you have done. Hope one day to work with you again. Category:Xbox360_Homebrew_Software","title":"Tanks 360"},{"location":"Tanks_360/#general-info","text":"","title":"General Info"},{"location":"Tanks_360/#nfo","text":"This is going to get flushed out more. For now, i decided to work on creating an engine / game from scratch made in and from libxenon and lzx. This is still very basic much more to come. Thanks to libxenon team. Thanks to Ced2911, Cancerous, Tuxuser for Libxenon / LZX / Encouragement Thanks to Blackwolf for the upcoming music Thanks to Mattie for the idea Thanks to STK50 for all you have done. Hope one day to work with you again. Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"Timing_Attack/","text":"Valid as of December 7th 2007 The timing attack is used allow machines with kernel 4552 or higher to downgrade to a vulnerable kernel. The purpose of the timing attack is to find the required hash values for the altered CB section in a base kernel (1888). The lockdown counter in the CB section is changed to a higher value to allow the base kernel (1888) to bypass the restrictive lockdown counter check during boot-up. The check is what makes it impossible to just flash the NAND and downgrade to a vulnerable kernel. The community at XboxHacker made this project possible, Arnezami found the Timing Attack vector and figured out the basic concept, and Robinsod built the necessary downgrader hardware and measurement software required to perform the attack. Purpose A good explanation by arnezami 1 : [With the CPU key] can we not resign the essential parts of the HV, or anything else, with a modified bootloader? All executable code on the xbox is (one way or another) signed by a RSA key. MS has the private RSA key and thats why we will never be able to sign our own executable code. This is what prevents us from running anything different than what MS has build (like the kernel and bootloaders). This has nothing to do with the cpu key. The only thing we can do with the cpu key is choose which version of the kernel/bootloader we want to run. But we cannot make changes to any of these versions themselves. Then why downgrade? Because two kernel versions MS build (4532,4548) have a tiny flaw. And when we have our cpu key we can choose to run these (old) kernels and exploit them by running a patched KK game. After running the exploit we have complete control over the xbox (but not before that). This means to be able to run homebrew or linux we now have to start the game, press ok, insert a disc etc. More Visual representation of the process: Memcmp Flaw A memcmp function is used to check the CB-auth HMAC-hash value. The value is 16-bytes long and is done byte-by-byte wise. By changing one byte at a time it's possible to determine if a byte is the valid (true) by measuring the time to compare a false and a true value. Measuring each byte will in the end reveal the correct hash and the boot process can continue. The time differences for a valid and false value is about 2200 microseconds. Possibilities: 16 bytes * 256 different possibility for each byte, total 4096 tries. Statistically only half has to be tried, 2048 tries. Procedure The official documentation by robinsod for the downgrader hardware and downgrading process can be downloaded from the Timing Attack thread over at XboxHacker. Dump NAND Use Infectus or custom hardware (memorycard reader) to make a valid dump of the current NAND. Xbox 360 Infectus Kernel Dump Patch CB Get a plain 1888 base kernel and patch the CB lockdown counter with the LDV (LockDownValue) from the CF section in the NAND dump. Get the 1888 base kernel from the \"usual places\". Download Degraded.exe to automate the build of a new 1888 image with the SMC, Keyvault, CB, CD and CE sections from the NAND dump. The LDV (fuse count) will be corrected for CB (which is why you need to find a new hash) and the hash value is set to all zeroes. An external 1888 base kernel is needed because essential system files for 1888 is overwritten in the 4552 update and later, making it impossible to use the NAND dump to create a new 1888 image. In Degraded.exe click 'Settings', set the 1BL Key to 'DD88AD0C9ED669E7B56794FB68563EFA ', select the folder where the 1888 file system is located, and set 'File System Start' to '39 '. Select the NAND dump file under 'Flash Dump' and click 'Build Downgrader Image'. Downgrading Tools Flash Image Flash the new 1888 base kernel build to the NAND. Connect Infectus chip to the Xbox 360 again, erase and flash the new patched 1888 base kernel image. Xbox 360 Infectus Kernel Dump Attack Hash Attack the HMAC-hash value using the timing hardware and DGTool. Build the downgrader hardware and connect a serial port cable and power/ground (3.3v or 5v) from the 360 or an external power supply (USB) to the downgrader hardware. Connect the USB cable to the Infectus chip. The Infectus is required to flash the NAND page for the CB section with a new value for each new guess (every ~2 seconds). Create a folder with the 3 following files; DGTool.exe, Infectus.dll and SiUSBXp.dll. Move the 1888 image to this folder too, e.g. Infectus_5787_downgraded_1888.bin. Open a new command-prompt, by Start -> Run -> 'cmd'. Change directory (cd) to the folder where the DGTool.exe is located. DGTool normally only needs 2 arguments to start; one being the COM- or serial port the downgrader hardware is connected to and the other is the filename of the patched 1888 image. DGTool.exe 1 Infectus_5787_downgraded_1888.bin Enter the command above and press enter. Now power on the Xbox 360 and wait for the 3 red lights to start blinking, aka Red Ring Of Death (RROD). Press enter once more to start the timing process. Let it run for a little over an hour (around 1 hour 10 minutes seems to be normal) and the correct hash value will hopefully be discovered. If successful the last line of text should state 'BOOT! '. Xbox 360 Downgrader Hardware Upgrade Kernel Once you can boot the 1888 base kernel, you can apply the vulnerable 4532 or 4548 update to use the King King exploit. Download the 4532 HD DVD update , extract the files into a folder, and burn the content on a regular CD-R. Insert the CD-R into the Xbox 360 and you will be prompted that a update is required. Get CPU Key Boot a modified King Kong game disc and launch Gentoo Linux to get the CPU Key. Patch the King Kong game image with the King Kong exploit and burn it to a DVD+R Dual Layer disc. Burn the latest Gentoo Xenon release (as of writing beta2) from free60.org to a CD-R and insert the disc after pressing 'Start' on the modified King Kong disc. Download the dump32 application to dump the fusesets to find the CPU Key of the machine. wget http://home.x-pec.com/~ivc/sites/ivc/xbox360/files/arnezamidump32.tgz tar zxvf arnezamidump32.tgz cd arnezamidump32 sudo ./dump32 Save the FUSES.TXT file to a USB memorystick, upload it to yousendit.com, mail it to yourself, or use the 'scp' or 'ftp' utility to transfer it over the network to a computer. The CPU Key is found by combining line 3 + 5 in the FUSES.TXT file. It is now possible to upgrade to latest kernel (as of writing 5787) and then downgrade to a lower version again using the 360 Flash Tool . Insert the correct CPU Key in the 360 Flash Tool and patching the LDV (LockDownValue) in the CB/CE/CF section to that of the latest update. Kernel King Kong Hack Results All of my runs can be found on the page below. Xbox 360 Timing Attack Results Speculation arnezami: MS cannot fix this problem by simply changing the memcmp function in a future kernel version. Thats not gonna help them. The weakness is that the byte-wise memcmp function is in the 1888 kernel/bootloader (and they cannot change that one anymore of course). 2 tmbinc: sure, microsoft can change the 2BL, and burn a fuse (of the fuseline 2) so that an old 2BL doesn't work anymore... 3 arnezami: Ah. Right. If they can indeed burn these fuses at row 2 than you wouldn't be able to run any of the lower kernel versions anymore. 4 Been thinking about this. I'm now pretty sure when row 2 of the fuses is burned your xbox won't be able to downgrade or run homebrew anymore (it appears the fuse count number is indeed RSA signed). 5 surrido: you could if it makes you happy wire a switch to the R6T3 and keep it on while being in live and turn it of when you receive an update. 6 tmbinc: No, a switch at R6T3 doesn't help. It's not the resistor which presence can be detected, but the result to the fuse (burned or not). So his question is completely valid: If you remove the resistor, you could end up with an unbootable box after the next update. But at least you could restore a previous flash. (If you want, you could *then* re-attach the resistor, and update again, of course loosing the possibility to downgrade). 7 Current Situation The last 2007 fall update , 6683, is still vulnerable and can be downgraded by timing attacking the HMAC-hash value. The update is still vulnerable because the CB (2BL) section of the kernel did not change after the update, only the main CE/CF sections. No other fuses than the obligatory fuseline 7 (to match the LockDownValue in CE/FE) were blown. The latest revisions of the Xbox 360, the Falcon , has a newer basekernel and CB section, 1921, and this version is patched against the memcmp-vulnerability 8 . Making timing attack on these machines impossible until another vulnerability is found. This might suggest that only newer machines from factory can be patched to fix the memcmp-function in CB. References Original Wiki page - Thx ivc! Timing Attack Timing Attach - Thanks and stupid questions","title":"Timing Attack"},{"location":"Timing_Attack/#purpose","text":"A good explanation by arnezami 1 : [With the CPU key] can we not resign the essential parts of the HV, or anything else, with a modified bootloader? All executable code on the xbox is (one way or another) signed by a RSA key. MS has the private RSA key and thats why we will never be able to sign our own executable code. This is what prevents us from running anything different than what MS has build (like the kernel and bootloaders). This has nothing to do with the cpu key. The only thing we can do with the cpu key is choose which version of the kernel/bootloader we want to run. But we cannot make changes to any of these versions themselves. Then why downgrade? Because two kernel versions MS build (4532,4548) have a tiny flaw. And when we have our cpu key we can choose to run these (old) kernels and exploit them by running a patched KK game. After running the exploit we have complete control over the xbox (but not before that). This means to be able to run homebrew or linux we now have to start the game, press ok, insert a disc etc. More Visual representation of the process:","title":"Purpose"},{"location":"Timing_Attack/#memcmp-flaw","text":"A memcmp function is used to check the CB-auth HMAC-hash value. The value is 16-bytes long and is done byte-by-byte wise. By changing one byte at a time it's possible to determine if a byte is the valid (true) by measuring the time to compare a false and a true value. Measuring each byte will in the end reveal the correct hash and the boot process can continue. The time differences for a valid and false value is about 2200 microseconds. Possibilities: 16 bytes * 256 different possibility for each byte, total 4096 tries. Statistically only half has to be tried, 2048 tries.","title":"Memcmp Flaw"},{"location":"Timing_Attack/#procedure","text":"The official documentation by robinsod for the downgrader hardware and downgrading process can be downloaded from the Timing Attack thread over at XboxHacker.","title":"Procedure"},{"location":"Timing_Attack/#dump-nand","text":"Use Infectus or custom hardware (memorycard reader) to make a valid dump of the current NAND. Xbox 360 Infectus Kernel Dump","title":"Dump NAND"},{"location":"Timing_Attack/#patch-cb","text":"Get a plain 1888 base kernel and patch the CB lockdown counter with the LDV (LockDownValue) from the CF section in the NAND dump. Get the 1888 base kernel from the \"usual places\". Download Degraded.exe to automate the build of a new 1888 image with the SMC, Keyvault, CB, CD and CE sections from the NAND dump. The LDV (fuse count) will be corrected for CB (which is why you need to find a new hash) and the hash value is set to all zeroes. An external 1888 base kernel is needed because essential system files for 1888 is overwritten in the 4552 update and later, making it impossible to use the NAND dump to create a new 1888 image. In Degraded.exe click 'Settings', set the 1BL Key to 'DD88AD0C9ED669E7B56794FB68563EFA ', select the folder where the 1888 file system is located, and set 'File System Start' to '39 '. Select the NAND dump file under 'Flash Dump' and click 'Build Downgrader Image'. Downgrading Tools","title":"Patch CB"},{"location":"Timing_Attack/#flash-image","text":"Flash the new 1888 base kernel build to the NAND. Connect Infectus chip to the Xbox 360 again, erase and flash the new patched 1888 base kernel image. Xbox 360 Infectus Kernel Dump","title":"Flash Image"},{"location":"Timing_Attack/#attack-hash","text":"Attack the HMAC-hash value using the timing hardware and DGTool. Build the downgrader hardware and connect a serial port cable and power/ground (3.3v or 5v) from the 360 or an external power supply (USB) to the downgrader hardware. Connect the USB cable to the Infectus chip. The Infectus is required to flash the NAND page for the CB section with a new value for each new guess (every ~2 seconds). Create a folder with the 3 following files; DGTool.exe, Infectus.dll and SiUSBXp.dll. Move the 1888 image to this folder too, e.g. Infectus_5787_downgraded_1888.bin. Open a new command-prompt, by Start -> Run -> 'cmd'. Change directory (cd) to the folder where the DGTool.exe is located. DGTool normally only needs 2 arguments to start; one being the COM- or serial port the downgrader hardware is connected to and the other is the filename of the patched 1888 image. DGTool.exe 1 Infectus_5787_downgraded_1888.bin Enter the command above and press enter. Now power on the Xbox 360 and wait for the 3 red lights to start blinking, aka Red Ring Of Death (RROD). Press enter once more to start the timing process. Let it run for a little over an hour (around 1 hour 10 minutes seems to be normal) and the correct hash value will hopefully be discovered. If successful the last line of text should state 'BOOT! '. Xbox 360 Downgrader Hardware","title":"Attack Hash"},{"location":"Timing_Attack/#upgrade-kernel","text":"Once you can boot the 1888 base kernel, you can apply the vulnerable 4532 or 4548 update to use the King King exploit. Download the 4532 HD DVD update , extract the files into a folder, and burn the content on a regular CD-R. Insert the CD-R into the Xbox 360 and you will be prompted that a update is required.","title":"Upgrade Kernel"},{"location":"Timing_Attack/#get-cpu-key","text":"Boot a modified King Kong game disc and launch Gentoo Linux to get the CPU Key. Patch the King Kong game image with the King Kong exploit and burn it to a DVD+R Dual Layer disc. Burn the latest Gentoo Xenon release (as of writing beta2) from free60.org to a CD-R and insert the disc after pressing 'Start' on the modified King Kong disc. Download the dump32 application to dump the fusesets to find the CPU Key of the machine. wget http://home.x-pec.com/~ivc/sites/ivc/xbox360/files/arnezamidump32.tgz tar zxvf arnezamidump32.tgz cd arnezamidump32 sudo ./dump32 Save the FUSES.TXT file to a USB memorystick, upload it to yousendit.com, mail it to yourself, or use the 'scp' or 'ftp' utility to transfer it over the network to a computer. The CPU Key is found by combining line 3 + 5 in the FUSES.TXT file. It is now possible to upgrade to latest kernel (as of writing 5787) and then downgrade to a lower version again using the 360 Flash Tool . Insert the correct CPU Key in the 360 Flash Tool and patching the LDV (LockDownValue) in the CB/CE/CF section to that of the latest update. Kernel King Kong Hack","title":"Get CPU Key"},{"location":"Timing_Attack/#results","text":"All of my runs can be found on the page below. Xbox 360 Timing Attack Results","title":"Results"},{"location":"Timing_Attack/#speculation","text":"arnezami: MS cannot fix this problem by simply changing the memcmp function in a future kernel version. Thats not gonna help them. The weakness is that the byte-wise memcmp function is in the 1888 kernel/bootloader (and they cannot change that one anymore of course). 2 tmbinc: sure, microsoft can change the 2BL, and burn a fuse (of the fuseline 2) so that an old 2BL doesn't work anymore... 3 arnezami: Ah. Right. If they can indeed burn these fuses at row 2 than you wouldn't be able to run any of the lower kernel versions anymore. 4 Been thinking about this. I'm now pretty sure when row 2 of the fuses is burned your xbox won't be able to downgrade or run homebrew anymore (it appears the fuse count number is indeed RSA signed). 5 surrido: you could if it makes you happy wire a switch to the R6T3 and keep it on while being in live and turn it of when you receive an update. 6 tmbinc: No, a switch at R6T3 doesn't help. It's not the resistor which presence can be detected, but the result to the fuse (burned or not). So his question is completely valid: If you remove the resistor, you could end up with an unbootable box after the next update. But at least you could restore a previous flash. (If you want, you could *then* re-attach the resistor, and update again, of course loosing the possibility to downgrade). 7","title":"Speculation"},{"location":"Timing_Attack/#current-situation","text":"The last 2007 fall update , 6683, is still vulnerable and can be downgraded by timing attacking the HMAC-hash value. The update is still vulnerable because the CB (2BL) section of the kernel did not change after the update, only the main CE/CF sections. No other fuses than the obligatory fuseline 7 (to match the LockDownValue in CE/FE) were blown. The latest revisions of the Xbox 360, the Falcon , has a newer basekernel and CB section, 1921, and this version is patched against the memcmp-vulnerability 8 . Making timing attack on these machines impossible until another vulnerability is found. This might suggest that only newer machines from factory can be patched to fix the memcmp-function in CB.","title":"Current Situation"},{"location":"Timing_Attack/#references","text":"Original Wiki page - Thx ivc! Timing Attack Timing Attach - Thanks and stupid questions","title":"References"},{"location":"Toolchain/","text":"REDIRECT Xenon Toolchain","title":"Toolchain"},{"location":"Trinity/","text":"Trinity is the codename of the motherboard used in the Xbox 360 Slim. It is the sixth motherboard revision. It was originally believed that it's codename was Valhalla , but after looking through debug files it was found that this is not the case. It no longer has Memory Unit ports. It has a special port for connecting the Kinect peripheral, which provides power to the device instead of plugging it in seperately. It also features a single chip that contains the CPU, GPU and eDRAM, with a 45nm die size. The Xbox 360 Slim, and as a result, the motherboard are much smaller than the original. It also contains an internal USB port which has a 802.11n WiFi card inserted. The HDD port was also changed, making it much smaller and flush against the case. The RRoD is also non-existant, replaced with a single red power light on any errors. Consoles: 4GB Arcade, Elite 250GB and Halo Reach Console Unified single chip with CPU, GP and eDRAM at 45nm process. 16MB NAND 135 Watt PSU 802.11n Wi-Fi integrated No more Memory Unit ports Separate Kinect port Different HDD port Smaller form factor 4GB internal Memory on small Daughter board No more RROD, simple red power light on error (unknown on more detail) Category:Xbox360_Hardware","title":"Trinity"},{"location":"UART/","text":"The XBox 360 has an UART in the Southbridge. Registers To configure the UART, write to register 0x8000 0200 EA00 101C (real mode) Register value Configuration 0xE6010000 115200,8,N,1 0xB2010000 38400,8,N,1 0x63010000 19200,8,N,1 To send a byte, do a 32 bit write to 0x8000 0200 EA00 1014 . After you sent something to the serial port, the status should be read from 0x8000 0200 EA00 1018 . Sample code Init UART speed: li %r7, 0x0200 oris %r7, %r7, 0x8000 sldi %r7, %r7, 32 oris %r7, %r7, 0xEA00 #ori %r7, %r7, 0x101C lis %r8, 0 oris %r8, %r8, 0xE601 # 115200,8,N,1 stw %r8, 0x101C(%r7) Send char '!' to the serial port (UART): li %r8, '!' slwi %r8, %r8, 24 stw %r8, 0x1014(%r7) # send the character sync isync 1: lwz %r8, 0x1018(%r7) # wait until character is sent rlwinm. %r8, %r8, 0, 6, 6 beq 1b Get char from the serial port (UART): lis %r4, 0x8000 ori %r4, %r4, 0x200 rldicr %r4, %r4, 32,31 oris %r4, %r4, 0xEA00 1: lwz %r8, 0x1018(%r4) rlwinm %r7, %r8, 0,8,5 cmplwi %r7, 0 # check the status of the UART before input bne 1b rlwinm. %r7, %r8, 0,7,7 beq 1b lwz %r3, 0x1010(%r4) # input char from address 8000 0200 EA00 1010 srwi %r3, %r3, 24 Serial Console The Serial Console can be very useful when debugging the Linux Kernel or diagnosing the Boot Process . Diagram FAT Diagram ALL You can either use the GND pin on the header (might be difficult to solder for the inexperienced) or some alternative GND pin like the one from the Stereo DAC nearby the J2B1 header. Note that you will probably need a Level Shifter to connect the 3.3V RX/TX pins to your PC Serial Port (which usually uses +/-12V) The Level Shifter can be either powered from the standby 3.3V on pin 7 (always on) or better from the active 3.3V on pin 8 or from an external power source. It is also possible to use some cheap cell phone data cables as a PC interface. Category:Xbox360_Hardware Category:Xbox360_Development Category:Xbox360_Homebrew_Software","title":"UART"},{"location":"UART/#registers","text":"To configure the UART, write to register 0x8000 0200 EA00 101C (real mode) Register value Configuration 0xE6010000 115200,8,N,1 0xB2010000 38400,8,N,1 0x63010000 19200,8,N,1 To send a byte, do a 32 bit write to 0x8000 0200 EA00 1014 . After you sent something to the serial port, the status should be read from 0x8000 0200 EA00 1018 .","title":"Registers"},{"location":"UART/#sample-code","text":"Init UART speed: li %r7, 0x0200 oris %r7, %r7, 0x8000 sldi %r7, %r7, 32 oris %r7, %r7, 0xEA00 #ori %r7, %r7, 0x101C lis %r8, 0 oris %r8, %r8, 0xE601 # 115200,8,N,1 stw %r8, 0x101C(%r7) Send char '!' to the serial port (UART): li %r8, '!' slwi %r8, %r8, 24 stw %r8, 0x1014(%r7) # send the character sync isync 1: lwz %r8, 0x1018(%r7) # wait until character is sent rlwinm. %r8, %r8, 0, 6, 6 beq 1b Get char from the serial port (UART): lis %r4, 0x8000 ori %r4, %r4, 0x200 rldicr %r4, %r4, 32,31 oris %r4, %r4, 0xEA00 1: lwz %r8, 0x1018(%r4) rlwinm %r7, %r8, 0,8,5 cmplwi %r7, 0 # check the status of the UART before input bne 1b rlwinm. %r7, %r8, 0,7,7 beq 1b lwz %r3, 0x1010(%r4) # input char from address 8000 0200 EA00 1010 srwi %r3, %r3, 24","title":"Sample code"},{"location":"UART/#serial-console","text":"The Serial Console can be very useful when debugging the Linux Kernel or diagnosing the Boot Process .","title":"Serial Console"},{"location":"UART/#diagram-fat","text":"","title":"Diagram FAT"},{"location":"UART/#diagram-all","text":"You can either use the GND pin on the header (might be difficult to solder for the inexperienced) or some alternative GND pin like the one from the Stereo DAC nearby the J2B1 header. Note that you will probably need a Level Shifter to connect the 3.3V RX/TX pins to your PC Serial Port (which usually uses +/-12V) The Level Shifter can be either powered from the standby 3.3V on pin 7 (always on) or better from the active 3.3V on pin 8 or from an external power source. It is also possible to use some cheap cell phone data cables as a PC interface. Category:Xbox360_Hardware Category:Xbox360_Development Category:Xbox360_Homebrew_Software","title":"Diagram ALL"},{"location":"USB/","text":"General Information \u2022The Xbox 360 comes with 3 standard USB 2.0 ports. (2 on the front and 1 on the back) The Xbox 360 added official support for using USB drives as a mean of storing Xbox 360 files on April 6, 2010. Files are stored to the flash drive by using files within a hidden folder (Root\\Xbox360\\) that use the FATX file system. Confirmed Facts Can be used to add hard disk and get around DRM. SEE: USB Hard Drive Mod Speculation iPod and standard USB flashdrives using the FAT(32)? Filesystem are detected via the 360 media center.(Cannot read NTFS) The Xbox 360 seems to be able to read the HFS filesystem Mac formatted iPods. It is unknown if the USB ports can access DMA but it is speculated that the USB ports may be read-only. Such speculation is questionable, as two-way communication is required to be able to communicate with products. Instead, any read-only access control may be implemented in the Dashboard, or write support may simply not exist within the filesystem drivers. - This is most likely impossible - There are no \"slave initiated DMA\" transactions as part of the USB spec. Even if it does support USB OTG, and therefore can act as a Slave, a driver [on the xbox] would still need to be present for any usb endpoints to exist. Category:Xbox360_Hardware","title":"USB"},{"location":"USB/#general-information","text":"\u2022The Xbox 360 comes with 3 standard USB 2.0 ports. (2 on the front and 1 on the back) The Xbox 360 added official support for using USB drives as a mean of storing Xbox 360 files on April 6, 2010. Files are stored to the flash drive by using files within a hidden folder (Root\\Xbox360\\) that use the FATX file system.","title":"General Information"},{"location":"USB/#confirmed-facts","text":"Can be used to add hard disk and get around DRM. SEE: USB Hard Drive Mod","title":"Confirmed Facts"},{"location":"USB/#speculation","text":"iPod and standard USB flashdrives using the FAT(32)? Filesystem are detected via the 360 media center.(Cannot read NTFS) The Xbox 360 seems to be able to read the HFS filesystem Mac formatted iPods. It is unknown if the USB ports can access DMA but it is speculated that the USB ports may be read-only. Such speculation is questionable, as two-way communication is required to be able to communicate with products. Instead, any read-only access control may be implemented in the Dashboard, or write support may simply not exist within the filesystem drivers. - This is most likely impossible - There are no \"slave initiated DMA\" transactions as part of the USB spec. Even if it does support USB OTG, and therefore can act as a Slave, a driver [on the xbox] would still need to be present for any usb endpoints to exist. Category:Xbox360_Hardware","title":"Speculation"},{"location":"Ubuntu/","text":"Ubuntu is a computer operating system based on the Debian GNU/Linux distribution and is distributed as free and open source software with additional proprietary software available. Ubuntu is composed of many software packages, of which the vast majority are distributed under a free software license (also known as open source). The main license used is the GNU General Public License (GNU GPL) which, along with the GNU Lesser General Public License (GNU LGPL), explicitly declares that users are free to run, copy, distribute, study, change, develop and improve the software. Canonical, the company that endorses the Ubuntu project (as well as Kubuntu and other Ubuntu-based derivations) releases new versions of Ubuntu every six months and supports Ubuntu for eighteen months by providing security fixes, patches to critical bugs and minor updates to programs. LTS (Long Term Support) versions, which are released every two years, are supported for three years on the desktop and five years for servers. The latest version of Ubuntu, 10.04 (Lucid Lynx), is such an LTS version, and was released on April 29, 2010. It is possible to boot Ubuntu by using an Xbox 360 which has had the SMC Hack applied. You find the current working Ubuntu-installationscript here: Ubuntu7.10 Category:Xbox360_Linux","title":"Ubuntu"},{"location":"Ubuntu11.10/","text":"Install Ubuntu 11.10 from a Linux LiveCD WARNING: This script will WIPE your Xbox 360 internal harddisk (/dev/sda) and install Ubuntu 11.10 If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing. ubuntu_oneiric.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script. How do I run it? Click \"Application > Accessories > Terminal\" and type the following commands: sudo su wget http://file.libxenon.org/free60/linux/script/ubuntu_oneiric.sh sh ./ubuntu_oneiric.sh Reboot the 360 when you are told. Boot with http://file.libxenon.org/latest_kern , supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.) debootstrapping script ubuntu_oneiric.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 # if /dev/sda is mounted then paritions get wiped by dd but sfdisk fails! swapoff /dev/sda1 umount /mnt/ubuntu # partition and mkfs hdd (all data is lost!) dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF dd if=/dev/zero of=/dev/sda2 bs=512 count=1 mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 # setup paths mkdir /mnt/ubuntu mount /dev/sda2 /mnt/ubuntu cd /mnt/ubuntu mkdir /mnt/ubuntu/work cd /mnt/ubuntu/work # download extract and run debootstrap wget http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb ar -xf debootstrap_1.0.38_all.deb cd /mnt/ubuntu zcat < /mnt/ubuntu/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/ubuntu/usr/share/debootstrap export PATH=$PATH:/mnt/ubuntu/usr/sbin debootstrap --arch powerpc oneiric /mnt/ubuntu http://ports.ubuntu.com/ # create needed files on hdd echo Xenon > /mnt/ubuntu/etc/hostname cat > /mnt/ubuntu/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/ubuntu/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/ubuntu/etc/apt/sources.list << EOF # Main deb http://ports.ubuntu.com/ubuntu-ports/ oneiric main restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric universe multiverse # Updates deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates main restricted deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates universe multiverse # Security deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-security main restricted deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-security main restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-security universe multiverse deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-security universe multiverse EOF #Change root-pwd to \"xbox\" inside chroot chroot /mnt/ubuntu echo \"root:xbox\" | chroot /mnt/ubuntu /usr/sbin/chpasswd # Add user: xbox with password: xbox and add it to the sudo-group chroot /mnt/ubuntu /usr/sbin/useradd -m -d /home/xbox -p paRRy2CC47LXY xbox chroot /mnt/ubuntu /usr/sbin/adduser xbox sudo # create .second_stage script on hdd cat >> /mnt/ubuntu/root/.second_stage << EOF #!/bin/bash date -s 1/1/2009 apt-get update apt-get install ntp wget openssh-server locales -y --force-yes dpkg-reconfigure locales apt-get install ubuntu-desktop -y echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ wget -O xenosfb_drv.so http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_oneiric cd /etc/X11/ wget http://file.libxenon.org/free60/linux/xenosfb/xorg.conf rm -r -f /work/ echo \"Installation completed.\" echo \"To boot the system: Reboot and load the kernel with correct root= params.\" echo \"You should be greeted by a fresh install of Ubuntu 11.10 Oneiric\" EOF chmod a+x /mnt/ubuntu/root/.second_stage # Execute second part of installation in the chroot environment mount -t proc none /mnt/ubuntu/proc mount --rbind /dev /mnt/ubuntu/dev cp -L /etc/resolv.conf /mnt/ubuntu/etc/resolv.conf chroot /mnt/ubuntu /root/.second_stage umount /mnt/ubuntu/dev /mnt/ubuntu/proc /mnt/ubuntu Fix possible xorg fail After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type, sudo dpkg-reconfigure xserver-xorg Then follow the instructions below. 1. Attempt to autodetect video hardware? > No 2. X Server Driver: Xenosfb 3. Generic Video Card > Enter 4. Video card\u2019s bus identifier: Press enter for default 5. Amount of memory: Press enter for default 6. Use kernel framebuffer device interface? > Yes 7. Autodetect keyboard layout? > Yes 8. Keyboard layout: us 9. XKB rule set to use: xorg 10. Keyboard model: choose your rule set based on the options 11. Keyboard variant: leave blank if you\u2019re in the U.S. 12. Keyboard options: Leave as default 13. Mouse Protocol: ImPS/2 14. Emulate a 3 button mouse? > Your choice 15. Xorg server modules: Default 16. Write default Files section to configuration file? > Yes 17. Attempt monitor detection? > Yes 18. Use generic monitor if it doesn\u2019t detect it. 19. Video modes to be used by the X server: 1280x768 (1024x768 if garbled) 20. Method for selecting the monitor characteristics: Medium 21. Monitors best video mode: Choose what\u2019s best for your monitor. 22. Write monitor sync ranges to the configuration file? > Yes 23. Desired default color depth in bits: 24. After that go back to gnome by typing Ctrl+Alt+F7. Reboot X by typing Ctrl+Alt+Backspace. Category:Xbox360_Linux","title":"Install Ubuntu 11.10 from a Linux LiveCD"},{"location":"Ubuntu11.10/#install-ubuntu-1110-from-a-linux-livecd","text":"WARNING: This script will WIPE your Xbox 360 internal harddisk (/dev/sda) and install Ubuntu 11.10 If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing. ubuntu_oneiric.sh will create two partitions. 1 GB swap on sda1 and the rest of the disk as a root-filesystem on sda2. Run the script as root from the a Linux LiveCD. You will need a DHCP-server on your network for this script. How do I run it? Click \"Application > Accessories > Terminal\" and type the following commands: sudo su wget http://file.libxenon.org/free60/linux/script/ubuntu_oneiric.sh sh ./ubuntu_oneiric.sh Reboot the 360 when you are told. Boot with http://file.libxenon.org/latest_kern , supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as user: xbox, password: xbox. Have fun :) (If you are not having fun, let us know about the errors you are experiencing.)","title":"Install Ubuntu 11.10 from a Linux LiveCD"},{"location":"Ubuntu11.10/#debootstrapping-script","text":"ubuntu_oneiric.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 # if /dev/sda is mounted then paritions get wiped by dd but sfdisk fails! swapoff /dev/sda1 umount /mnt/ubuntu # partition and mkfs hdd (all data is lost!) dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF dd if=/dev/zero of=/dev/sda2 bs=512 count=1 mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 # setup paths mkdir /mnt/ubuntu mount /dev/sda2 /mnt/ubuntu cd /mnt/ubuntu mkdir /mnt/ubuntu/work cd /mnt/ubuntu/work # download extract and run debootstrap wget http://ftp.nl.debian.org/debian/pool/main/d/debootstrap/debootstrap_1.0.38_all.deb ar -xf debootstrap_1.0.38_all.deb cd /mnt/ubuntu zcat < /mnt/ubuntu/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/ubuntu/usr/share/debootstrap export PATH=$PATH:/mnt/ubuntu/usr/sbin debootstrap --arch powerpc oneiric /mnt/ubuntu http://ports.ubuntu.com/ # create needed files on hdd echo Xenon > /mnt/ubuntu/etc/hostname cat > /mnt/ubuntu/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/ubuntu/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/ubuntu/etc/apt/sources.list << EOF # Main deb http://ports.ubuntu.com/ubuntu-ports/ oneiric main restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric universe multiverse # Updates deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates main restricted deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-updates universe multiverse # Security deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-security main restricted deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-security main restricted deb http://ports.ubuntu.com/ubuntu-ports/ oneiric-security universe multiverse deb-src http://ports.ubuntu.com/ubuntu-ports/ oneiric-security universe multiverse EOF #Change root-pwd to \"xbox\" inside chroot chroot /mnt/ubuntu echo \"root:xbox\" | chroot /mnt/ubuntu /usr/sbin/chpasswd # Add user: xbox with password: xbox and add it to the sudo-group chroot /mnt/ubuntu /usr/sbin/useradd -m -d /home/xbox -p paRRy2CC47LXY xbox chroot /mnt/ubuntu /usr/sbin/adduser xbox sudo # create .second_stage script on hdd cat >> /mnt/ubuntu/root/.second_stage << EOF #!/bin/bash date -s 1/1/2009 apt-get update apt-get install ntp wget openssh-server locales -y --force-yes dpkg-reconfigure locales apt-get install ubuntu-desktop -y echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ wget -O xenosfb_drv.so http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_oneiric cd /etc/X11/ wget http://file.libxenon.org/free60/linux/xenosfb/xorg.conf rm -r -f /work/ echo \"Installation completed.\" echo \"To boot the system: Reboot and load the kernel with correct root= params.\" echo \"You should be greeted by a fresh install of Ubuntu 11.10 Oneiric\" EOF chmod a+x /mnt/ubuntu/root/.second_stage # Execute second part of installation in the chroot environment mount -t proc none /mnt/ubuntu/proc mount --rbind /dev /mnt/ubuntu/dev cp -L /etc/resolv.conf /mnt/ubuntu/etc/resolv.conf chroot /mnt/ubuntu /root/.second_stage umount /mnt/ubuntu/dev /mnt/ubuntu/proc /mnt/ubuntu","title":"debootstrapping script"},{"location":"Ubuntu11.10/#fix-possible-xorg-fail","text":"After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type, sudo dpkg-reconfigure xserver-xorg Then follow the instructions below. 1. Attempt to autodetect video hardware? > No 2. X Server Driver: Xenosfb 3. Generic Video Card > Enter 4. Video card\u2019s bus identifier: Press enter for default 5. Amount of memory: Press enter for default 6. Use kernel framebuffer device interface? > Yes 7. Autodetect keyboard layout? > Yes 8. Keyboard layout: us 9. XKB rule set to use: xorg 10. Keyboard model: choose your rule set based on the options 11. Keyboard variant: leave blank if you\u2019re in the U.S. 12. Keyboard options: Leave as default 13. Mouse Protocol: ImPS/2 14. Emulate a 3 button mouse? > Your choice 15. Xorg server modules: Default 16. Write default Files section to configuration file? > Yes 17. Attempt monitor detection? > Yes 18. Use generic monitor if it doesn\u2019t detect it. 19. Video modes to be used by the X server: 1280x768 (1024x768 if garbled) 20. Method for selecting the monitor characteristics: Medium 21. Monitors best video mode: Choose what\u2019s best for your monitor. 22. Write monitor sync ranges to the configuration file? > Yes 23. Desired default color depth in bits: 24. After that go back to gnome by typing Ctrl+Alt+F7. Reboot X by typing Ctrl+Alt+Backspace. Category:Xbox360_Linux","title":"Fix possible xorg fail"},{"location":"Ubuntu7.10/","text":"Install Ubuntu 7.10 from the Gentoo LiveCD gnome Issue Resolved WARNING: This script will WIPE your Xbox 360 internal harddisk (/dev/sda) and install Ubuntu 7.10 If you have XeXmenu or another dashboard homebrew on that drive, you will loose it all: Follow these instructions only if you understand what you are doing. I new boot disk that would allow the booting of a USB harddisk would ease the risk of ruining your 360 harddrive. ubuntu_gutsy.sh will create two partitions. 1 GB swap on sda0 and the rest of the disk as a root-filesystem on sda1. Run the script as root from the Gentoo LiveCD v2. You will need a DHCP-server on your network for this script. How do I run it? Click \"Application > Accessories > Terminal\" and type the following commands: sudo su wget http://file.libxenon.org/free60/linux/script/ubuntu_gutsy.sh sh ./ubuntu_gutsy.sh Reboot the 360 when you are told. Boot with http://file.libxenon.org/latest_kern , supply correct \"root=\" parameter via kboot.conf (*kboot currently only supported via xell-reloaded-testing builds), boot the kernel/system and login as root. You will be asked to set new password. The rest of the installation will start automatically. The download is about 600Mb. After a while it will ask you to setup the screen resolution, select 1280x768 with the space bar. If the display is garbled use 1024x768. After it has finished installing and has rebooted into gnome open a new shell by typing Ctrl+Alt+F6 or Ctrl+Alt+F1 and type, sudo dpkg-reconfigure xserver-xorg Then follow the instructions below. 1. Attempt to autodetect video hardware? > No 2. X Server Driver: Xenonfb 3. Generic Video Card > Enter 4. Video card\u2019s bus identifier: Press enter for default 5. Amount of memory: Press enter for default 6. Use kernel framebuffer device interface? > Yes 7. Autodetect keyboard layout? > Yes 8. Keyboard layout: us 9. XKB rule set to use: xorg 10. Keyboard model: choose your rule set based on the options 11. Keyboard variant: leave blank if you\u2019re in the U.S. 12. Keyboard options: Leave as default 13. Mouse Protocol: ImPS/2 14. Emulate a 3 button mouse? > Your choice 15. Xorg server modules: Default 16. Write default Files section to configuration file? > Yes 17. Attempt monitor detection? > Yes 18. Use generic monitor if it doesn\u2019t detect it. 19. Video modes to be used by the X server: 1280x768 (1024x768 if garbled) 20. Method for selecting the monitor characteristics: Medium 21. Monitors best video mode: Choose what\u2019s best for your monitor. 22. Write monitor sync ranges to the configuration file? > Yes 23. Desired default color depth in bits: 24. After that go back to gnome by typing Ctrl+Alt+F7. Reboot X by typing Ctrl+Alt+Backspace. (If Java is required, do not install the one in the default repository as it is broken, to attempt to install it http://ubuntuforums.org/showthread.php?t=1116368 , or simply install this http://3dslice.net/downloads/PrimeGen/ibm-j2sdk1.6_1.6.0_powerpc.deb ) ubuntu_gutsy.sh #!/bin/bash # set the date to anything except 1/1/1970 since this causes issues # time is now also set after first boot by .bashrc script below date -s 1/1/2009 # if /dev/sda is mounted then paritions get wiped by dd but sfdisk fails! swapoff /dev/sda1 umount /mnt/ubuntu # partition and mkfs hdd (all data is lost!) dd if=/dev/zero of=/dev/sda bs=512 count=1 sfdisk /dev/sda << EOF ,124,S ,,L EOF dd if=/dev/zero of=/dev/sda2 bs=512 count=1 mkfs.ext3 /dev/sda2 mkswap /dev/sda1 sync; sync; sync swapon /dev/sda1 # setup paths mkdir /mnt/ubuntu mount /dev/sda2 /mnt/ubuntu cd /mnt/ubuntu mkdir /mnt/ubuntu/work cd /mnt/ubuntu/work # download extract and run debootstrap wget ftp://old-releases.ubuntu.com/old-images/ubuntu/pool/main/d/debootstrap/debootstrap_1.0.3build1_all.deb ar -xf debootstrap_1.0.3build1_all.deb cd /mnt/ubuntu zcat < /mnt/ubuntu/work/data.tar.gz | tar xv export DEBOOTSTRAP_DIR=/mnt/ubuntu/usr/lib/debootstrap export PATH=$PATH:/mnt/ubuntu/usr/sbin debootstrap --arch powerpc gutsy /mnt/ubuntu ftp://old-releases.ubuntu.com/old-images/ubuntu/ # create needed files on hdd echo Falcon > /mnt/ubuntu/etc/hostname cat > /mnt/ubuntu/etc/fstab << EOF /dev/sda2 / ext3 defaults 0 0 /dev/sda1 none swap sw 0 0 proc /proc proc defaults 0 0 EOF cat > /mnt/ubuntu/etc/network/interfaces << EOF iface lo inet loopback auto lo auto eth0 iface eth0 inet dhcp EOF cat > /mnt/ubuntu/etc/apt/sources.list << EOF deb ftp://old-releases.ubuntu.com/old-images/ubuntu/ gutsy main restricted universe multiverse EOF #Change root-pwd inside chroot chroot /mnt/ubuntu echo \"root:xbox\" | chroot /mnt/ubuntu /usr/sbin/chpasswd cp /mnt/ubuntu/root/.bashrc /mnt/ubuntu/root/.bashrc.orginal # create .bashrc script on hdd cat >> /mnt/ubuntu/root/.bashrc << EOF date -s 1/1/2009 passwd mkdir /lib/modules/2.6.24.3 touch /lib/modules/2.6.24.3/modules.dep apt-get update apt-get install ntp wget -y --force-yes apt-get install ubuntu-desktop -y echo \"AVAHI_DAEMON_START=0\" > /etc/default/avahi-daemon /etc/init.d/networking restart cd /usr/lib/xorg/modules/drivers/ wget -O xenosfb_drv.so http://file.libxenon.org/free60/linux/xenosfb/xenosfb_drv.so_gutsy cd /etc/X11/ wget http://file.libxenon.org/free60/linux/xenosfb/xorg.conf mv ubuntu.conf xorg.conf cd /usr/lib/xorg/modules/linux/ mv libfbdevhw.so libfbdevhw.so.bk wget -O libfbdevhw.so http://file.libxenon.org/free60/linux/xenosfb/libfbdevhw.so_gutsy rm -r -f /work/ echo \"\" > /etc/gdm/gdm.conf-custom sed -i 's/AllowRoot=false/AllowRoot=true/' /etc/gdm/gdm.conf rm /root/.bashrc mv /root/.bashrc.orginal /root/.bashrc /etc/init.d/gdm start EOF # done echo \"Base installation completed.\" echo \"To finish the installation: Reboot and load the kernel with correct root= params.\" echo \"The install may take up to two hours, depending on your internet connection\" Category:Xbox360_Linux","title":"Ubuntu7.10"},{"location":"Utilities/","text":"Back to Xbox Software Name: Lflash Description: A NAND Flasher for xbox360, currently only working with 16MB NAND. For use with Linux. Official Site: www.free60.org Download: Free60 GIT Name: Dumpana Description: Tool for dumping ANA (Graphic Scaler Chip) registers. For use with Linux. Official Site: www.free60.org Download: Free60 GIT Name: Rawflash v2 Description: A tool for flashing rawimages (already properly remapped) to NAND, directly via LibXenon application Official Site: http://www.libxenon.org , by cOz Forum Discussion: libxenon.org archive Download: libxenon.org archive Category:Xbox360_Homebrew_Software","title":"Utilities"},{"location":"Valhalla/","text":"REDIRECT Trinity","title":"Valhalla"},{"location":"Webcam/","text":"The web cam, also known as Xbox Vision Cam, that you can buy separate from the xbox 360 is just a little web cam that you can twist and move yourself. You can send picture messages with it, have video chats and a few other little things like having the background warping appropriate to your movement in front of the vision cam. The quality isn't amazing but it suits the purpose of what the device is used for which is just simple things like video chatting and picture messaging. When video chatting audio is heard through the microphone. They aren't as popular as they used to be probably because of the Kinect having all of these features and much more built in. Category:Xbox360_Hardware","title":"Webcam"},{"location":"Wifi_Adapter/","text":"Introduction back.jpg FCC ID:C3K-WKS168 IC: 3048A-WKS168 The Wireless Network Adapter is a dual-band (2.4/5GHz) 802.11a/b/g interface for the Xbox 360. This is a standard USB 2.0 device, and although it is designed to clamp onto the back of the console, it works when plugged into a standard USB port, given your operating system has accompanying device drivers. See below. Disassembly all pieces.jpg Disassembled; bottom and top covers, PCB, USB cable and antenna back opened.jpg PCB underside, with Hannstar Board Corp. inscription. Integrated Circuits front opened.jpg PCB upper-side, showing the major ICs Marvell MVPG16 MG16R 00A2R 521AC The MVPG16 is an integrated DC-DC synchronous step-down switching regulator. Input voltage ranges from 3.0V-5.5V. Output voltage ranges from 0.72V-3.63V and is user-programmable via a single external resistor. There's no readily available datasheet for this particular IC, however, one for it's modular MDx-G16 counterpart is, for download . There's a two-page brochure as well, but is rather lacking in the more technical details. Product information page at http://www.marvell.com/products/power/dspswitcher/index.jsp Marvell 88W8388-BDK1 88W8388-BDK1 AGW1P .2 0530 A2P TW The 88W8388 is an 802.11a/b/g WLAN SoC from Marvell. Embedded are an ARM946E-S core (as per the ARM Networking.pdf Networking brochure) and on-chip memory. Together with an integrated TCP/IP stack, this allows for off-loading the host processor of protocol processing. This SoC is targeted at small-footprint devices, eg. cellular/VoIP phones, PDAs, video game consoles, etc. The 88W8388 is 88W88305-derived, as indicated below (table reproduced from http://www.clv.macnica.co.jp/product/marvell/sub1.html ): Part no. b/g/a Package option CLK Type Interface Feature/Advantage 88W8305 b TQFP 128pin 14x14x1.2 TBGA no option Flip chip Yes 20, 40, 44 CMOS only CF SDIO (SPI) TKIP (firmware) AES (hardware) WPA (firmware) Power Save 88W8381 b TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave CF SDIO (SPI) 8305 TKIP (hardware) 802.11e (QoS) 802.11i (Security) BT coex 88W8385 a/b/g TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave CF SDIO (SPI) Generic SPI 8381 a/g 88W8388 a/b/g TQFP No TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave SDIO (SPI) USB 2.0 8385 TCP/IP termination NAND Flash I/F Audio Codec I/F Baseband Processor Product Selection table Category:Xbox360_Hardware Category:Pages with missing images","title":"Introduction"},{"location":"Wifi_Adapter/#introduction","text":"back.jpg FCC ID:C3K-WKS168 IC: 3048A-WKS168 The Wireless Network Adapter is a dual-band (2.4/5GHz) 802.11a/b/g interface for the Xbox 360. This is a standard USB 2.0 device, and although it is designed to clamp onto the back of the console, it works when plugged into a standard USB port, given your operating system has accompanying device drivers. See below.","title":"Introduction"},{"location":"Wifi_Adapter/#disassembly","text":"all pieces.jpg Disassembled; bottom and top covers, PCB, USB cable and antenna back opened.jpg PCB underside, with Hannstar Board Corp. inscription.","title":"Disassembly"},{"location":"Wifi_Adapter/#integrated-circuits","text":"front opened.jpg PCB upper-side, showing the major ICs","title":"Integrated Circuits"},{"location":"Wifi_Adapter/#marvell-mvpg16","text":"MG16R 00A2R 521AC The MVPG16 is an integrated DC-DC synchronous step-down switching regulator. Input voltage ranges from 3.0V-5.5V. Output voltage ranges from 0.72V-3.63V and is user-programmable via a single external resistor. There's no readily available datasheet for this particular IC, however, one for it's modular MDx-G16 counterpart is, for download . There's a two-page brochure as well, but is rather lacking in the more technical details. Product information page at http://www.marvell.com/products/power/dspswitcher/index.jsp","title":"Marvell MVPG16"},{"location":"Wifi_Adapter/#marvell-88w8388-bdk1","text":"88W8388-BDK1 AGW1P .2 0530 A2P TW The 88W8388 is an 802.11a/b/g WLAN SoC from Marvell. Embedded are an ARM946E-S core (as per the ARM Networking.pdf Networking brochure) and on-chip memory. Together with an integrated TCP/IP stack, this allows for off-loading the host processor of protocol processing. This SoC is targeted at small-footprint devices, eg. cellular/VoIP phones, PDAs, video game consoles, etc. The 88W8388 is 88W88305-derived, as indicated below (table reproduced from http://www.clv.macnica.co.jp/product/marvell/sub1.html ): Part no. b/g/a Package option CLK Type Interface Feature/Advantage 88W8305 b TQFP 128pin 14x14x1.2 TBGA no option Flip chip Yes 20, 40, 44 CMOS only CF SDIO (SPI) TKIP (firmware) AES (hardware) WPA (firmware) Power Save 88W8381 b TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave CF SDIO (SPI) 8305 TKIP (hardware) 802.11e (QoS) 802.11i (Security) BT coex 88W8385 a/b/g TQFP 128pin 14x14x1.2 TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave CF SDIO (SPI) Generic SPI 8381 a/g 88W8388 a/b/g TQFP No TBGA 132pin 8x8x1 Flip chip Yes 19.2, 20, 26, 38.4, 40, 44 COMS & Low swing sine wave SDIO (SPI) USB 2.0 8385 TCP/IP termination NAND Flash I/F Audio Codec I/F Baseband Processor Product Selection table Category:Xbox360_Hardware Category:Pages with missing images","title":"Marvell 88W8388-BDK1"},{"location":"XCP/","text":"General Info It's been found [1] that Xbox360 Live Arcade downloads files with the extension .xcp over unencrypted http on port 3074 for content distribution. XCP stands for Xbox Content Package (from http://forums.xbox-scene.com/index.php?s=&showtopic=462911&view=findpost&p=3067263 ) XCP files are (in-order) encrypted and compressed (with zlib). Underneath, they are STFS containers. XCP files from some categories (\"Full Game Demos\" being one of them) are not encrypted It may be possible to use the avatar downloads to glean more info about the file format. The communication is pure http and you can redirect traffic to a local webserver, however it does checksum the file Content downloaded with licenses are locked to a 360 at purchase Box A downloads trial Box B can run the same downloaded trial Box A upgrades trial to full Box B can only run in trial mode (if available) Content is downloaded and extracted into place When upgrading to full license the 360 dials home and then some modification is made to lock content to the particular box First Generation Xbox xcp files are not new to the Xbox 360. Are encrypted Cabinet files Encrypted with a public and symmetric key. Keys needed for extraction. Need tools to create our own without the Xbox SDK Category:Xbox360 System Software","title":"XCP"},{"location":"XCP/#general-info","text":"It's been found [1] that Xbox360 Live Arcade downloads files with the extension .xcp over unencrypted http on port 3074 for content distribution. XCP stands for Xbox Content Package (from http://forums.xbox-scene.com/index.php?s=&showtopic=462911&view=findpost&p=3067263 ) XCP files are (in-order) encrypted and compressed (with zlib). Underneath, they are STFS containers. XCP files from some categories (\"Full Game Demos\" being one of them) are not encrypted It may be possible to use the avatar downloads to glean more info about the file format. The communication is pure http and you can redirect traffic to a local webserver, however it does checksum the file Content downloaded with licenses are locked to a 360 at purchase Box A downloads trial Box B can run the same downloaded trial Box A upgrades trial to full Box B can only run in trial mode (if available) Content is downloaded and extracted into place When upgrading to full license the 360 dials home and then some modification is made to lock content to the particular box","title":"General Info"},{"location":"XCP/#first-generation-xbox","text":"xcp files are not new to the Xbox 360. Are encrypted Cabinet files Encrypted with a public and symmetric key. Keys needed for extraction. Need tools to create our own without the Xbox SDK Category:Xbox360 System Software","title":"First Generation Xbox"},{"location":"XConfig/","text":"Categories XCONFIG_STATIC_CATEGORY = 0x0 XCONFIG_STATISTIC_CATEGORY = 0x1 XCONFIG_SECURED_CATEGORY = 0x2 XCONFIG_USER_CATEGORY = 0x3 XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY = 0x4 XCONFIG_XNET_PARAMETERS_CATEGORY = 0x5 XCONFIG_MEDIA_CENTER_CATEGORY = 0x6 XCONFIG_CONSOLE_CATEGORY = 0x7 XCONFIG_DVD_CATEGORY = 0x8 XCONFIG_IPTV_CATEGORY = 0x9 XCONFIG_SYSTEM_CATEGORY = 0xa Notes XCONFIG_STATIC_SETTINGS 0x0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0x00 Version unsigned long 4 0x04 FirstPowerOnDate char[] 5 0x08 // key 0x1 5 bytes Reserved char 1 0x0D SMCBlock union <unnamed-tag> 256 0x0E ----------------------------------------------------------------------------------------------------------- SMCBlock ~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- StuctureVersion unsigned char 1 0x0E ConfigSource unsigned char 1 0x0F ClockSelect char 1 0x10 FanOverride Struct_XCONFIG_STATIC_SETTINGS 2 0x11 pad1 char[] 1 0x13 RadioEnable char 1 0x14 0 1 //This is the \"bit field\" at offset 6 ;// 1 byte total for this bitfield UseTempCalDefaults char 1 0x14 1 1 ScreenToolStarted char 1 0x14 2 1 ScreenToolFinished char 1 0x14 3 1 ScreenToolExecutionCount char 1 0x14 4 2 pad2 char[] 3 0x15 Temperature union_XCONFIG_STATIC_SETTINGS 16 0x18 AnaFuseValue char 1 0x28 Thermal Struct_XCONFIG_STATIC_SETTINGS 6 0x29 pad3 unsigned char[] 1 0x2F Viper vFlags Struct_XCONFIG_STATIC_SETTINGS 4 0x30 pad4 unsigned char[] 190 0x34 BackupThermalCalData union_XCONFIG_STATIC_SETTINGS 23 0xF2 pad5 unsigned char[] 3 0x109 DoNotUse unsigned char[] 2 0x10C FanOverride ~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Cpu Struct_XCONFIG_STATIC_SETTINGS 1 0 Gpu Struct_XCONFIG_STATIC_SETTINGS 1 0 // 01111111 <- normally disabled as 0x7F Enable : 1; // says 7 is bit 0 Speed : 7; // says 0 bit 7 FanOverrideCpu -------------- Speed unsigned char 1 0 0 7 Enable unsigned char 1 0 7 1 FanOverrideGpu -------------- Speed unsigned char 1 0 0 7 Enable unsigned char 1 0 7 1 ----------------------------------------------------------------------------------------------------------- Temperature ~~~~~~~~~~~ ------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- TempCalData unsigned short[] 16 0 Constant Struct_XCONFIG_STATIC_SETTINGS 16 0 TemperatureConstant ------------------- Cpu Struct_XCONFIG_STATIC_SETTINGS 4 0 Gpu Struct_XCONFIG_STATIC_SETTINGS 4 4 Edram Struct_XCONFIG_STATIC_SETTINGS 4 8 Board Struct_XCONFIG_STATIC_SETTINGS 4 12 TemperatureConstantBoard ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantCpu ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantGpu ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantEdram ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 ----------------------------------------------------------------------------------------------------------- Thermal ~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- SetPoint Struct_XCONFIG_STATIC_SETTINGS 3 0 Overload Struct_XCONFIG_STATIC_SETTINGS 3 3 ThermalSetPoint --------------- Cpu Unsigned char 1 0 Gpu Unsigned char 1 1 Edram Unsigned char 1 2 ThermalOverload --------------- Cpu Unsigned char 1 0 Gpu Unsigned char 1 1 Edram Unsigned char 1 2 ----------------------------------------------------------------------------------------------------------- Viper ~~~~~ ------------------------------------------------------------------------------------------------------------ Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Flags union_XCONFIG_STATIC_SETTINGS 1 0 GpuTarget unsigned char 1 1 MemoryTarget unsigned char 1 2 Checksum unsigned char 1 3 ViperFlags ----------- AsUCHAR Unsigned char 1 0 AsFlags Struct_XCONFIG_STATIC_SETTINGS 1 0 ViperAsFlags ------------ MemoryVoltageNotSetting Unsigned char 1 0 6 1 : 1; // bit 6 (bit 5 thru 0 unused GpuVoltageNotSetting unsigned char 1 0 7 1 : 1; // bit 7 //u8 unknown : 6; // 1 byte u8 GpuTarget; u8 MemoryTarget; u8 CheckSum; ----------------------------------------------------------------------------------------------------------- BackupThermalCalData ~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Temperature union_XCONFIG_STATIC_SETTINGS 16 0 // Same as other info AnaFuseValue char 1 16 Thermal Struct_XCONFIG_STATIC_SETTINGS 6 17 ----------------------------------------------------------------------------------------------------------- XCONFIG_STATISTIC_SETTINGS 0x1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 XUIDMACAddress char[] 6 8 Reserved char[] 2 14 XUIDCount unsigned long 4 16 ODDFailures unsigned char[] 32 20 BugCheckData unsigned char[] 101 52 TemperatureData unsigned char[] 200 153 Unused char[] 467 353 HDDSmartData char[] 512 820 UEMErrors char[] 100 1332 FPMErrors char[] 56 1432 LastReportTime unsigned int 8 1488 ----------------------------------------------------------------------------------------------------------- XCONFIG_SECURED_SETTINGS 0x2 // This is the other static one right after the SMCBlock ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum Unsigned Long 4 0 Version Unsigned Long 4 4 OnlineNetworkID char[] 4 8 Reserved1 char[] 8 12 Reserved2 char[] 12 20 MACAddress unsigned char[] 6 32 Reserved3 char[] 2 38 AVRegion unsigned long 4 40 GameRegion unsigned short 2 44 Reserved4 char[] 6 46 DVDRegion unsigned long 4 52 ResetKey unsigned long 4 56 SystemFlags unsigned long 4 60 PowerMode Struct_XCONFIG_POWER_MODE 2 64 PowerVcsControl Struct_XCONFIG_POWER_VCS_CONTROL 2 66 ReservedRegion char[] 444 68 PowerMode --------- VIDDelta unsigned char 1 0 Reserved unsigned char 1 1 PowerVCSControl --------------- Configured unsigned short 2 0 15 1 Reserved unsigned short 2 0 12 3 Full unsigned short 2 0 8 4 Quiet unsigned short 2 0 4 4 Fuse unsigned short 2 0 0 4 ----------------------------------------------------------------------------------------------------------- XCONFIG_USER_SETTINGS 0x3 ~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 TimeZoneBias unsigned long 4 8 TimeZoneStdName char[] 4 12 TimeZoneDltName char[] 4 16 TimeZoneStdDate struct_XCONFIG_TIMEZONE_DATE 4 20 TimeZoneDltDate struct_XCONFIG_TIMEZONE_DATE 4 24 TimeZoneStdBias unsigned long 4 28 TimeZoneDltBias unsigned long 4 32 DefaultProfile unsigned int 8 36 Language unsigned long 4 44 VideoFlags unsigned long 4 48 AudioFlags unsigned long 4 52 RetailFlags unsigned long 4 56 DevkitFlags unsigned long 4 60 Country char 1 64 ParentalControlFlags char 1 65 ReservedFlag unsigned char[] 2 66 SMBConfig char[] 256 68 LivePUID unsigned int 8 324 LiveCredentials char[] 16 332 AVPackHDMIScreenSz signed short[] 4 348 AVPackComponentScreenSz signed short[] 4 352 AVPackVGAScreenSz signed short[] 4 356 ParentalControlGame unsigned long 4 360 ParentalControlPassword unsigned long 4 364 ParentalControlMovie unsigned long 4 368 ParentalControlGameRating unsigned long 4 372 ParentalControlMovieRating unsigned long 4 376 ParentalControlHint char 1 380 ParentalControlHintAnswer char[] 32 381 ParentalControlOverride char[] 32 413 MusicPlaybackMode unsigned long 4 445 MusicVolume double 4 449 MusicFlags unsigned long 4 453 ArcadeFlags unsigned long 4 457 ParentalControlVersion unsigned long 4 461 ParentalControlTv unsigned long 4 465 ParentalControlTvRating unsigned long 4 469 ParentalControlExplicitVideo unsigned long 4 473 ParentalControlExplicitVideoRating unsigned long 4 477 ParentalControlUnratedVideo unsigned long 4 481 ParentalControlUnratedVideoRating unsigned long 4 485 VideoOutputBlackLevels unsigned long 4 489 VideoPlayerDisplayMode unsigned char 1 493 AlternativeVideoTimingIDs unsigned long 4 494 VideoDriverOptions unsigned long 4 498 MusicUIFlags unsigned long 4 502 VideoMediaSourceType char 1 506 MusicMediaSourceType char 1 507 PhotoMediaSourceType char 1 508 XCONFIG_TIMEZONE_DATE --------------------- Month unsigned char 1 0 Day unsigned char 1 1 DayOfWeek unsigned char 1 2 Hour unsigned char 1 3 ----------------------------------------------------------------------------------------------------------- XCONFIG_XNET_MACHINE_ACCOUNT 0x4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 Data unsigned long 492 4 ----------------------------------------------------------------------------------------------------------- XCONFIG_XNET_PARAMETERS 0x5 //I believe this is XnetStartupParams which is retrieved at sockinit in xam ~~~~~~~~~~~~~~~~~~~~~~~~~~~ // so this is a struct of XNetStartupParams, but that might not be right. // these Qos things seem to be the \"Ping Limit\" ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- cfgSizeOfStruct unsigned char 1 0 cfgFlags unsigned char 1 1 cfgSockMaxDgramSockets unsigned char 1 2 cfgSockMaxStreamSockets unsigned char 1 3 cfgSockDefaultRecvBufsizeInK unsigned char 1 4 cfgSockDefaultSendBufsizeInK unsigned char 1 5 cfgKeyRegMax unsigned char 1 6 cfgSecRegMax unsigned char 1 7 cfgQosDataLimitDiv4 unsigned char 1 8 cfgQosProbleTimeoutInSeconds unsigned char 1 9 cfgQosProbeEntries unsigned char 1 10 cfgQosSrvMaxSimultaneousResponses unsigned char 1 11 cfgQosPairWaitTimeInSeconds unsigned char 1 12 ----------------------------------------------------------------------------------------------------------- XCONFIG_MEDIA_CENTER_SETTINGS 0x6 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 MediaPlayer char[] 20 8 xeSledVersion unsigned char[] 10 28 xeSledTrustSecret unsigned char[] 20 38 xeSledTrustCode unsigned char[] 8 58 xeSledHostID unsigned char[] 20 66 xeSledKey unsigned char[] 1628 86 xeSledHostMACAddress unsigned char[] 6 1714 ServerUUID char[] 16 1720 ServerName char[] 128 1736 ServerFlags char[] 4 1864 XCONFIG_CONSOLE_SETTINGS 0x7 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 ScreenSaver signed short 2 8 AutoShutOff signed short 2 10 WirelessSettings unsigned char[] 256 12 CameraSettings unsigned long 4 268 CameraSettingsReserved unsigned char[] 28 272 PlayTimerData struct_XCONFIG_PLAYTIMERDATA 20 300 MediaDisableAutoLaunch signed short 2 320 KeyboardLayout signed short 2 322 PlayTimerData ------------- uliResetDate union_ULARGE_INTEGER 8 0 dwPlayTimerFrequency unsigned long 4 8 dwTotalPlayTime unsigned long 4 12 dwRemainingPlayTime unsigned long 4 16 union_ULARGE_INTEGER -------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 4 u unnamed_ULARGE_INTEGER 8 0 QuadPart unsigned int 8 0 unnamed_ULARGE_INTEGER ---------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 0 ----------------------------------------------------------------------------------------------------------- XCONFIG_DVD_SETTINGS 0x8 ~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 VolumeID unsigned char[] 20 4 Data unsigned char[] 640 24 ----------------------------------------------------------------------------------------------------------- XCONFIG_IPTV_SETTINGS 0x9 ~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 ServiceProviderName wchar_t[] 120 8 ProvisioningServerURL wchar_t[] 128 128 SupportInfo wchar_t[] 128 256 BootstrapServerURL wchar_t[] 128 384 XCONFIG_SYSTEM_SETTINGS 0xA ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 AlarmTime union_LARGE_INTEGER 8 4 PreviousFlashVersion unsigned long 4 12 union_ULARGE_INTEGER -------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 4 u unnamed_ULARGE_INTEGER 8 0 QuadPart unsigned int 8 0 unnamed_ULARGE_INTEGER ---------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 0 -----------------------------------------------------------------------------------------------------------","title":"Categories"},{"location":"XConfig/#categories","text":"XCONFIG_STATIC_CATEGORY = 0x0 XCONFIG_STATISTIC_CATEGORY = 0x1 XCONFIG_SECURED_CATEGORY = 0x2 XCONFIG_USER_CATEGORY = 0x3 XCONFIG_XNET_MACHINE_ACCOUNT_CATEGORY = 0x4 XCONFIG_XNET_PARAMETERS_CATEGORY = 0x5 XCONFIG_MEDIA_CENTER_CATEGORY = 0x6 XCONFIG_CONSOLE_CATEGORY = 0x7 XCONFIG_DVD_CATEGORY = 0x8 XCONFIG_IPTV_CATEGORY = 0x9 XCONFIG_SYSTEM_CATEGORY = 0xa","title":"Categories"},{"location":"XConfig/#notes","text":"XCONFIG_STATIC_SETTINGS 0x0 ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0x00 Version unsigned long 4 0x04 FirstPowerOnDate char[] 5 0x08 // key 0x1 5 bytes Reserved char 1 0x0D SMCBlock union <unnamed-tag> 256 0x0E ----------------------------------------------------------------------------------------------------------- SMCBlock ~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- StuctureVersion unsigned char 1 0x0E ConfigSource unsigned char 1 0x0F ClockSelect char 1 0x10 FanOverride Struct_XCONFIG_STATIC_SETTINGS 2 0x11 pad1 char[] 1 0x13 RadioEnable char 1 0x14 0 1 //This is the \"bit field\" at offset 6 ;// 1 byte total for this bitfield UseTempCalDefaults char 1 0x14 1 1 ScreenToolStarted char 1 0x14 2 1 ScreenToolFinished char 1 0x14 3 1 ScreenToolExecutionCount char 1 0x14 4 2 pad2 char[] 3 0x15 Temperature union_XCONFIG_STATIC_SETTINGS 16 0x18 AnaFuseValue char 1 0x28 Thermal Struct_XCONFIG_STATIC_SETTINGS 6 0x29 pad3 unsigned char[] 1 0x2F Viper vFlags Struct_XCONFIG_STATIC_SETTINGS 4 0x30 pad4 unsigned char[] 190 0x34 BackupThermalCalData union_XCONFIG_STATIC_SETTINGS 23 0xF2 pad5 unsigned char[] 3 0x109 DoNotUse unsigned char[] 2 0x10C FanOverride ~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Cpu Struct_XCONFIG_STATIC_SETTINGS 1 0 Gpu Struct_XCONFIG_STATIC_SETTINGS 1 0 // 01111111 <- normally disabled as 0x7F Enable : 1; // says 7 is bit 0 Speed : 7; // says 0 bit 7 FanOverrideCpu -------------- Speed unsigned char 1 0 0 7 Enable unsigned char 1 0 7 1 FanOverrideGpu -------------- Speed unsigned char 1 0 0 7 Enable unsigned char 1 0 7 1 ----------------------------------------------------------------------------------------------------------- Temperature ~~~~~~~~~~~ ------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- TempCalData unsigned short[] 16 0 Constant Struct_XCONFIG_STATIC_SETTINGS 16 0 TemperatureConstant ------------------- Cpu Struct_XCONFIG_STATIC_SETTINGS 4 0 Gpu Struct_XCONFIG_STATIC_SETTINGS 4 4 Edram Struct_XCONFIG_STATIC_SETTINGS 4 8 Board Struct_XCONFIG_STATIC_SETTINGS 4 12 TemperatureConstantBoard ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantCpu ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantGpu ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 TemperatureConstantEdram ------------------------ Gain unsigned short 2 0 Offset unsigned short 2 2 ----------------------------------------------------------------------------------------------------------- Thermal ~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- SetPoint Struct_XCONFIG_STATIC_SETTINGS 3 0 Overload Struct_XCONFIG_STATIC_SETTINGS 3 3 ThermalSetPoint --------------- Cpu Unsigned char 1 0 Gpu Unsigned char 1 1 Edram Unsigned char 1 2 ThermalOverload --------------- Cpu Unsigned char 1 0 Gpu Unsigned char 1 1 Edram Unsigned char 1 2 ----------------------------------------------------------------------------------------------------------- Viper ~~~~~ ------------------------------------------------------------------------------------------------------------ Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Flags union_XCONFIG_STATIC_SETTINGS 1 0 GpuTarget unsigned char 1 1 MemoryTarget unsigned char 1 2 Checksum unsigned char 1 3 ViperFlags ----------- AsUCHAR Unsigned char 1 0 AsFlags Struct_XCONFIG_STATIC_SETTINGS 1 0 ViperAsFlags ------------ MemoryVoltageNotSetting Unsigned char 1 0 6 1 : 1; // bit 6 (bit 5 thru 0 unused GpuVoltageNotSetting unsigned char 1 0 7 1 : 1; // bit 7 //u8 unknown : 6; // 1 byte u8 GpuTarget; u8 MemoryTarget; u8 CheckSum; ----------------------------------------------------------------------------------------------------------- BackupThermalCalData ~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Temperature union_XCONFIG_STATIC_SETTINGS 16 0 // Same as other info AnaFuseValue char 1 16 Thermal Struct_XCONFIG_STATIC_SETTINGS 6 17 ----------------------------------------------------------------------------------------------------------- XCONFIG_STATISTIC_SETTINGS 0x1 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 XUIDMACAddress char[] 6 8 Reserved char[] 2 14 XUIDCount unsigned long 4 16 ODDFailures unsigned char[] 32 20 BugCheckData unsigned char[] 101 52 TemperatureData unsigned char[] 200 153 Unused char[] 467 353 HDDSmartData char[] 512 820 UEMErrors char[] 100 1332 FPMErrors char[] 56 1432 LastReportTime unsigned int 8 1488 ----------------------------------------------------------------------------------------------------------- XCONFIG_SECURED_SETTINGS 0x2 // This is the other static one right after the SMCBlock ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum Unsigned Long 4 0 Version Unsigned Long 4 4 OnlineNetworkID char[] 4 8 Reserved1 char[] 8 12 Reserved2 char[] 12 20 MACAddress unsigned char[] 6 32 Reserved3 char[] 2 38 AVRegion unsigned long 4 40 GameRegion unsigned short 2 44 Reserved4 char[] 6 46 DVDRegion unsigned long 4 52 ResetKey unsigned long 4 56 SystemFlags unsigned long 4 60 PowerMode Struct_XCONFIG_POWER_MODE 2 64 PowerVcsControl Struct_XCONFIG_POWER_VCS_CONTROL 2 66 ReservedRegion char[] 444 68 PowerMode --------- VIDDelta unsigned char 1 0 Reserved unsigned char 1 1 PowerVCSControl --------------- Configured unsigned short 2 0 15 1 Reserved unsigned short 2 0 12 3 Full unsigned short 2 0 8 4 Quiet unsigned short 2 0 4 4 Fuse unsigned short 2 0 0 4 ----------------------------------------------------------------------------------------------------------- XCONFIG_USER_SETTINGS 0x3 ~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 TimeZoneBias unsigned long 4 8 TimeZoneStdName char[] 4 12 TimeZoneDltName char[] 4 16 TimeZoneStdDate struct_XCONFIG_TIMEZONE_DATE 4 20 TimeZoneDltDate struct_XCONFIG_TIMEZONE_DATE 4 24 TimeZoneStdBias unsigned long 4 28 TimeZoneDltBias unsigned long 4 32 DefaultProfile unsigned int 8 36 Language unsigned long 4 44 VideoFlags unsigned long 4 48 AudioFlags unsigned long 4 52 RetailFlags unsigned long 4 56 DevkitFlags unsigned long 4 60 Country char 1 64 ParentalControlFlags char 1 65 ReservedFlag unsigned char[] 2 66 SMBConfig char[] 256 68 LivePUID unsigned int 8 324 LiveCredentials char[] 16 332 AVPackHDMIScreenSz signed short[] 4 348 AVPackComponentScreenSz signed short[] 4 352 AVPackVGAScreenSz signed short[] 4 356 ParentalControlGame unsigned long 4 360 ParentalControlPassword unsigned long 4 364 ParentalControlMovie unsigned long 4 368 ParentalControlGameRating unsigned long 4 372 ParentalControlMovieRating unsigned long 4 376 ParentalControlHint char 1 380 ParentalControlHintAnswer char[] 32 381 ParentalControlOverride char[] 32 413 MusicPlaybackMode unsigned long 4 445 MusicVolume double 4 449 MusicFlags unsigned long 4 453 ArcadeFlags unsigned long 4 457 ParentalControlVersion unsigned long 4 461 ParentalControlTv unsigned long 4 465 ParentalControlTvRating unsigned long 4 469 ParentalControlExplicitVideo unsigned long 4 473 ParentalControlExplicitVideoRating unsigned long 4 477 ParentalControlUnratedVideo unsigned long 4 481 ParentalControlUnratedVideoRating unsigned long 4 485 VideoOutputBlackLevels unsigned long 4 489 VideoPlayerDisplayMode unsigned char 1 493 AlternativeVideoTimingIDs unsigned long 4 494 VideoDriverOptions unsigned long 4 498 MusicUIFlags unsigned long 4 502 VideoMediaSourceType char 1 506 MusicMediaSourceType char 1 507 PhotoMediaSourceType char 1 508 XCONFIG_TIMEZONE_DATE --------------------- Month unsigned char 1 0 Day unsigned char 1 1 DayOfWeek unsigned char 1 2 Hour unsigned char 1 3 ----------------------------------------------------------------------------------------------------------- XCONFIG_XNET_MACHINE_ACCOUNT 0x4 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 Data unsigned long 492 4 ----------------------------------------------------------------------------------------------------------- XCONFIG_XNET_PARAMETERS 0x5 //I believe this is XnetStartupParams which is retrieved at sockinit in xam ~~~~~~~~~~~~~~~~~~~~~~~~~~~ // so this is a struct of XNetStartupParams, but that might not be right. // these Qos things seem to be the \"Ping Limit\" ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- cfgSizeOfStruct unsigned char 1 0 cfgFlags unsigned char 1 1 cfgSockMaxDgramSockets unsigned char 1 2 cfgSockMaxStreamSockets unsigned char 1 3 cfgSockDefaultRecvBufsizeInK unsigned char 1 4 cfgSockDefaultSendBufsizeInK unsigned char 1 5 cfgKeyRegMax unsigned char 1 6 cfgSecRegMax unsigned char 1 7 cfgQosDataLimitDiv4 unsigned char 1 8 cfgQosProbleTimeoutInSeconds unsigned char 1 9 cfgQosProbeEntries unsigned char 1 10 cfgQosSrvMaxSimultaneousResponses unsigned char 1 11 cfgQosPairWaitTimeInSeconds unsigned char 1 12 ----------------------------------------------------------------------------------------------------------- XCONFIG_MEDIA_CENTER_SETTINGS 0x6 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 MediaPlayer char[] 20 8 xeSledVersion unsigned char[] 10 28 xeSledTrustSecret unsigned char[] 20 38 xeSledTrustCode unsigned char[] 8 58 xeSledHostID unsigned char[] 20 66 xeSledKey unsigned char[] 1628 86 xeSledHostMACAddress unsigned char[] 6 1714 ServerUUID char[] 16 1720 ServerName char[] 128 1736 ServerFlags char[] 4 1864 XCONFIG_CONSOLE_SETTINGS 0x7 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 ScreenSaver signed short 2 8 AutoShutOff signed short 2 10 WirelessSettings unsigned char[] 256 12 CameraSettings unsigned long 4 268 CameraSettingsReserved unsigned char[] 28 272 PlayTimerData struct_XCONFIG_PLAYTIMERDATA 20 300 MediaDisableAutoLaunch signed short 2 320 KeyboardLayout signed short 2 322 PlayTimerData ------------- uliResetDate union_ULARGE_INTEGER 8 0 dwPlayTimerFrequency unsigned long 4 8 dwTotalPlayTime unsigned long 4 12 dwRemainingPlayTime unsigned long 4 16 union_ULARGE_INTEGER -------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 4 u unnamed_ULARGE_INTEGER 8 0 QuadPart unsigned int 8 0 unnamed_ULARGE_INTEGER ---------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 0 ----------------------------------------------------------------------------------------------------------- XCONFIG_DVD_SETTINGS 0x8 ~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 VolumeID unsigned char[] 20 4 Data unsigned char[] 640 24 ----------------------------------------------------------------------------------------------------------- XCONFIG_IPTV_SETTINGS 0x9 ~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- CheckSum unsigned long 4 0 Version unsigned long 4 4 ServiceProviderName wchar_t[] 120 8 ProvisioningServerURL wchar_t[] 128 128 SupportInfo wchar_t[] 128 256 BootstrapServerURL wchar_t[] 128 384 XCONFIG_SYSTEM_SETTINGS 0xA ~~~~~~~~~~~~~~~~~~~~~~~~~~~ ----------------------------------------------------------------------------------------------------------- Field Name Type Field Size Offset Bit Position Bit Length ----------------------------------------------------------------------------------------------------------- Version unsigned long 4 0 AlarmTime union_LARGE_INTEGER 8 4 PreviousFlashVersion unsigned long 4 12 union_ULARGE_INTEGER -------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 4 u unnamed_ULARGE_INTEGER 8 0 QuadPart unsigned int 8 0 unnamed_ULARGE_INTEGER ---------------------- HighPart unsigned long 4 0 LowPart unsigned long 4 0 -----------------------------------------------------------------------------------------------------------","title":"Notes"},{"location":"XContent/","text":"REDIRECT STFS","title":"XContent"},{"location":"XDBF/","text":"XDBF ( X box D ata B ase F ile) files are used by the Xbox 360 as a generic database. It is used as the format for GPD ( G amer P rofile D ata) and SPA ( S tatistics, P resence and A chievements) files. SPA files are linked into an Xbox 360 executable during compilation and are used by the dashboard to generate the GPD, Save Game ( STFS ) Meta-Data and Images. In the XAM the DataFile class handles all of the operations associated with these files. Header Total length: 24 bytes (0x18) Byte ordering: Dependant on magic. If the magic is little endian then the whole file is and is a GFWL, if it's big endian then it's an Xbox file. Offset Length Type Information 0x0 0x4 ascii string Magic (0x58444246) 0x4 0x4 unsigned int Version (0x10000) 0x8 0x4 unsigned int Entry Table Length (in number of entries) 0xC 0x4 unsigned int Entry Count 0x10 0x4 unsigned int Free Space Table Length (in number of entries) 0x14 0x4 unsigned int Free Space Table Entry Count Entry Table Length and Free Space Table Length will be a multiple of 512, this is just Xbox's preferred values, but it will read the file if you decrease them to make the size of the file smaller, alot smaller. Entry Table The Entry Table is made up of entries, each one under a different namespace and ID. The table length will be Entry Table Length * 18, but only the first Entry Count are used. Entry Structure Total length: 18 bytes (0x12) Offset Length Type Information 0x0 0x2 unsigned short Namespace (see [[GPD 0x2 0x8 unsigned long ID 0xA 0x4 unsigned int OffsetSpecifier 0xE 0x4 unsigned int Length Free Space Table The Free Space Table is used to map out the unused space within the file. It is updated whenever n entry changes size. Each entry within the Free Space Table is composed of the OffsetSpecifier and how much space is unused their (Length). The final entry in the Free Space Table isn't actually free space, but rather is information about the length of data after the tables. The OffsetSpecifier would be the length (file length - header and tables) and the Length would be -1 - OffsetSpecifier . Free Space Entry Structure Total length: 8 bytes Offset Length Type Information 0x0 0x4 unsigned int OffsetSpecifier 0x4 0x4 unsigned int Length Entry Data Offset To work out the real entry data offset, times the Entry Table Length by 0x12, then times the Free Space Table Length by 0x8 and add the result together, and add 0x18 (file header). This is where the beginning of the entry data begins, then add the OffsetSpecifier by the entry to get the real offset. ((( Entry Table Length * 18) + ( Free Space Table Length * 8)) + 24) + OffsetSpecifier Just to explain a bit more, Entry Table Length * 18, 18 being the length of each entry, this will workout the actual length of the entry table. Free Space Table Length * 8, 8 being the length of each free space entry, workout the actual length of the free space table. + 24, 24 is the length of the header. Category:Xbox360_System_Software","title":"XDBF"},{"location":"XDBF/#header","text":"Total length: 24 bytes (0x18) Byte ordering: Dependant on magic. If the magic is little endian then the whole file is and is a GFWL, if it's big endian then it's an Xbox file. Offset Length Type Information 0x0 0x4 ascii string Magic (0x58444246) 0x4 0x4 unsigned int Version (0x10000) 0x8 0x4 unsigned int Entry Table Length (in number of entries) 0xC 0x4 unsigned int Entry Count 0x10 0x4 unsigned int Free Space Table Length (in number of entries) 0x14 0x4 unsigned int Free Space Table Entry Count Entry Table Length and Free Space Table Length will be a multiple of 512, this is just Xbox's preferred values, but it will read the file if you decrease them to make the size of the file smaller, alot smaller.","title":"Header"},{"location":"XDBF/#entry-table","text":"The Entry Table is made up of entries, each one under a different namespace and ID. The table length will be Entry Table Length * 18, but only the first Entry Count are used.","title":"Entry Table"},{"location":"XDBF/#entry-structure","text":"Total length: 18 bytes (0x12) Offset Length Type Information 0x0 0x2 unsigned short Namespace (see [[GPD 0x2 0x8 unsigned long ID 0xA 0x4 unsigned int OffsetSpecifier 0xE 0x4 unsigned int Length","title":"Entry Structure"},{"location":"XDBF/#free-space-table","text":"The Free Space Table is used to map out the unused space within the file. It is updated whenever n entry changes size. Each entry within the Free Space Table is composed of the OffsetSpecifier and how much space is unused their (Length). The final entry in the Free Space Table isn't actually free space, but rather is information about the length of data after the tables. The OffsetSpecifier would be the length (file length - header and tables) and the Length would be -1 - OffsetSpecifier .","title":"Free Space Table"},{"location":"XDBF/#free-space-entry-structure","text":"Total length: 8 bytes Offset Length Type Information 0x0 0x4 unsigned int OffsetSpecifier 0x4 0x4 unsigned int Length","title":"Free Space Entry Structure"},{"location":"XDBF/#entry-data-offset","text":"To work out the real entry data offset, times the Entry Table Length by 0x12, then times the Free Space Table Length by 0x8 and add the result together, and add 0x18 (file header). This is where the beginning of the entry data begins, then add the OffsetSpecifier by the entry to get the real offset. ((( Entry Table Length * 18) + ( Free Space Table Length * 8)) + 24) + OffsetSpecifier Just to explain a bit more, Entry Table Length * 18, 18 being the length of each entry, this will workout the actual length of the entry table. Free Space Table Length * 8, 8 being the length of each free space entry, workout the actual length of the free space table. + 24, 24 is the length of the header. Category:Xbox360_System_Software","title":"Entry Data Offset"},{"location":"XDK_Kernel/","text":"XDK Version Flash Version Comment 2.0.0198.0 2.0.????.0 First XDK Launcher Alpha 1 2.0.1232.0 2.0.????.0 Second XDK Launcher Alpha 2 2.0.1838.1 2.0.1838.1 Beta Launcher 2.0.1839.2 2.0.????.0 XeDK release Dashboard 2.0.1888.0 2.0.1888.0 XeDK 2.0.2099.9 2.0.????.0 XeDK 2.0.2135.0 2.0.????.0 XeDK 2.0.2417.0 2.0.2241.0 XeDK 2.0.2638.0 2.0.2258.0 XeDK 2.0.2638.0 2.0.2419.0 XeDK 2.0.2920.0 2.0.2832.0 XeDK - Remote includes 1888, 2241, 2255, 2258 and 2832 2.0.3215.0 2.0.2853.0 XeDK 2.0.3424.0 2.0.2858.0 XeDK 2.0.4314.0 2.0.4308.0 XeDK 2.0.4802.0 2.0.????.0 XeDK 2.0.4929.0 2.0.4548.0 XeDK 2.0.5426.0 2.0.4548.0 XeDK - Last recovery KK exploit works 2.0.5632.0 2.0.4548.0 XeDK - Remote includes 4548 and 5632 2.0.5787.0 2.0.????.0 XeDK - ISO image in game format 2.0.6132.0 2.0.5759.0 XeDK 2.0.6274.0 2.0.????.0 XeDK 2.0.6534.0 2.0.5759.0 XeDK - Remote includes 5787 (no 5759 ?) 2.0.6534.4 2.0.6683.0 XeDK 2.0.6707.0 2.0.????.0 XeDK 2.0.6995.0 2.0.6690.0 XeDK 2.0.6995.1 2.0.6690.0 XeDK 2.0.7645.0 2.0.6690.0 XeDK - Remote includes 6690 2.0.7645.1 2.0.6690.0 XeDK 2.0.7776.0 2.0.6719.0 XeDK 2.0.7776.1 2.0.6719.0 XeDK 2.0.7978.0 2.0.7342.0 XeDK 2.0.7978.3 2.0.7359.0 XeDK 2.0.8276.0 2.0.7366.0 XeDK 2.0.8953.0 2.0.????.0 XeDK 2.0.9328.0 2.0.8464.0 XeDK - Remote includes 8464 and 7366 2.0.9328.5 2.0.8498.0 XeDK 2.0.9328.8 2.0.????.0 XeDK 2.0.9328.9 2.0.8955.0 XeDK - DO NOT RUN THE LEAKED ISO RECOVERY it was edited by TheFallen93 (afaik) and others to brick kits. You can find the real 9328.9 iso around though with filesize 301,434,880 bytes 2.0.11164.0 2.0.9189.0 XeDK 2.0.11164.1 2.0.9189.0 XeDK 2.0.11511.0 2.0.11025.0 XeDK 2.0.11626.0 2.0.?????.0 XeDK 2.0.11626.1 2.0.?????.0 XeDK 2.0.11775.3 2.0.12387.0 XeDK - ISO leaked from chinese forums, remote includes 12387 and 9199 2.0.11776.3 2.0.?????.0 XeDK 2.0.20353.0 2.0.12611.0 XeDK - Remote leaked from MS server 2.0.20353.2 2.0.12625.0 XeDK 2.0.20500.1 2.0.13139.0 XeDK Category:Xbox360 System Software","title":"XDK Kernel"},{"location":"XEX/","text":"File Format Speculation XEX is the executable file format used by the Xbox 360 operating system. It seems to be a crypto and packing container for PPC PE executable files, comparable to UPX or TEEE Burneye. It's likely the 360 knows how to grab the section it needs into memory and decrypt/decompress on demand, instead of traditional all at once extraction. Cryptography The executable code seems to be crypted, though, there exists some uncrypted XEX files in the wild. The following program dumps what is supposed to be a hash table. Actually it has been reported to work with the first official \"Backward Compatibility\" .XEX File from Microsoft. It takes the XEX file as argument. // default.xex table dumper // only works with the default.xex from the xbox360 emulator update package. // - th0mas, th0mas.sixbit.org [at] gmail.com #include <stdio.h> #include <string.h> #define TABLE_START 0x288 struct table { unsigned int unknown[6]; }; unsigned int ByteSwap (unsigned int nInt) { union u {unsigned int vi; unsigned char c[sizeof(unsigned int)];}; union v {unsigned int ni; unsigned char d[sizeof(unsigned int)];}; union u un; union v vn; un.vi = nInt; vn.d[0]=un.c[3]; vn.d[1]=un.c[2]; vn.d[2]=un.c[1]; vn.d[3]=un.c[0]; return (vn.ni); } void printTable(struct table *t) { int i; for (i = 0; i < 6; i ) { int j = ByteSwap(t->unknown[i]); printf(\"0x%08x \", j); } printf(\"\\n\"); } int main(int argc, char **argv) { FILE *fp = fopen(argv[1], \"rb\"); struct table tmp; int numEntries = 0; int i; fseek(fp, TABLE_START, SEEK_SET); fread(&numEntries, sizeof(unsigned int), 1, fp); numEntries = ByteSwap(numEntries); for (i = 0; i < numEntries; i ) { fread(&tmp, sizeof(struct table), 1, fp); printTable(&tmp); } } Structure of the XEX File A XEX file is composed of the following: A 24 bytes XEX Header Variable-length program/section headers Program/Section content XEX Header Total length: 24 bytes. Byte ordering: Big Endian . Offset Length Type Information 0x0 0x4 ascii string \"XEX2\" magic 0x4 0x4 module flags (see below) Flags 0x8 0x4 unsigned int PE data offset 0xC 0x4 unsigned int Reserved 0x10 0x4 unsigned int Security Info Offset 0x14 0x4 unsigned int Optional Header Count The Flags field is a bitfield, as shown below: bit 0 - Title Module bit 1 - Exports To Title bit 2 - System Debugger bit 3 - DLL Module bit 4 - Module Patch bit 5 - Patch Full bit 6 - Patch Delta bit 7 - User Mode Optional Headers Following the XEX header is a list of the optional headers within the file. Use the Optional Header Count field to determine how many there are. Each Optional Header is composed of the following: Offset Length Type Information 0x0 0x4 unsigned int Header ID (see below) 0x4 0x8 unsigned int Header Data / Offset to data (see below) To handle the data you would first check to see what its size is, to do this you need to AND the Header ID by 0xFF. If ID & 0xFF == 0x01 then the Header Data field is used to store the headers data, otherwise it's used to store the data's offset. if ID & 0xFF == 0xFF then the Header's data will contain its size if ID & 0xFF == (Anything else) the value of this is the size of the entry in number of DWORDS (times by 4 to get real size) Header IDs Value Description 0x2FF Resource Info 0x3FF Base File Format 0x405 Base Reference 0x5FF Delta Patch Descriptor 0x80FF Bounding Path 0x8105 Device ID 0x10001 Original Base Address 0x10100 Entry Point 0x10201 Image Base Address 0x103FF Import Libraries 0x18002 Checksum Timestamp 0x18102 Enabled For Callcap 0x18200 Enabled For Fastcap 0x183FF Original PE Name 0x200FF Static Libraries 0x20104 TLS Info 0x20200 Default Stack Size 0x20301 Default Filesystem Cache Size 0x20401 Default Heap Size 0x28002 Page Heap Size and Flags 0x30000 System Flags 0x40006 Execution ID 0x401FF Service ID List 0x40201 Title Workspace Size 0x40310 Game Ratings 0x40404 LAN Key 0x405FF Xbox 360 Logo 0x406FF Multidisc Media IDs 0x407FF Alternate Title IDs 0x40801 Additional Title Memory 0xE10402 Exports by Name Program / Section content The program holds a PE file which is crypted/packed, usually starting at offset 0x2000 (described in the XEX header). It's possible to have this PE uncrypted/unpacked on debug XEX files. Section contents are encrypted with CBC AES, with the key changing for each file. It's probably derived from the RSA(?) block at the beginning and a \"secret\" public key in the box. Contents are compressed with microsoft's proprietary LDIC compression (hello, xbox1!). Miscellaneous Strings found in some XEX Files These appear to be important strings found in the update file Directories? XAdu $UPDATES MEDIA \\Device\\CdRom0\\default.xex installupdate.exe The xboxkrnl is updated using the updates. xam.xex xboxkrnl.exe Library includes: XUIRNDR XAUD XGRAPHC XRTLLIB XAPILIB LIBCMT XBOXKRNL D3D9 XUIRUN XUIRNDR Availability of XEX files There are currently at least four XEX files freely available on the net: Original Xbox Game Support November 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm . Original Xbox Game Support December 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm . Windows XP Media Center Edition Update Rollup 2 from http://www.xbox.com/en-US/pcsetup/alldownloads.htm . Use cabextract to extract the executable file, then do the same on mcrdinstaller/ehd.cab inside the archive. This cabinet file contains XboxMcx.xex. XBOX 360 HD DVD Update found on http://www.xbox.com/en-us/hardware/x/xbox360hddvdplayer/download.htm#disc Programs xextools -- A library and tools for manipulating xex files (xexread replacement). xexdump -- Dumps information about xex files (perl) xexdump -- Dumps information about xex files (windows) Executable Format XEX files are the default executable format. <nowiki> File-offset Description 0 \"XEX2\" 0x4 (module flags?) 0x10 File header offset 0x14 Definition count (see below) 0x18 Definition[] Definition Description 0x2FF Module Sections 0x3FF 0x5FF Delta patch descriptor 0x4004 0x4104 0x42FF 0x80FF Binding path(s) 0x8105 0x10001 Load Address 0x10100 Entry Point 0x10201 Base Address 0x103FF Import Libraries 0x18002 Checksum[4], Filetime[4] 0x18102 (something debug related) 0x183FF PE Name 0x200FF Static Libraries UINT32 Total size entries[total size / 0x10] 0x20104 TLS UINT32 Number of Slots UINT32 Raw Data Address UINT32 Data Size UINT32 Raw Data Size 0x20200 Get Stack Size 0x20301 Cache Element Count 0x30000 0x40006 MediaID[4], Version[4], Baseversion[4], TitleID[4] 0x40310 Game Ratings UINT8 ESRB UINT8 PEGI UINT8 PEGI-FI UINT8 PEGI-PT UINT8 PEGI_BBFC UINT8 CERO UINT8 USK UINT8 OFLCAU UINT8 OFLCNZ UINT8 KMRB UINT8 BRASIL UINT8 FPB 0x40404 Lan Key (16 Bytes) 0x406FF Multidisc, accepted Media IDs 0x40801 FileHeaderOffset Description 0 HeaderSize[4] 0x4 Image Size[4] 0x8 RSA Signature 0x10C (resulting Image size?)[4] 0x110 LoadAddress 0x140 MediaID[16] 0x150 (AES key seed?)[16] 0x164 (Input to SHA)[0x14] 0x178 Region[4] 0x17C SHA Hash[0x14] 0x180 ImageDataCount[4] 0x184...0x184+(IDC*24) ImageData0[8], ImageData1[8], ImageData2[8] </nowiki> Category:Xbox360_System_Software","title":"File Format Speculation"},{"location":"XEX/#file-format-speculation","text":"XEX is the executable file format used by the Xbox 360 operating system. It seems to be a crypto and packing container for PPC PE executable files, comparable to UPX or TEEE Burneye. It's likely the 360 knows how to grab the section it needs into memory and decrypt/decompress on demand, instead of traditional all at once extraction.","title":"File Format Speculation"},{"location":"XEX/#cryptography","text":"The executable code seems to be crypted, though, there exists some uncrypted XEX files in the wild. The following program dumps what is supposed to be a hash table. Actually it has been reported to work with the first official \"Backward Compatibility\" .XEX File from Microsoft. It takes the XEX file as argument. // default.xex table dumper // only works with the default.xex from the xbox360 emulator update package. // - th0mas, th0mas.sixbit.org [at] gmail.com #include <stdio.h> #include <string.h> #define TABLE_START 0x288 struct table { unsigned int unknown[6]; }; unsigned int ByteSwap (unsigned int nInt) { union u {unsigned int vi; unsigned char c[sizeof(unsigned int)];}; union v {unsigned int ni; unsigned char d[sizeof(unsigned int)];}; union u un; union v vn; un.vi = nInt; vn.d[0]=un.c[3]; vn.d[1]=un.c[2]; vn.d[2]=un.c[1]; vn.d[3]=un.c[0]; return (vn.ni); } void printTable(struct table *t) { int i; for (i = 0; i < 6; i ) { int j = ByteSwap(t->unknown[i]); printf(\"0x%08x \", j); } printf(\"\\n\"); } int main(int argc, char **argv) { FILE *fp = fopen(argv[1], \"rb\"); struct table tmp; int numEntries = 0; int i; fseek(fp, TABLE_START, SEEK_SET); fread(&numEntries, sizeof(unsigned int), 1, fp); numEntries = ByteSwap(numEntries); for (i = 0; i < numEntries; i ) { fread(&tmp, sizeof(struct table), 1, fp); printTable(&tmp); } }","title":"Cryptography"},{"location":"XEX/#structure-of-the-xex-file","text":"A XEX file is composed of the following: A 24 bytes XEX Header Variable-length program/section headers Program/Section content","title":"Structure of the XEX File"},{"location":"XEX/#xex-header","text":"Total length: 24 bytes. Byte ordering: Big Endian . Offset Length Type Information 0x0 0x4 ascii string \"XEX2\" magic 0x4 0x4 module flags (see below) Flags 0x8 0x4 unsigned int PE data offset 0xC 0x4 unsigned int Reserved 0x10 0x4 unsigned int Security Info Offset 0x14 0x4 unsigned int Optional Header Count The Flags field is a bitfield, as shown below: bit 0 - Title Module bit 1 - Exports To Title bit 2 - System Debugger bit 3 - DLL Module bit 4 - Module Patch bit 5 - Patch Full bit 6 - Patch Delta bit 7 - User Mode","title":"XEX Header"},{"location":"XEX/#optional-headers","text":"Following the XEX header is a list of the optional headers within the file. Use the Optional Header Count field to determine how many there are. Each Optional Header is composed of the following: Offset Length Type Information 0x0 0x4 unsigned int Header ID (see below) 0x4 0x8 unsigned int Header Data / Offset to data (see below) To handle the data you would first check to see what its size is, to do this you need to AND the Header ID by 0xFF. If ID & 0xFF == 0x01 then the Header Data field is used to store the headers data, otherwise it's used to store the data's offset. if ID & 0xFF == 0xFF then the Header's data will contain its size if ID & 0xFF == (Anything else) the value of this is the size of the entry in number of DWORDS (times by 4 to get real size)","title":"Optional Headers"},{"location":"XEX/#header-ids","text":"Value Description 0x2FF Resource Info 0x3FF Base File Format 0x405 Base Reference 0x5FF Delta Patch Descriptor 0x80FF Bounding Path 0x8105 Device ID 0x10001 Original Base Address 0x10100 Entry Point 0x10201 Image Base Address 0x103FF Import Libraries 0x18002 Checksum Timestamp 0x18102 Enabled For Callcap 0x18200 Enabled For Fastcap 0x183FF Original PE Name 0x200FF Static Libraries 0x20104 TLS Info 0x20200 Default Stack Size 0x20301 Default Filesystem Cache Size 0x20401 Default Heap Size 0x28002 Page Heap Size and Flags 0x30000 System Flags 0x40006 Execution ID 0x401FF Service ID List 0x40201 Title Workspace Size 0x40310 Game Ratings 0x40404 LAN Key 0x405FF Xbox 360 Logo 0x406FF Multidisc Media IDs 0x407FF Alternate Title IDs 0x40801 Additional Title Memory 0xE10402 Exports by Name","title":"Header IDs"},{"location":"XEX/#program-section-content","text":"The program holds a PE file which is crypted/packed, usually starting at offset 0x2000 (described in the XEX header). It's possible to have this PE uncrypted/unpacked on debug XEX files. Section contents are encrypted with CBC AES, with the key changing for each file. It's probably derived from the RSA(?) block at the beginning and a \"secret\" public key in the box. Contents are compressed with microsoft's proprietary LDIC compression (hello, xbox1!).","title":"Program / Section content"},{"location":"XEX/#miscellaneous","text":"","title":"Miscellaneous"},{"location":"XEX/#strings-found-in-some-xex-files","text":"These appear to be important strings found in the update file Directories? XAdu $UPDATES MEDIA \\Device\\CdRom0\\default.xex installupdate.exe The xboxkrnl is updated using the updates. xam.xex xboxkrnl.exe Library includes: XUIRNDR XAUD XGRAPHC XRTLLIB XAPILIB LIBCMT XBOXKRNL D3D9 XUIRUN XUIRNDR","title":"Strings found in some XEX Files"},{"location":"XEX/#availability-of-xex-files","text":"There are currently at least four XEX files freely available on the net: Original Xbox Game Support November 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm . Original Xbox Game Support December 2005 update found on http://www.xbox.com/en-US/games/backwardscompatibility.htm . Windows XP Media Center Edition Update Rollup 2 from http://www.xbox.com/en-US/pcsetup/alldownloads.htm . Use cabextract to extract the executable file, then do the same on mcrdinstaller/ehd.cab inside the archive. This cabinet file contains XboxMcx.xex. XBOX 360 HD DVD Update found on http://www.xbox.com/en-us/hardware/x/xbox360hddvdplayer/download.htm#disc","title":"Availability of XEX files"},{"location":"XEX/#programs","text":"xextools -- A library and tools for manipulating xex files (xexread replacement). xexdump -- Dumps information about xex files (perl) xexdump -- Dumps information about xex files (windows)","title":"Programs"},{"location":"XEX/#executable-format","text":"XEX files are the default executable format. <nowiki> File-offset Description 0 \"XEX2\" 0x4 (module flags?) 0x10 File header offset 0x14 Definition count (see below) 0x18 Definition[] Definition Description 0x2FF Module Sections 0x3FF 0x5FF Delta patch descriptor 0x4004 0x4104 0x42FF 0x80FF Binding path(s) 0x8105 0x10001 Load Address 0x10100 Entry Point 0x10201 Base Address 0x103FF Import Libraries 0x18002 Checksum[4], Filetime[4] 0x18102 (something debug related) 0x183FF PE Name 0x200FF Static Libraries UINT32 Total size entries[total size / 0x10] 0x20104 TLS UINT32 Number of Slots UINT32 Raw Data Address UINT32 Data Size UINT32 Raw Data Size 0x20200 Get Stack Size 0x20301 Cache Element Count 0x30000 0x40006 MediaID[4], Version[4], Baseversion[4], TitleID[4] 0x40310 Game Ratings UINT8 ESRB UINT8 PEGI UINT8 PEGI-FI UINT8 PEGI-PT UINT8 PEGI_BBFC UINT8 CERO UINT8 USK UINT8 OFLCAU UINT8 OFLCNZ UINT8 KMRB UINT8 BRASIL UINT8 FPB 0x40404 Lan Key (16 Bytes) 0x406FF Multidisc, accepted Media IDs 0x40801 FileHeaderOffset Description 0 HeaderSize[4] 0x4 Image Size[4] 0x8 RSA Signature 0x10C (resulting Image size?)[4] 0x110 LoadAddress 0x140 MediaID[16] 0x150 (AES key seed?)[16] 0x164 (Input to SHA)[0x14] 0x178 Region[4] 0x17C SHA Hash[0x14] 0x180 ImageDataCount[4] 0x184...0x184+(IDC*24) ImageData0[8], ImageData1[8], ImageData2[8] </nowiki> Category:Xbox360_System_Software","title":"Executable Format"},{"location":"XMENU/","text":"General Info NFO Xmenu 0.3 ========= Xmenu is an elf loader with a basic gui. Installation ============ Copy the file xenon.elf and the \"xenon\" folder to the root of your usb disk/pen. Load it with the free60.org hack. Changelog ========= Version 0.3 : - It's now possible to load custom icons. Put a \".png\" image (32 bits, with alpha channel, 32*32 pixels would be better) alongside your executable file, with the \".ico\" extension. Example : If you have an executable named \"snes9x.elf\", put the \".png\" icon in the same directory with the name \"snes9x.ico\". Version 0.2 : - Graphics data is now loaded at startup, allowing to customise. - Smaller fonts, this allow more items to be displayed. Version 0.1 : - Alpha testing version. Thanks ====== Sasoseso from xboxhacker.net for sending me a free xbox 360, if all the people could be like you :) Tmbinc of course for all his work. Ced2911 for sega master system emulators sources, helped me a lot. Ge0rG and ssmurf, because they are nice guys :) Cpasjuste @ mydedibox.fr Category:Xbox360_Homebrew_Software\u200f","title":"XMENU"},{"location":"XMENU/#general-info","text":"","title":"General Info"},{"location":"XMENU/#nfo","text":"Xmenu 0.3 ========= Xmenu is an elf loader with a basic gui. Installation ============ Copy the file xenon.elf and the \"xenon\" folder to the root of your usb disk/pen. Load it with the free60.org hack. Changelog ========= Version 0.3 : - It's now possible to load custom icons. Put a \".png\" image (32 bits, with alpha channel, 32*32 pixels would be better) alongside your executable file, with the \".ico\" extension. Example : If you have an executable named \"snes9x.elf\", put the \".png\" icon in the same directory with the name \"snes9x.ico\". Version 0.2 : - Graphics data is now loaded at startup, allowing to customise. - Smaller fonts, this allow more items to be displayed. Version 0.1 : - Alpha testing version. Thanks ====== Sasoseso from xboxhacker.net for sending me a free xbox 360, if all the people could be like you :) Tmbinc of course for all his work. Ced2911 for sega master system emulators sources, helped me a lot. Ge0rG and ssmurf, because they are nice guys :) Cpasjuste @ mydedibox.fr Category:Xbox360_Homebrew_Software\u200f","title":"NFO"},{"location":"XMPlayer/","text":"General Info NFO XMPlayer 0.0.1 - June 17, 2012 -------------- After some long weeks of work, this XMPlayer for 360 ================================================================================ Website & Donate ================================================================================ Ced2911 https://www.paypal.com/cgi-bin/websc...if%3aNonHosted ================================================================================ What it does ================================================================================ - Play video from usb, hard drive and disc drive - Support for ext2fs, ntfs, fat, xtaf and iso9660 partition - French and english translation - Launch elf from every media ================================================================================ What it does not do ================================================================================ - Some 1080p are playing, some doesn't - No network support - No control when playing music files - No picture viewer ================================================================================ Know issues ================================================================================ - Slowdown when using vsync - XTAF support is experimental ================================================================================ What to do next ================================================================================ - More tranlastions - Nand flasher/dumper - Nand fs - Network support (http, youtube, update) - More performance ================================================================================ Install ================================================================================ - Copy all files at the root of an usb stick, launch it by xell or latest dashlaunch Thanks to Aioros cancerous GliGli IceKiller Juvenal Natelx Razkar sk1080 tuxuser [c0z] Category:Xbox360_Homebrew_Software","title":"XMPlayer"},{"location":"XMPlayer/#general-info","text":"","title":"General Info"},{"location":"XMPlayer/#nfo","text":"XMPlayer 0.0.1 - June 17, 2012 -------------- After some long weeks of work, this XMPlayer for 360 ================================================================================ Website & Donate ================================================================================ Ced2911 https://www.paypal.com/cgi-bin/websc...if%3aNonHosted ================================================================================ What it does ================================================================================ - Play video from usb, hard drive and disc drive - Support for ext2fs, ntfs, fat, xtaf and iso9660 partition - French and english translation - Launch elf from every media ================================================================================ What it does not do ================================================================================ - Some 1080p are playing, some doesn't - No network support - No control when playing music files - No picture viewer ================================================================================ Know issues ================================================================================ - Slowdown when using vsync - XTAF support is experimental ================================================================================ What to do next ================================================================================ - More tranlastions - Nand flasher/dumper - Nand fs - Network support (http, youtube, update) - More performance ================================================================================ Install ================================================================================ - Copy all files at the root of an usb stick, launch it by xell or latest dashlaunch Thanks to Aioros cancerous GliGli IceKiller Juvenal Natelx Razkar sk1080 tuxuser [c0z] Category:Xbox360_Homebrew_Software","title":"NFO"},{"location":"XTAF/","text":"REDIRECT FATX","title":"XTAF"},{"location":"Xbox_360_Motherboards/","text":"The XBox 360 motherboard has gone through several changes over the years. These changes often reduced die sizes of various chips (CPU (Xenon), GPU (Xenos), eDRAM , etc.), added new features (HDMI, etc.) and patched the SMC/JTAG exploit. This pages lists off all known motherboard revisions, their changes as well as links to their respective pages. '''NOTE TO MAINTAINERS: ''' This page is often ripped apart by spam bots! Please check and revert any unwanted changes regularly! Xenon (V1) The original Xbox 360 configuration used in the initial Premium and Core machines released in the end of November 2005. These are also known as the RRoD (Red Ring of Death) machines because the GPU chip warps away from the motherboard because of excessive heat. Consoles : Core, Pro/Premium 20GB 90nm IBM CPU 90nm ATI GPU and 90nm on-chip eDRAM Low profile GPU cooler Standard CPU cooler 203 Watt output power supply (16.5 A) Shipping with Hitachi46-78, Samsung ms25or ms28, BenQ DVD-Drive. Can also come with Lite-On drive if it was refurbished. Highly unlikely to have glue around the CPU but it IS possible. Zephyr (V2) Zephyr was the first revision with HDMI connector. It was introduced with the Xbox 360 Elite in May 2007. In July 2007 Xbox 360 Premium machines began appearing with the Zephyr motherboard. Consoles: Arcade, Pro/Premium 20GB, Elite 120GB and Halo 3 Console 90nm IBM CPU & ATI GPU 90nm eDRAM 203 Watt PSU (16.5 A) HDMI video output Updated motherboard layout Glue around the CPU in some cases 3 pin fan connector New Extended GPU heat sink with a heat pipe New Elite model includes 120GB hard drive Shipping with Hitachi 78 or 79 and BenQ DVD-Drive. May also have Lite-On if it was refurbished. Falcon (V3) All Xbox 360 Premium machines and Arcade machines made in August 2007 introduced the new 65 nm CPU accompanied with a new cooler and still 90 nm GPU with the Zephyr cooler. The motherboard is based on Zephyr and requires fewer components (some capacitors and coils removed) for the new 65 nm CPU, resulting in lower costs. Consoles: Arcade, Pro/Premium 20GB & 60GB, Elite 120GB 65nm IBM CPU 90nm ATI GPU 80nm on-chip eDRAM . HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) New CPU Heat sink + the GPU heat sink with heat pipe Fewer voltage regulators, capacitors and inductors Bigger and enhanced CPU cooler RAM removed from bottom of mainboard on later models 3 pin fan connector Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive Opus (V3.1) This is an intermediate motherboard with 65nm CPU and 90nm GPU, new coolers, but no HDMI. It will be used in Xenon chassis for repairs and RRoD affected machines. Started to appear end of July 2008 in machines coming back from repair. It's just a Falcon without a custom A/V (HDMI) port so that it fits into a Xenon chassis and case. Consoles: Core, Pro/Premium 20GB Falcon based board 65nm IBM CPU 90nm ATI GPU with 80nm on-chip eDRAM No HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) Updated Heat sinks Falcon CPU cooler Zephyr GPU cooler 3 pin fan connector Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX DVD-Drive Opus only available from Xenon being repaired by MS . Very Rare Jasper (V4) Jasper introduced the 65nm GPU to reduce power usage and cost further. The new power supply is rated for 150 Watt, down from 175 Watt on the Falcon. The Amperage on the 12V rail is down to 12.1A (12.1A x 12V = 145.2W). The on-board flash has also increased to allow the new NXE (New Xbox Experience) dashboard update to reside internally, instead of requiring a memory unit or the hard drive. Consoles: Arcade 256MB & 512MB, Pro/Premium 60GB, Elite 120GB & 250GB and Resident Evil 5 console 65nm IBM CPU 65nm ATI GPU with 80nm on-chip eDRAM 150 Watt PSU (12V rated for 12.1A, new connector) Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B on-board flash, up from 16MB HY27US08281A flash, to accommodate the NXE update. New Southbridge chipset Ram removed from bottom of mainboard New style CPU Heat sink + the GPU heat sink with heat pipe 3 pin fan connector. New Warranty Sticker. Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers. Least likely to red ring of death (RRoD) due to the less heat being outputted by the chips Jasper (V4.1) Same as Jasper (V4), minor changes. Consoles: Arcade 512MB, Elite 120GB & 250GB, Modern Warfare 2 consoles and Final Fantasy 13 consoles 65nm eDRAM (?) New Southbridge chipset Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE (Removes 256MB Memory Card) Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers. JTAG Hack / SMC patched on CB level Xenon style GPU heat sink with Falcon style CPU heat sink Special edition consoles: Modern Warfare 2 Consoles Last of the original style 360 systems Trinity/ Valhalla (V5) [New Slim Xbox 360] Consoles: 4GB Arcade, Elite 250GB and Halo Reach Console Unified single chip with CPU, GPU and eDRAM at 45nm process. 16MB NAND 135 Watt PSU 802.11n Wi-Fi integrated No more Memory Unit ports Separate Kinect port Different HDD port Smaller form factor 4GB internal Memory on small Daughter board No more RROD, simple red power light on error (unknown on more detail) Corona (?) Referenced in 20353 xbdm.dll, nothing known right now, possibly the newer cheaper XDKs? Information on this board so far: Many say that it is a Trinity Revision (Trinity v2) Console: Forza 4 250 GB (This board was found in a Forza 4 bundle) Manufacture Date: 8-17-2011 No HANA Chip, it's integrated into the Southbridge 115 W PSU CPU: 45 nm Combined Chip (Basicaly the CPU and GPU are combined) HDMI Enabled The interesting thing is that it seems that Microsoft knew about the Reset Glitch Hack, so they removed the HANA Chip. So it seems Microsoft found the exploit days before GliGli brought it out for the public. Corona Sources: Source 1 Source 2 Category:Xbox360_Hardware","title":"Xbox 360 Motherboards"},{"location":"Xbox_360_Motherboards/#xenon-v1","text":"The original Xbox 360 configuration used in the initial Premium and Core machines released in the end of November 2005. These are also known as the RRoD (Red Ring of Death) machines because the GPU chip warps away from the motherboard because of excessive heat. Consoles : Core, Pro/Premium 20GB 90nm IBM CPU 90nm ATI GPU and 90nm on-chip eDRAM Low profile GPU cooler Standard CPU cooler 203 Watt output power supply (16.5 A) Shipping with Hitachi46-78, Samsung ms25or ms28, BenQ DVD-Drive. Can also come with Lite-On drive if it was refurbished. Highly unlikely to have glue around the CPU but it IS possible.","title":"Xenon (V1)"},{"location":"Xbox_360_Motherboards/#zephyr-v2","text":"Zephyr was the first revision with HDMI connector. It was introduced with the Xbox 360 Elite in May 2007. In July 2007 Xbox 360 Premium machines began appearing with the Zephyr motherboard. Consoles: Arcade, Pro/Premium 20GB, Elite 120GB and Halo 3 Console 90nm IBM CPU & ATI GPU 90nm eDRAM 203 Watt PSU (16.5 A) HDMI video output Updated motherboard layout Glue around the CPU in some cases 3 pin fan connector New Extended GPU heat sink with a heat pipe New Elite model includes 120GB hard drive Shipping with Hitachi 78 or 79 and BenQ DVD-Drive. May also have Lite-On if it was refurbished.","title":"Zephyr (V2)"},{"location":"Xbox_360_Motherboards/#falcon-v3","text":"All Xbox 360 Premium machines and Arcade machines made in August 2007 introduced the new 65 nm CPU accompanied with a new cooler and still 90 nm GPU with the Zephyr cooler. The motherboard is based on Zephyr and requires fewer components (some capacitors and coils removed) for the new 65 nm CPU, resulting in lower costs. Consoles: Arcade, Pro/Premium 20GB & 60GB, Elite 120GB 65nm IBM CPU 90nm ATI GPU 80nm on-chip eDRAM . HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) New CPU Heat sink + the GPU heat sink with heat pipe Fewer voltage regulators, capacitors and inductors Bigger and enhanced CPU cooler RAM removed from bottom of mainboard on later models 3 pin fan connector Shipping with Hitachi 79, BenQ and new Lite-On 7XXX series DVD-Drive","title":"Falcon (V3)"},{"location":"Xbox_360_Motherboards/#opus-v31","text":"This is an intermediate motherboard with 65nm CPU and 90nm GPU, new coolers, but no HDMI. It will be used in Xenon chassis for repairs and RRoD affected machines. Started to appear end of July 2008 in machines coming back from repair. It's just a Falcon without a custom A/V (HDMI) port so that it fits into a Xenon chassis and case. Consoles: Core, Pro/Premium 20GB Falcon based board 65nm IBM CPU 90nm ATI GPU with 80nm on-chip eDRAM No HDMI Video Output 175 Watt PSU (2V rated for 14.2A, new connector) Updated Heat sinks Falcon CPU cooler Zephyr GPU cooler 3 pin fan connector Shipping with Hitachi, Samsung, BenQ and Lite-On 7XXX DVD-Drive Opus only available from Xenon being repaired by MS . Very Rare","title":"Opus (V3.1)"},{"location":"Xbox_360_Motherboards/#jasper-v4","text":"Jasper introduced the 65nm GPU to reduce power usage and cost further. The new power supply is rated for 150 Watt, down from 175 Watt on the Falcon. The Amperage on the 12V rail is down to 12.1A (12.1A x 12V = 145.2W). The on-board flash has also increased to allow the new NXE (New Xbox Experience) dashboard update to reside internally, instead of requiring a memory unit or the hard drive. Consoles: Arcade 256MB & 512MB, Pro/Premium 60GB, Elite 120GB & 250GB and Resident Evil 5 console 65nm IBM CPU 65nm ATI GPU with 80nm on-chip eDRAM 150 Watt PSU (12V rated for 12.1A, new connector) Arcade Edition Larger Flash 256MB or 512MB Hynix HY27UF082G2B on-board flash, up from 16MB HY27US08281A flash, to accommodate the NXE update. New Southbridge chipset Ram removed from bottom of mainboard New style CPU Heat sink + the GPU heat sink with heat pipe 3 pin fan connector. New Warranty Sticker. Shipping with LiteOn 7XXX/8XXX/V2/9XXX DVD-Drivers. Least likely to red ring of death (RRoD) due to the less heat being outputted by the chips","title":"Jasper (V4)"},{"location":"Xbox_360_Motherboards/#jasper-v41","text":"Same as Jasper (V4), minor changes. Consoles: Arcade 512MB, Elite 120GB & 250GB, Modern Warfare 2 consoles and Final Fantasy 13 consoles 65nm eDRAM (?) New Southbridge chipset Arcade Edition Larger Flash 256MB and 512MB to accommodate NXE (Removes 256MB Memory Card) Shipping with Lite-On 8XXXV2/9XXX DVD-Drivers. JTAG Hack / SMC patched on CB level Xenon style GPU heat sink with Falcon style CPU heat sink Special edition consoles: Modern Warfare 2 Consoles Last of the original style 360 systems","title":"Jasper (V4.1)"},{"location":"Xbox_360_Motherboards/#trinityvalhalla-v5-new-slim-xbox-360","text":"Consoles: 4GB Arcade, Elite 250GB and Halo Reach Console Unified single chip with CPU, GPU and eDRAM at 45nm process. 16MB NAND 135 Watt PSU 802.11n Wi-Fi integrated No more Memory Unit ports Separate Kinect port Different HDD port Smaller form factor 4GB internal Memory on small Daughter board No more RROD, simple red power light on error (unknown on more detail)","title":"Trinity/Valhalla (V5) [New Slim Xbox 360]"},{"location":"Xbox_360_Motherboards/#corona","text":"Referenced in 20353 xbdm.dll, nothing known right now, possibly the newer cheaper XDKs? Information on this board so far: Many say that it is a Trinity Revision (Trinity v2) Console: Forza 4 250 GB (This board was found in a Forza 4 bundle) Manufacture Date: 8-17-2011 No HANA Chip, it's integrated into the Southbridge 115 W PSU CPU: 45 nm Combined Chip (Basicaly the CPU and GPU are combined) HDMI Enabled The interesting thing is that it seems that Microsoft knew about the Reset Glitch Hack, so they removed the HANA Chip. So it seems Microsoft found the exploit days before GliGli brought it out for the public. Corona Sources: Source 1 Source 2 Category:Xbox360_Hardware","title":"Corona (?)"},{"location":"Xbox_Revision_Identification/","text":"With opening the console When you open your Xbox Console you can determine the Revision precisely. First you have to locate the used Video Encoder Chip! Determine Video-Chip The VideoChip is located in the marked area: Find out which chip your xbox has! CONEXTANT FOCUS XCALIBUR I got a CONEXTANT chip I got a FOCUS chip I got a XCALIBUR chip Without opening the console Just by looking at the serial number, which is visible through the Xbox carton, you have a very good chance to find out the version of an Xbox. You can also get the serial number in Linux with the xbox_tool command. Please note that these rules may not apply to refurbished models. Step 1: Manufacturing Date and Serial Number On the bottom of the Xbox, you can see the manufacturing date and the serial number. The manufacturing date is in the following format: 2004-11-20 i.e. YYYY-MM-DD (Year-Month-Day) which is the date according to ISO 8601. The serial number looks like this: 3137905 44705 i.e. LNNNNNN YWWFF L the number of the production line within the factory, NNNNNN the number of the Xbox within this week, Y the last digit of the production year, WW the number of the week of the production year, FF is the code of the factory (02: Mexico, 03: Hungary, 05: China. 06: Taiwan). Step 2: The Factory Look at the factory code, i.e. the last two digits of the serial number. If the factory code is \"03\" (Hungary), you are done: You can be sure that it is a 1.0 Xbox. You can even be sure that it contains a Thomson DVD drive If the factory code is \"02\" (Mexico), it is either a 1.0 or a 1.1 Xbox. Look at the manufacturing date: If it is November 2002 or later, you have a 1.1 Xbox, else it's a 1.0. If the factory code is \"05\" (China), you have at least a 1.1 Xbox. If the factory code is \"06\" (Taiwan), you have at least a 1.3 Xbox. Step 3: Version Table If you have a \"Halo Special Edition\" Xbox (translucent green), you have version 1.2, which has been made in weeks 8 and 9 of 2003 on lines 2, 5 and 6. If you have a \"Crystal Special Edition\" Xbox (translucent white), you either have a version 1.5 or 1.6 which were made in weeks 32 to 34 of 2004.(Which is not on the list below) Find out the production line of the Xbox, which is the first digit of the serial number. Then find out the year and week of your Xbox. The first digit of the second block is the last digit of the year (i.e. 2 or 3 for 2002 or 2003), and the following two digits are the number of the week. For example, the serial \"1111111 31205\" is from week 12/2003. Now look up the box corresponding to the week and the production line in the following table. The legend below the table will tell you the meaning of the colors. Note :Anything After 18\\04 Is mainly Unknown and is most likly to be a version 1.6 or 1.6b. Week Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 23/02 ? ? 12 Jun ? ? ? 34/02 ? ? 24 Aug ? ? ? 39/02 ? ? ? ? 29 sept ? 42/02 18 Oct 43/02 ? 44/02 ? 45/02 13 Nov 46/02 ? 47/02 20 Nov ? 48/02 ? ? 49/02 03 Dec 03 Dec 50/02 13 Dec 51/02 19 Dec ? 52/02 ? ? 01/03 ? ? 02/03 10 Jan ? 03/03 ? ? 04/03 24 Jan ? 22 Jan 20 Jan 05/03 ? ? ? 06/03 ? ? ? 07/03 ? ? ? 08/03 ? 21 Feb ? 19 Feb 09/03 ? ? 27 Feb ? \\- 10/03 ? 03 Mar ? ? \\- 11/03 ? 10 Mar ? 11 Mar \\- 12/03 ? ? ? \\- 13/03 ? ? ? \\- 14/03 ? 02 Apr 03 Apr \\- 15/03 09 Apr \\- 16/03 \\- 17/03 \\- 18/03 \\- 19/03 04 May 20/03 05 May 21/03 22/03 23/03 02 Jun 24/03 25/03 26/03 27/03 28/03 29/03 ?-?-? 17 Jul 30/03 23 Jul ?-?-? 23 Jul 24 Jul 23 Jul 23 Jul 31/03 28 Jul 32/03 11/04 2 Mar 11/04 11 Mar ? 12/04 ? ? 18 Mar 22 Mar 13/04 28 Mar ? ? 14/04 ? 1 Apr 15/04 ? 5 Apr 10 Apr 16/04 ? ? ? 17/04 ? ? ? 18/04 ? ? ? 31/04 ? ? ? ? ? 33/04 ? ? ? ? 46/04 ? ? ? 11 Nov ? ? 47/04 ? 16 Nov ? ? ? ? 21/05 16 May Legend: 1.0 1.1 1.2 1.3 1.4 1.6 unknown Retrieved from \" http://www.xbox-linux.org/wiki/Xbox_Versions_HOWTO \"","title":"With opening the console"},{"location":"Xbox_Revision_Identification/#with-opening-the-console","text":"When you open your Xbox Console you can determine the Revision precisely. First you have to locate the used Video Encoder Chip!","title":"With opening the console"},{"location":"Xbox_Revision_Identification/#determine-video-chip","text":"The VideoChip is located in the marked area: Find out which chip your xbox has! CONEXTANT FOCUS XCALIBUR","title":"Determine Video-Chip"},{"location":"Xbox_Revision_Identification/#i-got-a-conextant-chip","text":"","title":"I got a CONEXTANT chip"},{"location":"Xbox_Revision_Identification/#i-got-a-focus-chip","text":"","title":"I got a FOCUS chip"},{"location":"Xbox_Revision_Identification/#i-got-a-xcalibur-chip","text":"","title":"I got a XCALIBUR chip"},{"location":"Xbox_Revision_Identification/#without-opening-the-console","text":"Just by looking at the serial number, which is visible through the Xbox carton, you have a very good chance to find out the version of an Xbox. You can also get the serial number in Linux with the xbox_tool command. Please note that these rules may not apply to refurbished models.","title":"Without opening the console"},{"location":"Xbox_Revision_Identification/#step-1-manufacturing-date-and-serial-number","text":"On the bottom of the Xbox, you can see the manufacturing date and the serial number. The manufacturing date is in the following format: 2004-11-20 i.e. YYYY-MM-DD (Year-Month-Day) which is the date according to ISO 8601. The serial number looks like this: 3137905 44705 i.e. LNNNNNN YWWFF L the number of the production line within the factory, NNNNNN the number of the Xbox within this week, Y the last digit of the production year, WW the number of the week of the production year, FF is the code of the factory (02: Mexico, 03: Hungary, 05: China. 06: Taiwan).","title":"Step 1: Manufacturing Date and Serial Number"},{"location":"Xbox_Revision_Identification/#step-2-the-factory","text":"Look at the factory code, i.e. the last two digits of the serial number. If the factory code is \"03\" (Hungary), you are done: You can be sure that it is a 1.0 Xbox. You can even be sure that it contains a Thomson DVD drive If the factory code is \"02\" (Mexico), it is either a 1.0 or a 1.1 Xbox. Look at the manufacturing date: If it is November 2002 or later, you have a 1.1 Xbox, else it's a 1.0. If the factory code is \"05\" (China), you have at least a 1.1 Xbox. If the factory code is \"06\" (Taiwan), you have at least a 1.3 Xbox.","title":"Step 2: The Factory"},{"location":"Xbox_Revision_Identification/#step-3-version-table","text":"If you have a \"Halo Special Edition\" Xbox (translucent green), you have version 1.2, which has been made in weeks 8 and 9 of 2003 on lines 2, 5 and 6. If you have a \"Crystal Special Edition\" Xbox (translucent white), you either have a version 1.5 or 1.6 which were made in weeks 32 to 34 of 2004.(Which is not on the list below) Find out the production line of the Xbox, which is the first digit of the serial number. Then find out the year and week of your Xbox. The first digit of the second block is the last digit of the year (i.e. 2 or 3 for 2002 or 2003), and the following two digits are the number of the week. For example, the serial \"1111111 31205\" is from week 12/2003. Now look up the box corresponding to the week and the production line in the following table. The legend below the table will tell you the meaning of the colors. Note :Anything After 18\\04 Is mainly Unknown and is most likly to be a version 1.6 or 1.6b. Week Line 1 Line 2 Line 3 Line 4 Line 5 Line 6 23/02 ? ? 12 Jun ? ? ? 34/02 ? ? 24 Aug ? ? ? 39/02 ? ? ? ? 29 sept ? 42/02 18 Oct 43/02 ? 44/02 ? 45/02 13 Nov 46/02 ? 47/02 20 Nov ? 48/02 ? ? 49/02 03 Dec 03 Dec 50/02 13 Dec 51/02 19 Dec ? 52/02 ? ? 01/03 ? ? 02/03 10 Jan ? 03/03 ? ? 04/03 24 Jan ? 22 Jan 20 Jan 05/03 ? ? ? 06/03 ? ? ? 07/03 ? ? ? 08/03 ? 21 Feb ? 19 Feb 09/03 ? ? 27 Feb ? \\- 10/03 ? 03 Mar ? ? \\- 11/03 ? 10 Mar ? 11 Mar \\- 12/03 ? ? ? \\- 13/03 ? ? ? \\- 14/03 ? 02 Apr 03 Apr \\- 15/03 09 Apr \\- 16/03 \\- 17/03 \\- 18/03 \\- 19/03 04 May 20/03 05 May 21/03 22/03 23/03 02 Jun 24/03 25/03 26/03 27/03 28/03 29/03 ?-?-? 17 Jul 30/03 23 Jul ?-?-? 23 Jul 24 Jul 23 Jul 23 Jul 31/03 28 Jul 32/03 11/04 2 Mar 11/04 11 Mar ? 12/04 ? ? 18 Mar 22 Mar 13/04 28 Mar ? ? 14/04 ? 1 Apr 15/04 ? 5 Apr 10 Apr 16/04 ? ? ? 17/04 ? ? ? 18/04 ? ? ? 31/04 ? ? ? ? ? 33/04 ? ? ? ? 46/04 ? ? ? 11 Nov ? ? 47/04 ? 16 Nov ? ? ? ? 21/05 16 May Legend: 1.0 1.1 1.2 1.3 1.4 1.6 unknown Retrieved from \" http://www.xbox-linux.org/wiki/Xbox_Versions_HOWTO \"","title":"Step 3: Version Table"},{"location":"Xbox_Revisions/","text":"REDIRECT Xbox 360 Motherboards","title":"Xbox Revisions"},{"location":"Xbox_Software/","text":"REDIRECT Xbox System Software","title":"Xbox Software"},{"location":"Xbox_System_Software/","text":"The Xbox's Original Software is composed of many things, including the bootloaders, the kernel, the dashboard and more. Bootloaders The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process . Hypervisor The Hypervisor is the main operating system being run on the console. It looks after the kernel and stops things like buffer overflows from happening. It also manages a lot of the security aspects of the 360, including memory encryption and region protection. It has code to handle the XeKeys (keyvault + some static ones) and XEXs. The end-user of an Xbox would never have any knowledge of the hypervisor, it's only really interesting for hackers. Kernel The Xbox 360's Kernel is responsible for low level hardware communication and more. This is the main part of the 360, the kernel is where all the user-based stuff happens. The drivers for accessing most of the hardware is located in the Kernel, along with certain drivers for other things used by the system (e.g. FATX (File Allocation Table for Xbox), STFS (Secure Transacted File System), SFCX (System Flash Controller for Xbox). This is the most interesting part of the console because of all the functions it performs. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0. nnnnn .0, where nnnnn is your kernel version. XAM A lot of fun things are inside XAM. XAM handles gamer profiles and online interactivity, so as you can guess not a lot of information is made public about it. XeDevWiki hopes to change that. XAM handles such things as XDBF ( X box D ata b ase F ile) files ( GPD ( G amer P rogress D ata)/ SPA ) and PEC ( P rofile E mbedded C ontent) files. File Systems The Xbox 360 uses various File Systems for storing games, user content and more. FATX ( F ile A llocation T able for X box) is used as the storage filesystem on hard drives/memory units/USB devices/xlaunch.fdf files. GDFX /XSF ( G ame D isc F ormat for X box) is the filesystem used on X360 CD/DVD Media. STFS ( S ecure T ransacted F ile S ystem) is used for game saves, profiles, arcade games, downloadable content and more. STFS is also referred to as CON/LIVE/PIRS files, as they are all STFS files, just signed with a different header. (SFCX S ecure F ile C ache for X box) :is used for cache storage for games. NAND File System is used to store the bootloaders, kernel, keyvault and other files on the NAND . File Formats The Xbox 360 also uses different File Formats for storage of data, as storage on the Xbox is limited, these files are usually binary. XeNTaX.com is a DataBase of hundreds of different file formats, which may be of help. PEC ( P rofile E mbedded C ontent) is used as another layer of security inside profiles. STFS ( S ecure T ransacted F ile S ystem) is used for secure storage of files on memory devices. XDBF / GPD / SPA ( X box D ash b oard F ile/ G amer P rofile D ata/ S tatistics, P resence and A chievements) is used for profiles (achievements/settings/titles) and games (achievements/strings/ratings). XEX ( X enon Ex ecutable) is the executable format used by the Xbox 360. XMI ( X enon M usic I ndex) is used to index music on the Xbox. Category:Xbox360 System Software","title":"Xbox System Software"},{"location":"Xbox_System_Software/#bootloaders","text":"The Xbox 360 system uses a series of bootloaders to load the hv/kernel and dashboard. These loaders are explained at Boot Process .","title":"Bootloaders"},{"location":"Xbox_System_Software/#hypervisor","text":"The Hypervisor is the main operating system being run on the console. It looks after the kernel and stops things like buffer overflows from happening. It also manages a lot of the security aspects of the 360, including memory encryption and region protection. It has code to handle the XeKeys (keyvault + some static ones) and XEXs. The end-user of an Xbox would never have any knowledge of the hypervisor, it's only really interesting for hackers.","title":"Hypervisor"},{"location":"Xbox_System_Software/#kernel","text":"The Xbox 360's Kernel is responsible for low level hardware communication and more. This is the main part of the 360, the kernel is where all the user-based stuff happens. The drivers for accessing most of the hardware is located in the Kernel, along with certain drivers for other things used by the system (e.g. FATX (File Allocation Table for Xbox), STFS (Secure Transacted File System), SFCX (System Flash Controller for Xbox). This is the most interesting part of the console because of all the functions it performs. You can check your kernel version in \"System -> Console Settings -> System Info\". The line at the bottom contains your kernel version in the format K:2.0. nnnnn .0, where nnnnn is your kernel version.","title":"Kernel"},{"location":"Xbox_System_Software/#xam","text":"A lot of fun things are inside XAM. XAM handles gamer profiles and online interactivity, so as you can guess not a lot of information is made public about it. XeDevWiki hopes to change that. XAM handles such things as XDBF ( X box D ata b ase F ile) files ( GPD ( G amer P rogress D ata)/ SPA ) and PEC ( P rofile E mbedded C ontent) files.","title":"XAM"},{"location":"Xbox_System_Software/#file-systems","text":"The Xbox 360 uses various File Systems for storing games, user content and more. FATX ( F ile A llocation T able for X box) is used as the storage filesystem on hard drives/memory units/USB devices/xlaunch.fdf files. GDFX /XSF ( G ame D isc F ormat for X box) is the filesystem used on X360 CD/DVD Media. STFS ( S ecure T ransacted F ile S ystem) is used for game saves, profiles, arcade games, downloadable content and more. STFS is also referred to as CON/LIVE/PIRS files, as they are all STFS files, just signed with a different header. (SFCX S ecure F ile C ache for X box) :is used for cache storage for games. NAND File System is used to store the bootloaders, kernel, keyvault and other files on the NAND .","title":"File Systems"},{"location":"Xbox_System_Software/#file-formats","text":"The Xbox 360 also uses different File Formats for storage of data, as storage on the Xbox is limited, these files are usually binary. XeNTaX.com is a DataBase of hundreds of different file formats, which may be of help. PEC ( P rofile E mbedded C ontent) is used as another layer of security inside profiles. STFS ( S ecure T ransacted F ile S ystem) is used for secure storage of files on memory devices. XDBF / GPD / SPA ( X box D ash b oard F ile/ G amer P rofile D ata/ S tatistics, P resence and A chievements) is used for profiles (achievements/settings/titles) and games (achievements/strings/ratings). XEX ( X enon Ex ecutable) is the executable format used by the Xbox 360. XMI ( X enon M usic I ndex) is used to index music on the Xbox. Category:Xbox360 System Software","title":"File Formats"},{"location":"XeLL/","text":"XeLL is the Xenon Linux Loader. It's a second-stage bootloader which is loaded by a loader . XeLL catches CPU threads, sets them up, loads an ELF file from either network (tftp) or CDROM (ISO9660), and launches it. It's made to boot linux. Thus it also contains a flat device tree for linux. However, it should be able to load other ELF files as well, like apps based on libXenon . lwIP is used for networking. Network config is currently hardcoded in network.c (and main.c), and probably needs to be modified if you want to use it. XeLL is in a very early stage, but is (most of the time) fully working. XeLL is available at https://github.com/Free60Project/xell . There are currently no binary releases of original XeLL. XeLLous is an available modification of XeLL made by Redline99. It support flashing full nand images (updflash.bin) and patchslots for rebooter images (updpatch.bin) and includes a HTTP Server where you can get your CPUKey and DVDKey (if KV is in place) and dump your nand. XeLLous is availabe on xbins. XeLL Reloaded (Codename: 2Stages ) is the recent branch of XeLL. It consists of 2 stages: Stage 1 does the main low level hw init, loads Stage 2 into memory and executes it. Stage 2 is built with libxenon - ensures the latest codebase. For all new features check the README 1 You can get the sourcecode of XeLL Reloaded from Free60 Sourceforge's GIT aswell - branch: 2stages (which is the standard branch) 2 Building and running 0. Make sure that you have a working Cross Compiler toolchain and LibXenon . 1. Grab the sources from the git repository: git clone 2. Compile it using your cross compiler (depending on the name of your cross compiler, you may have to adjust the name after CROSS=): cd xell If you want to build XeLL NON-2stages sourcecode: git checkout master Now compile it make CROSS=powerpc64-unknown-linux-gnu- 3a. Use the JTAG Hack or Reset Glitch Hack - you can even upgrade XeLL via USB. 3b. Deprecated: load xell-readcd.bin using the readcd method and a patched King Kong game. 3c. Deprecated: use the serial loader from Crawler360 to download xell-serial.bin to your Xbox360 and run it. Category:Xbox360_Homebrew_Software\u200f","title":"XeLL"},{"location":"XeLL/#building-and-running","text":"0. Make sure that you have a working Cross Compiler toolchain and LibXenon . 1. Grab the sources from the git repository: git clone 2. Compile it using your cross compiler (depending on the name of your cross compiler, you may have to adjust the name after CROSS=): cd xell If you want to build XeLL NON-2stages sourcecode: git checkout master Now compile it make CROSS=powerpc64-unknown-linux-gnu- 3a. Use the JTAG Hack or Reset Glitch Hack - you can even upgrade XeLL via USB. 3b. Deprecated: load xell-readcd.bin using the readcd method and a patched King Kong game. 3c. Deprecated: use the serial loader from Crawler360 to download xell-serial.bin to your Xbox360 and run it. Category:Xbox360_Homebrew_Software\u200f","title":"Building and running"},{"location":"XeLL_Reloaded/","text":"REDIRECT XeLL Category:Xbox360_Homebrew_Software\u200f","title":"XeLL Reloaded"},{"location":"XeLLous/","text":"REDIRECT XeLL","title":"XeLLous"},{"location":"Xenon/","text":"Xenon is a codename used many times during the Xbox 360's development, and mentions of it can still be found in some 360 files. Xenon may refer to: Xenon , the codename for the Xbox 360 before it was announced. Xenon (Motherboard) , the original Xbox 360 motherboard and case. Xenon (CPU) , the CPU used by the Xbox 360. See also Xenos , the GPU used by the Xbox 360 Category:Xbox360_Hardware","title":"Xenon"},{"location":"Xenon/#see-also","text":"Xenos , the GPU used by the Xbox 360 Category:Xbox360_Hardware","title":"See also"},{"location":"Xenon_%28CPU%29/","text":"Xenon is the CPU that is used in the Xbox 360. The processor, internally codenamed Waternoose by IBM and XCPU by Microsoft. \"The basic design is a 64-bit PowerPC architecture, with the complete PowerPC ISA available .\" It is different from the Intel Pentium III in the original Xbox: the Xenon CPU is composed of three symmetrical cores on a single die, each core has two symmetric hardware threads (SMT), for a total of six hardware threads available to games. Each individual core also includes 32 KiB of L1 instruction cache and 32 KiB of L1 data cache. Specifications The package is a 2-2-2 FC-PBGA, measuring 31mm by 31mm 168 mm2 die size; one cpu core is about 28mm2 Support logic for Array and Logic Built in Selftest 165 Million transistors Three symmetrical cores running at 3.2 GHz each = 9.6Ghz throughput. 32 KiB of L1 instruction cache and 32 KiB of L1 data cache per core 64 bit CPU cores based on the IBM 970 \"G5\" design Each core is two way SMT-capable and clocked at 3.2Ghz 2\u00d7 (128\u00d7128 bit) register files for each core Two hardware threads per core; six hardware threads total VMX-128 vector unit per core; three total 128 VMX-128 registers per hardware thread 1 MB L2 cache (lockable by the GPU) running at half-speed (1.6 GHz) with a 256-bit bus 51.2 gigabytes per second of L2 memory bandwidth (256 bit \u00d7 1600 MHz) 21.6 GB/s front side bus (aggregated 10.8 GB/s upstream and downstream) 115 GFLOPS theoretical peak performance CPU Integer Perf (VPR): 1089 (363 each) Dot product performance: 9.6 billion per second IBM eFuse technology IBM's PowerPC instruction set architecture Restricted to In-order code execution Big endian architecture Linux Support We have full SMP support, so we can use all three cores. However, we currently need to disable the secondary threads because of a yet-to-be analyzed stability issue. The CPU is quite slow on general purpose code. Due to the non out-of-order execution core, it heavily relies on the compiler to do proper optimizations. GCC currently doesn't know how to do this, resulting in running but very inefficient code. The Cell people worked on PPU-GCC, from which the Xenon will benefit as well, as the PPC cores is quite similiar to the Cell's PPU. All PPU-GCC work have been merged on mainline GCC 4.4 External Links Application-customized CPU design: The Microsoft Xbox 360 CPU story Jeffrey Brown, Distinguished Engineer, IBM [\"Power\" Architecture Technology]https://web.archive.org/web/20090213042736/http://www.ibm.com/developerworks/power) at IBM SoC drawer: The resource view at IBM (mentions Xbox CPU design. Gets nitty gritty on resources and scheduling, i/o interconnects, & on chip memory) Just like being there: Papers from the Fall Processor Forum 2005: Application-customized CPU design at IBM (Explore the customized IBM PowerPC processor designed for the Microsoft XBox 360) Xenon hardware overview by Pete Isensee, Development Lead, Xbox Advanced Technology Group, written some time before 23 June 2004 Ars Technica explains the Xenon CPU Xbox360 CPU at Wikipedia PowerPC 970 at Wikipedia PowerPC at Wikipedia POWER4 at Wikipedia CPU Chip for Xbox 360 Manufacturing Overview, FSB, PPC Core, VMX & FPU, & L2 Cache block diagrams from IBM Category:Xbox360_Hardware","title":"Xenon (CPU)"},{"location":"Xenon_%28CPU%29/#specifications","text":"The package is a 2-2-2 FC-PBGA, measuring 31mm by 31mm 168 mm2 die size; one cpu core is about 28mm2 Support logic for Array and Logic Built in Selftest 165 Million transistors Three symmetrical cores running at 3.2 GHz each = 9.6Ghz throughput. 32 KiB of L1 instruction cache and 32 KiB of L1 data cache per core 64 bit CPU cores based on the IBM 970 \"G5\" design Each core is two way SMT-capable and clocked at 3.2Ghz 2\u00d7 (128\u00d7128 bit) register files for each core Two hardware threads per core; six hardware threads total VMX-128 vector unit per core; three total 128 VMX-128 registers per hardware thread 1 MB L2 cache (lockable by the GPU) running at half-speed (1.6 GHz) with a 256-bit bus 51.2 gigabytes per second of L2 memory bandwidth (256 bit \u00d7 1600 MHz) 21.6 GB/s front side bus (aggregated 10.8 GB/s upstream and downstream) 115 GFLOPS theoretical peak performance CPU Integer Perf (VPR): 1089 (363 each) Dot product performance: 9.6 billion per second IBM eFuse technology IBM's PowerPC instruction set architecture Restricted to In-order code execution Big endian architecture","title":"Specifications"},{"location":"Xenon_%28CPU%29/#linux-support","text":"We have full SMP support, so we can use all three cores. However, we currently need to disable the secondary threads because of a yet-to-be analyzed stability issue. The CPU is quite slow on general purpose code. Due to the non out-of-order execution core, it heavily relies on the compiler to do proper optimizations. GCC currently doesn't know how to do this, resulting in running but very inefficient code. The Cell people worked on PPU-GCC, from which the Xenon will benefit as well, as the PPC cores is quite similiar to the Cell's PPU. All PPU-GCC work have been merged on mainline GCC 4.4","title":"Linux Support"},{"location":"Xenon_%28CPU%29/#external-links","text":"Application-customized CPU design: The Microsoft Xbox 360 CPU story Jeffrey Brown, Distinguished Engineer, IBM [\"Power\" Architecture Technology]https://web.archive.org/web/20090213042736/http://www.ibm.com/developerworks/power) at IBM SoC drawer: The resource view at IBM (mentions Xbox CPU design. Gets nitty gritty on resources and scheduling, i/o interconnects, & on chip memory) Just like being there: Papers from the Fall Processor Forum 2005: Application-customized CPU design at IBM (Explore the customized IBM PowerPC processor designed for the Microsoft XBox 360) Xenon hardware overview by Pete Isensee, Development Lead, Xbox Advanced Technology Group, written some time before 23 June 2004 Ars Technica explains the Xenon CPU Xbox360 CPU at Wikipedia PowerPC 970 at Wikipedia PowerPC at Wikipedia POWER4 at Wikipedia CPU Chip for Xbox 360 Manufacturing Overview, FSB, PPC Core, VMX & FPU, & L2 Cache block diagrams from IBM Category:Xbox360_Hardware","title":"External Links"},{"location":"Xenon_%28Motherboard%29/","text":"The original Xbox 360 configuration used in the initial Premium and Core machines released in the end of November 2005. These are also know as the RRoD (Red Ring of Death) machines because the GPU chip warps away from the motherboard because of excessive heat. 90 nm IBM CPU 90 nm ATI GPU and 90nm on-chip eDRAM Low profile GPU cooler Standard CPU cooler 203 Watt output power supply (16.5 A) Shipping with Hitachi and Samsung DVD-Drive Highly unlikely to have glue around the CPU but it IS possible. Category:Xbox360_Hardware","title":"Xenon (Motherboard)"},{"location":"Xenon_Toolchain/","text":"Windows Installing Cygwin Download Cygwin . Once it's done, run the installer. Set the Install Directory to C:\\Cygwin, or what ever your root drive path is. When prompted for a server, select anyone, they all have the same packages, but I would recommend xmission. Make sure you install the necessary devs libs: GCC Make Git build-essential texinfo Etc. Linux Prerequisites libgmp3-dev libmpfr-dev libmpc-dev texinfo git-core build-essential Mac OS X Prerequisites Install Xcode. Install macports, then \"sudo port install mpfr gmp git-core wget\" sudo mkdir /usr/local/xenon; sudo chown -R $USER /usr/local/xenon Do the \"Building the Toolchain\" stuff from below. If you're running Xcode 3.2, get Apple to fix this bug . Workaround is to compile until it fails with the \"duplicate symbol\" error (check build.log), then do the mentioned workaround in gcc-4.4.0/gcc directory (changing Make-lang.in), then disable the rebuild of binutils, gcc (first stage) and newlib by setting BUILD_BINUTILS=false BUILD_GCC=false BUILD_NEWLIB=false BUILD_GCC_SECOND=true in the build-xenon-toolchain. Then retry the build. It should finish the build. Building the Toolchain Run the following commands through the console your using: git clone <git://github.com/Free60Project/libxenon.git> cd libxenon/toolchain ./build-xenon-toolchain toolchain The toolchain should start building (Note: This might take some time). Full process of installation To give people a start who are not used to Linux but want to start coding, here it goes. In this example I am refering to Ubuntu/Debian. First we install dependencies apt-get install libgmp3-dev libmpfr-dev libmpc-dev texinfo git-core gettext build-essential Now we create the target directory for the Toolchain & Libxenon and own it by the current user Note: If your distro has the \"su\" command to get superuser rights, get superuser before typing the commands in the following block. Note: If not, append \"sudo\" before those commands (example: \"sudo mkdir -p /usr/local/xenon\") mkdir -p /usr/local/xenon chown -R your_regular_user:your_regular_user /usr/local/xenon # exit the superuser-environment now! Then we grab the toolchain from git and build it git clone <git://github.com/Free60Project/libxenon.git> cd libxenon/toolchain` ./build-xenon-toolchain toolchain Note: If gcc building, 2nd stage, fails for you, do \"apt-get install libgmp4-dev\" and restart building process. Note for Ubuntu users: If you encounter in the build.log following error: configure: error: Building GCC requires GMP 4.2+, MPFR 2.3.2+ and MPC 0.8.0+. Do the following: cd gcc-4.6.1 wget <ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2> tar xvjf gmp-5.0.2.tar.bz2 && mv gmp-5.0.2 gmp wget <http://www.multiprecision.org/downloads/mpc-0.9.tar.gz> tar xvzf mpc-0.9.tar.gz && mv mpc-0.9 mpc wget <https://www.mpfr.org/mpfr-3.0.1/mpfr-3.0.1.tar.gz> tar xvzf mpfr-3.0.1.tar.gz && mv mpfr-3.0.1 mpfr cd .. ./build-xenon-toolchain toolchain At the end of compiling it will tell you to add paths to your ~/.bashrc - that's an improper solution. Rather do it the following way: # Get superuser rights first! touch /etc/profile.d/devkitxenon.sh chmod +x /etc/profile.d/devkitxenon.sh # Now open the file and insert the two export lines nano /etc/profile.d/devkitxenon.sh # Insert the lines below in the text editor! export DEVKITXENON=\"/usr/local/xenon\" export PATH=\"$PATH:$DEVKITXENON/bin:$DEVKITXENON/usr/bin\" Press Ctrl+O for saving the file and press ENTER if it asks for a filename Press Ctrl+X for closing nano Have fun compiling your code ;) Category:Xbox360_Development","title":"Windows"},{"location":"Xenon_Toolchain/#windows","text":"","title":"Windows"},{"location":"Xenon_Toolchain/#installing-cygwin","text":"Download Cygwin . Once it's done, run the installer. Set the Install Directory to C:\\Cygwin, or what ever your root drive path is. When prompted for a server, select anyone, they all have the same packages, but I would recommend xmission. Make sure you install the necessary devs libs: GCC Make Git build-essential texinfo Etc.","title":"Installing Cygwin"},{"location":"Xenon_Toolchain/#linux","text":"","title":"Linux"},{"location":"Xenon_Toolchain/#prerequisites","text":"libgmp3-dev libmpfr-dev libmpc-dev texinfo git-core build-essential","title":"Prerequisites"},{"location":"Xenon_Toolchain/#mac-os-x","text":"","title":"Mac OS X"},{"location":"Xenon_Toolchain/#prerequisites_1","text":"Install Xcode. Install macports, then \"sudo port install mpfr gmp git-core wget\" sudo mkdir /usr/local/xenon; sudo chown -R $USER /usr/local/xenon Do the \"Building the Toolchain\" stuff from below. If you're running Xcode 3.2, get Apple to fix this bug . Workaround is to compile until it fails with the \"duplicate symbol\" error (check build.log), then do the mentioned workaround in gcc-4.4.0/gcc directory (changing Make-lang.in), then disable the rebuild of binutils, gcc (first stage) and newlib by setting BUILD_BINUTILS=false BUILD_GCC=false BUILD_NEWLIB=false BUILD_GCC_SECOND=true in the build-xenon-toolchain. Then retry the build. It should finish the build.","title":"Prerequisites"},{"location":"Xenon_Toolchain/#building-the-toolchain","text":"Run the following commands through the console your using: git clone <git://github.com/Free60Project/libxenon.git> cd libxenon/toolchain ./build-xenon-toolchain toolchain The toolchain should start building (Note: This might take some time).","title":"Building the Toolchain"},{"location":"Xenon_Toolchain/#full-process-of-installation","text":"To give people a start who are not used to Linux but want to start coding, here it goes. In this example I am refering to Ubuntu/Debian. First we install dependencies apt-get install libgmp3-dev libmpfr-dev libmpc-dev texinfo git-core gettext build-essential Now we create the target directory for the Toolchain & Libxenon and own it by the current user Note: If your distro has the \"su\" command to get superuser rights, get superuser before typing the commands in the following block. Note: If not, append \"sudo\" before those commands (example: \"sudo mkdir -p /usr/local/xenon\") mkdir -p /usr/local/xenon chown -R your_regular_user:your_regular_user /usr/local/xenon # exit the superuser-environment now! Then we grab the toolchain from git and build it git clone <git://github.com/Free60Project/libxenon.git> cd libxenon/toolchain` ./build-xenon-toolchain toolchain Note: If gcc building, 2nd stage, fails for you, do \"apt-get install libgmp4-dev\" and restart building process. Note for Ubuntu users: If you encounter in the build.log following error: configure: error: Building GCC requires GMP 4.2+, MPFR 2.3.2+ and MPC 0.8.0+. Do the following: cd gcc-4.6.1 wget <ftp://ftp.gmplib.org/pub/gmp-5.0.2/gmp-5.0.2.tar.bz2> tar xvjf gmp-5.0.2.tar.bz2 && mv gmp-5.0.2 gmp wget <http://www.multiprecision.org/downloads/mpc-0.9.tar.gz> tar xvzf mpc-0.9.tar.gz && mv mpc-0.9 mpc wget <https://www.mpfr.org/mpfr-3.0.1/mpfr-3.0.1.tar.gz> tar xvzf mpfr-3.0.1.tar.gz && mv mpfr-3.0.1 mpfr cd .. ./build-xenon-toolchain toolchain At the end of compiling it will tell you to add paths to your ~/.bashrc - that's an improper solution. Rather do it the following way: # Get superuser rights first! touch /etc/profile.d/devkitxenon.sh chmod +x /etc/profile.d/devkitxenon.sh # Now open the file and insert the two export lines nano /etc/profile.d/devkitxenon.sh # Insert the lines below in the text editor! export DEVKITXENON=\"/usr/local/xenon\" export PATH=\"$PATH:$DEVKITXENON/bin:$DEVKITXENON/usr/bin\" Press Ctrl+O for saving the file and press ENTER if it asks for a filename Press Ctrl+X for closing nano Have fun compiling your code ;) Category:Xbox360_Development","title":"Full process of installation"},{"location":"Xenos/","text":"REDIRECT Xenos (GPU)","title":"Xenos"},{"location":"Xenos_%28GPU%29/","text":"Xenos is a custom graphics processing unit (GPU) designed by ATI, used in the Xbox 360. Developed under the codename \"C1,\" it is in many ways related to the R500 desktop PC graphics card series and therefore very similar to an ATI Radeon X1900 as far as features and performance are concerned. However, the Xenos introduced many new design ideas that were later adopted in the R600 series. The package contains two separate silicon dies, the GPU and an eDRAM, featuring a total of 337 million transistors. For infos about Xenos Framebuffer/Xenosfb click HERE and for infos about modesetting HERE Specifications 325 Million transistors (235m Parent Die / 90m Daughter Die) (Other specs say 337 million total) GPU & Northbridge (Northbridge on Parent Die) Two-die design, with two chips in a single package on a single substrate Parent die contains the GPU and memory controller Daughter die consists of the 10MB of eDRAM & additional logic (FSAA, Alpha, ZLogic & Stencil) 2GHz link between the parent and daughter die 500MHz processor 10 MB of embedded DRAM (By NEC) 48-way parallel floating-point dynamically scheduled shader pipelines 4 ALU's per pipe for Vertex or Pixel Shader processing Unified shader architecture (Beyond Shader Model 3.0) Three SIMD engines with 16 processors per unit (The 48 shader pipeline) 16 Filtered & 16 unfiltered texture samples per clock HDR Rendering DirectX 9 Limited support for DirectX 10 Handles all scaling of video (resolution). Linux Support Currently, we have support for the framebuffer console. We also have an unaccelerated X driver. We don't yet have support for acceleration, neither 2D nor 3D, but there is on going work. 1 Rudimentary video mode setup code exists in XeLL and the Linux framebuffer driver. There are though problems with interlaced modes. Framebuffer Code Unfortunately, the framebuffer memory is not linear (i.e. pixels are not stored one after another, line after line). The memory is organized in tiles of 32x32 pixels, where in each tile blocks of 4x1 pixels are scattered around. Every pixel is stored as a 32 bit RGBx tuple. The tiling breaks most framebuffer applications which require linear access, causing heavily distorted pictures. This could maybe be fixed by writing custom blit routines in xenos_fb. Are there any apps using the framebuffer blit functions, or is everybody mmap()ing? -- Ge0rG 15:03, 21 Jan 2008 (PST) External Links ATI Xenos: Xbox 360 Graphics Demystified at Beyond3D AMD R6xx R7xx 3D at Xorg.com R700 Instruction Set Arch at developer.amd.com Category:Xbox360_Hardware","title":"Xenos (GPU)"},{"location":"Xenos_%28GPU%29/#specifications","text":"325 Million transistors (235m Parent Die / 90m Daughter Die) (Other specs say 337 million total) GPU & Northbridge (Northbridge on Parent Die) Two-die design, with two chips in a single package on a single substrate Parent die contains the GPU and memory controller Daughter die consists of the 10MB of eDRAM & additional logic (FSAA, Alpha, ZLogic & Stencil) 2GHz link between the parent and daughter die 500MHz processor 10 MB of embedded DRAM (By NEC) 48-way parallel floating-point dynamically scheduled shader pipelines 4 ALU's per pipe for Vertex or Pixel Shader processing Unified shader architecture (Beyond Shader Model 3.0) Three SIMD engines with 16 processors per unit (The 48 shader pipeline) 16 Filtered & 16 unfiltered texture samples per clock HDR Rendering DirectX 9 Limited support for DirectX 10 Handles all scaling of video (resolution).","title":"Specifications"},{"location":"Xenos_%28GPU%29/#linux-support","text":"Currently, we have support for the framebuffer console. We also have an unaccelerated X driver. We don't yet have support for acceleration, neither 2D nor 3D, but there is on going work. 1 Rudimentary video mode setup code exists in XeLL and the Linux framebuffer driver. There are though problems with interlaced modes.","title":"Linux Support"},{"location":"Xenos_%28GPU%29/#framebuffer-code","text":"Unfortunately, the framebuffer memory is not linear (i.e. pixels are not stored one after another, line after line). The memory is organized in tiles of 32x32 pixels, where in each tile blocks of 4x1 pixels are scattered around. Every pixel is stored as a 32 bit RGBx tuple. The tiling breaks most framebuffer applications which require linear access, causing heavily distorted pictures. This could maybe be fixed by writing custom blit routines in xenos_fb. Are there any apps using the framebuffer blit functions, or is everybody mmap()ing? -- Ge0rG 15:03, 21 Jan 2008 (PST)","title":"Framebuffer Code"},{"location":"Xenos_%28GPU%29/#external-links","text":"ATI Xenos: Xbox 360 Graphics Demystified at Beyond3D AMD R6xx R7xx 3D at Xorg.com R700 Instruction Set Arch at developer.amd.com Category:Xbox360_Hardware","title":"External Links"},{"location":"Xenos_Framebuffer/","text":"Xenosfb - Framebuffer Device Driver for Xbox 360 Xenos graphics chipset This X.org device driver supports the Xenos graphics chipset as it is built into the Microsoft Xbox 360 gaming console. It is based on the X.org fbdev generic framebuffer device driver. Thus, it relies on the fbdevhw driver as well as a working frambuffer device within /dev. This driver is in a very early stage and does only support graphics access through the framebuffer kernel device. No 2D or 3D acceleration is supported and changing resolution at runtime does not work. Currently the screen resolution is inherited from the settings in the Xbox 360 Dashboard. Please note that all hardware information that was used to develop this driver has been gained solely by reverse engineering and trial and error. No official documentation or SDK has been used. Compiling It has following dependencies: libtool m4 automake autoconf pkg-config xorg-dev xutils-dev x11-xserver-utils x11proto-randr-dev libxrandr-dev Probably some of these packages contain each other. Extract the sourcecode and make sure autogen.sh has the executable flag set. Start the compiling process by executing ./autogen.sh After successful Compiling you will find the driver-module in *builddir*/src/.libs/xenosfb_drv.so Copy it to /usr/lib/xorg/modules/drivers/ Also make sure /etc/X11/xorg.conf holds at least the following: Section \"Device\" Identifier \"Generic Video Card\" Driver \"xenosfb\" Option \"UseFBDev\" \"true\" EndSection Category:Xbox360_Development Category:Xbox360_Linux","title":"Xenos Framebuffer"},{"location":"Xenos_Framebuffer/#compiling","text":"It has following dependencies: libtool m4 automake autoconf pkg-config xorg-dev xutils-dev x11-xserver-utils x11proto-randr-dev libxrandr-dev Probably some of these packages contain each other. Extract the sourcecode and make sure autogen.sh has the executable flag set. Start the compiling process by executing ./autogen.sh After successful Compiling you will find the driver-module in *builddir*/src/.libs/xenosfb_drv.so Copy it to /usr/lib/xorg/modules/drivers/ Also make sure /etc/X11/xorg.conf holds at least the following: Section \"Device\" Identifier \"Generic Video Card\" Driver \"xenosfb\" Option \"UseFBDev\" \"true\" EndSection Category:Xbox360_Development Category:Xbox360_Linux","title":"Compiling"},{"location":"ZLX_Browser/","text":"General Info NFO The browser is built with the [[ZLX_Library|ZLX Library]] and is included with it. Category:Xbox360_Homebrew_Software\u200f","title":"ZLX Browser"},{"location":"ZLX_Browser/#general-info","text":"","title":"General Info"},{"location":"ZLX_Browser/#nfo","text":"The browser is built with the [[ZLX_Library|ZLX Library]] and is included with it. Category:Xbox360_Homebrew_Software\u200f","title":"NFO"},{"location":"Zephyr/","text":"Zephyr was the second revision of the Xbox 360 motherboard and case and was originally exclusively available only with Elite consoles. Zephyr was the first Xbox 360 motherboard revision to have HDMI. Performing the SMC Hack requires a slightly different set of connections to Xenon motherboards. Consoles: Arcade, Pro/Premium 20GB, Elite 120GB, and Halo 3 Console 90nm IBM CPU & ATI GPU 90nm eDRAM 203 Watt PSU (16.5 A) HDMI video output Updated motherboard layout Glue around the CPU in some cases 3 pin fan connector New Extended GPU heat sink with a heat pipe New Elite model includes 120GB hard drive Shipping with Hitachi 78 or 79 and BenQ DVD-Drive. May also have Lite-On drive if it was refurbished. Category:Xbox360_Hardware","title":"Zephyr"}]}