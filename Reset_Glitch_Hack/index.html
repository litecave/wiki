
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.2.2, mkdocs-material-7.2.4">
    
    
      
        <title>The Xbox 360 reset glitch hack - Free60 Wiki archive</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/main.f7f47774.min.css">
      
        
        <link rel="stylesheet" href="../assets/stylesheets/palette.3f5d1f46.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
    
      


    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#the-xbox-360-reset-glitch-hack" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href=".." title="Free60 Wiki archive" class="md-header__button md-logo" aria-label="Free60 Wiki archive" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Free60 Wiki archive
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              The Xbox 360 reset glitch hack
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href=".." title="Free60 Wiki archive" class="md-nav__button md-logo" aria-label="Free60 Wiki archive" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54z"/></svg>

    </a>
    Free60 Wiki archive
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href=".." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Xbox360_Hardware/" class="md-nav__link">
        Hardware
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Xbox360_System_Software/" class="md-nav__link">
        System Software
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Xbox360_Homebrew_Software/" class="md-nav__link">
        Homebrew Software
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Xbox360_Linux/" class="md-nav__link">
        Linux
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Xbox360_Development/" class="md-nav__link">
        Development
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../Category_Support/" class="md-nav__link">
        Support
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../%21TODO/" class="md-nav__link">
        ToDo
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#the-reset-glitch-in-a-few-words" class="md-nav__link">
    The reset glitch in a few words
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#details-for-the-fat-hack" class="md-nav__link">
    Details for the fat hack
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#details-for-the-slim-hack" class="md-nav__link">
    Details for the slim hack
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#caveats" class="md-nav__link">
    Caveats
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#our-current-implementation" class="md-nav__link">
    Our current implementation
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#finding-the-right-timing" class="md-nav__link">
    Finding the right timing
  </a>
  
    <nav class="md-nav" aria-label="Finding the right timing">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#getting-memcmp-post-length-in-ticks" class="md-nav__link">
    Getting memcmp POST length in ticks
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using-random-timing-over-the-full-post-length" class="md-nav__link">
    Using random timing over the full POST length
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#refining-the-timing-accounting-for-bell-like-curve" class="md-nav__link">
    Refining the timing, accounting for bell-like curve
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#conclusion" class="md-nav__link">
    Conclusion
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="the-xbox-360-reset-glitch-hack">The Xbox 360 reset glitch hack</h1>
<p>tmbinc said it himself, software based approaches of running unsigned
code on the 360 mostly don't work, it was designed to be secure from a
software point of view.</p>
<p>The processor starts running code from ROM (1bl) , which then starts
loading a RSA signed and RC4 crypted piece of code from NAND (CB).</p>
<p>CB then initialises the processor security engine, its task will be to
do real time encryption and hash check of physical DRAM memory. From
what we found, it's using AES128 for crypto and strong (Toeplitz ?)
hashing. The crypto is different each boot because it is seeded at least
from:</p>
<ul>
<li>A hash of the entire fuseset.</li>
<li>The timebase counter value.</li>
<li>A truly random value that comes from the hardware random number
    generator the processor embeds. on fats, that RNG could be
    electronically deactivated, but there's a check for "apparent
    randomness" (merely a count of 1 bits) in CB, it just waits for a
    seemingly proper random number.</li>
</ul>
<p>CB can then run some kind of simple bytecode based software engine whose
task will mainly be to initialise DRAM, CB can then load the next
bootloader (CD) from NAND into it, and run it.</p>
<p>Basically, CD will load a base kernel from NAND, patch it and run it.</p>
<p>That kernel contains a small privileged piece of code (hypervisor), when
the console runs, this is the only code that would have enough rights to
run unsigned code. In kernel versions 4532/4548, a critical flaw in it
appeared, and all known 360 hacks needed to run one of those kernels and
exploit that flaw to run unsigned code. On current 360s, CD contains a
hash of those 2 kernels and will stop the boot process if you try to
load them. The hypervisor is a relatively small piece of code to check
for flaws and apparently no newer ones has any flaws that could allow
running unsigned code.</p>
<p>On the other hand, tmbinc said the 360 wasn't designed to withstand
certain hardware attacks such as the timing attack and "glitching".</p>
<p>Glitching here is basically the process of triggering processor bugs by
electronical means.</p>
<p>This is the way we used to be able to run unsigned code.</p>
<h2 id="the-reset-glitch-in-a-few-words">The reset glitch in a few words</h2>
<p>We found that by sending a tiny reset pulse to the processor while it is
slowed down does not reset it but instead changes the way the code runs,
it seems it's very efficient at making bootloaders memcmp functions
always return "no differences". memcmp is often used to check the next
bootloader SHA hash against a stored one, allowing it to run if they are
the same. So we can put a bootloader that would fail hash check in NAND,
glitch the previous one and that bootloader will run, allowing almost
any code to run.</p>
<h2 id="details-for-the-fat-hack">Details for the fat hack</h2>
<p>On fats, the bootloader we glitch is CB, so we can run the CD we want.</p>
<p>cjak found that by asserting the CPU_PLL_BYPASS signal, the CPU clock
is slowed down a lot, there's a test point on the motherboard that's a
fraction of CPU speed, it's 200Mhz when the dash runs, 66.6Mhz when the
console boots, and 520Khz when that signal is asserted.</p>
<p>So it goes like that:</p>
<ul>
<li>We assert CPU_PLL_BYPASS around POST code 36 (hex).</li>
<li>We wait for POST 39 start (POST 39 is the memcmp between stored hash
    and image hash), and start a counter.</li>
<li>When that counter has reached a precise value (it's often around 62%
    of entire POST 39 length), we send a 100ns pulse on CPU_RESET.</li>
<li>We wait some time and then we deassert CPU_PLL_BYPASS.</li>
<li>The cpu speed goes back to normal, and with a bit of luck, instead
    of getting POST error AD, the boot process continues and CB runs our
    custom CD.</li>
</ul>
<p>The NAND contains a zero-paired CB, our payload in a custom CD, and a
modified SMC image. A glitch being unreliable by nature, we use a
modified SMC image that reboots infinitely (ie stock images reboot 5
times and then go RROD) until the console has booted properly. In most
cases, the glitch succeeds in less than 30 seconds from power on that
way.</p>
<h2 id="details-for-the-slim-hack">Details for the slim hack</h2>
<p>The bootloader we glitch is CB_A, so we can run the CB_B we want.</p>
<p>On slims, we weren't able to find a motherboard track for
CPU_PLL_BYPASS. Our first idea was to remove the 27Mhz master 360
crystal and generate our own clock instead but it was a difficult
modification and it didn't yield good results. We then looked for other
ways to slow the CPU clock down and found that the HANA chip had
configurable PLL registers for the 100Mhz clock that feeds CPU and GPU
differential pairs. Apparently those registers are written by the SMC
through an I2C bus. I2C bus can be freely accessed, it's even available
on a header (J2C3). So the HANA chip will now become our weapon of
choice to slow the CPU down (sorry tmbinc, you can't always be right, it
isn't boring and it does sit on an interesting bus ;)</p>
<p>So it goes like that:</p>
<ul>
<li>We send an i2c command to the HANA to slow down the CPU at POST code
    D8 .</li>
<li>We wait for POST DA start (POST DA is the memcmp between stored hash
    and image hash), and start a counter.</li>
<li>When that counter has reached a precise value, we send a 20ns pulse
    on CPU_RESET.</li>
<li>We wait some time and then we send an i2c command to the HANA to
    restore regular CPU clock.</li>
<li>The cpu speed goes back to normal, and with a bit of luck, instead
    of getting POST error F2, the boot process continues and CB_A runs
    our custom CB_B.</li>
</ul>
<p>When CB_B starts, DRAM isn't initialised so we chose to only apply a
few patches to it so that it can run any CD, the patches are:</p>
<ul>
<li>Always activate zero-paired mode, so that we can use a modified SMC
    image.</li>
<li>Don't decrypt CD, instead expect a plaintext CD in NAND.</li>
<li>Don't stop the boot process if CD hash isn't good.</li>
</ul>
<p>CB_B is RC4 crypted, the key comes from the CPU key, so how do we patch
CB_B without knowing the CPU key? RC4 is basically:</p>
<ul>
<li>crypted = plaintext xor pseudo-random-keystream</li>
</ul>
<p>So if we know plaintext and crypted, we can get the keystream, and with
the keystream, we can encrypt our own code. It goes like that:</p>
<ul>
<li>guessed-pseudo-random-keystream = crypted xor plaintext</li>
<li>new-crypted = guessed-pseudo-random-keystream xor plaintext-patch</li>
</ul>
<p>You could think there's a chicken and egg problem, how did we get
plaintext in the first place? Easy: we had plaintext CBs from fat
consoles, and we thought the first few bytes of code would be the same
as the new CB_B, so we could encrypt a tiny piece of code to dump the
CPU key and decrypt CB_B!</p>
<p>The NAND contains CB_A, a patched CB_B, our payload in a custom
plaintext CD, and a modified SMC image. The SMC image is modified to
have infinite reboot, and to prevent it from periodically sending I2C
commands while we send ours.</p>
<p>Now, maybe you haven't realised yet, but CB_A contains no checks on
revocation fuses, so it's an unpatchable hack !</p>
<h2 id="caveats">Caveats</h2>
<p>Nothing is ever perfect, so there are a few caveats to that hack:</p>
<ul>
<li>Even in the glitch we found is pretty reliable (25% success rate per
    try on average), it can take up to a few minutes to boot to unsigned
    code.</li>
<li>That success rate seems to depend on something like the hash of the
    modified bootloader we want to run (CD for fats and CB_B for
    slims).</li>
<li>It requires precise and fast hardware to be able to send the reset
    pulse.</li>
</ul>
<h2 id="our-current-implementation">Our current implementation</h2>
<p>We used a Xilinx CoolRunner II CPLD (xc2c64a) board, because it's fast,
precise, updatable, cheap and can work with 2 different voltage levels
at the same time. We use the 48Mhz standby clock from the 360 for the
glitch counter. For the slim hack, the counter even runs at 96Mhz
(incremented on rising and falling edges of clock) The cpld code is
written in VHDL. We need it to be aware of the current POST code, our
first implementations used the whole 8 bits POST port for this, but we
are now able to detect the changes of only 1 POST bit, making wiring
easier.</p>
<h2 id="finding-the-right-timing">Finding the right timing</h2>
<h3 id="getting-memcmp-post-length-in-ticks">Getting memcmp POST length in ticks</h3>
<p>First step is to know how long the memcmp POST will last while slowed
down. No reset pulse should be sent for this. Using hardware that can
read the POST bus and measure time in a precise way, measure the time
between memcmp POST start and 'hash compare failed' final POST (eg on
fats, between POST 39 and POST AD) with the next bootloader failing hash
check.</p>
<p>An ARM7 based Olimex LPC-H2148 was used for this task.</p>
<p>It could look like that:</p>
<p><code>for(;;)</code>
<code>{</code>
<code>post = post_read();</code>
<code>if (post == prev_post) then continue;</code></p>
<p><code>if(post == MEMCMP_POST)</code>
<code>{</code>
<code>t_start = get_tick();</code></p>
<p><code>while( post_read() == MEMCMP_POST );</code>
<code></code>
<code>memcmp_post_length=get_tick()-t_start;</code></p>
<p><code>print(memcmp_post_length);</code>
<code>}</code></p>
<p><code>prev_post=post;</code>
<code>}</code></p>
<p>Make sure you note memcmp post length ;)</p>
<h3 id="using-random-timing-over-the-full-post-length">Using random timing over the full POST length</h3>
<p>Now you need the hardware to send a reset pulse after a random amount of
time in memcmp POST, but no more than previously found memcmp POST
length.</p>
<p>It could look like that:</p>
<p><code>for(;;)</code>
<code>{</code>
<code>post = read_post();</code>
<code>if (post == prev_post) then continue;</code></p>
<p><code>if(post == MEMCMP_POST)</code>
<code>{</code>
<code>t_start = get_tick();</code>
<code>t_rand = rand() % MEMCMP_POST_LENGTH;</code></p>
<p><code>while( get_tick()&lt; t_start+t_rand );</code></p>
<p><code>ppc_send_reset_pulse();</code></p>
<p><code>print(t_rand);</code>
<code>}</code></p>
<p><code>prev_post=post;</code>
<code>}</code></p>
<p>Using a hacked smc that reboots infinitely it will take a good amount of
time, but it should end up glitching properly.</p>
<p>Make sure you note the timing that glitched ;)</p>
<h3 id="refining-the-timing-accounting-for-bell-like-curve">Refining the timing, accounting for bell-like curve</h3>
<p>So now we have one timing that glitches, but we don't know if it's
really the 'sweet spot' or if we were just lucky. What needs to be done
now is to get the timing of some more successes, I think it's safe to
use a smaller random range around previously found glitch timing. my
get_tick() function runs at 60Mhz, I found it was safe to make the
range -+50 ticks around previously found glitch timing</p>
<p>It could look like that:</p>
<p><code>for(;;)</code>
<code>{</code>
<code>post = read_post();</code>
<code>if (post == prev_post) then continue;</code></p>
<p><code>if(post == MEMCMP_POST)</code>
<code>{</code>
<code>t_start = get_tick();</code>
<code>t_rand = PREV_GLITCH_TIMING - 50 + (rand() % 100);</code></p>
<p><code>while( get_tick()&lt; t_start+t_rand );</code></p>
<p><code>ppc_send_reset_pulse();</code></p>
<p><code>print(t_rand);</code>
<code>}</code></p>
<p><code>prev_post=post;</code>
<code>}</code></p>
<p>You'll need the timing of at least 20-30 successes. Averaging those
timings should give you the sweet spot (aka final timing), because
empirically we found that success rate vs timing is a bell-like curve.</p>
<p>Make sure ... you got it ;)</p>
<p>PS: Those pseudo-code examples don't show the slowdown code for the sake
of clarity.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We tried not to include any MS copyrighted code in the released hack
tools. The purpose of this hack is to run Xell and other free software,
I (GliGli) did NOT do it to promote piracy or anything related, I just
want to be able to do whatever I want with the hardware I bought,
including running my own native code on it.</p>
<h1 id="howto-for-slims">HowTo (for slims)</h1>
<h2 id="required-software-and-hardware">Required Software and Hardware</h2>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>Installed Xilinx Lab Tools</li>
</ul>
<h3 id="software">Software</h3>
<ul>
<li>Python and Pyton Crypto</li>
<li>Impact (from Xilinx Lab Tools)</li>
<li>NandPro (>= v2.0e)</li>
</ul>
<h3 id="hardware">Hardware</h3>
<ul>
<li>USB SPI Programmer to dump/flash the Xbox360's NAND</li>
<li>XC2C64A CoolRunner-II CPLD (aka Digilent C-mod)</li>
<li>Socket for the CPLD</li>
<li>XilinX JTAG Programmer cable</li>
<li>1x 220pF capacitor</li>
<li>Soldering material</li>
</ul>
<h2 id="dumping-nand">Dumping NAND</h2>
<ul>
<li>Use the following diagram to solder your <strong>USB SPI Programmer</strong> to
    the Xbo360
motherboard.</li>
</ul>
<p><img alt="XBOX360_Slim_NandPro_LPCH2148_PIC18F2455_Diagram.png" src="XBOX360_Slim_NandPro_LPCH2148_PIC18F2455_Diagram.png" title="XBOX360_Slim_NandPro_LPCH2148_PIC18F2455_Diagram.png" /></p>
<ul>
<li>Open windows' command prompt and launch <strong>NandPro</strong>.</li>
</ul>
<!-- end list -->

<ul>
<li>Dump your nand twice by using the read command for 16MB NAND :</li>
</ul>
<p><code>nandpro usb : -r16 nanddumpname.bin</code></p>
<ul>
<li>Compare the two dumps with the following command (you canuse MD5
    Checksums too) :</li>
</ul>
<p><code>fc /b  nanddumpname.bin nanddumpname2.bin</code></p>
<p><img alt="H-Slim6.png" src="H-Slim6.png" title="H-Slim6.png" /></p>
<p>You should see something like <strong>FC : No difference found</strong>. If the two
dumps don't match, do a new dump and check again.</p>
<h2 id="installation-of-python-and-python-crypto">Installation of Python and Python Crypto</h2>
<ul>
<li>Install <strong>Python 2.7 (32bit!)</strong> with the default settings :</li>
</ul>
<p><img alt="H-Slim7.png" src="H-Slim7.png" title="H-Slim7.png" /> <img alt="H-Slim8.png" src="H-Slim8.png" title="H-Slim8.png" /> <img alt="H-Slim9.png" src="H-Slim9.png" title="H-Slim9.png" />
<img alt="H-Slim10.png" src="H-Slim10.png" title="H-Slim10.png" /></p>
<ul>
<li>Install <strong>PyCrypto 2.3</strong> with the default settings :</li>
</ul>
<p><img alt="H-Slim11.png" src="H-Slim11.png" title="H-Slim11.png" />
<img alt="H-Slim12.png" src="H-Slim12.png" title="H-Slim12.png" />
<img alt="H-Slim13.png" src="H-Slim13.png" title="H-Slim13.png" /></p>
<p>To enable python in windows' command prompt, we will have to modify the
environment variables .</p>
<ul>
<li>Go in <strong>Control Panel > System > Advanced system settings</strong></li>
</ul>
<p><img alt="H-Slim14.png" src="H-Slim14.png" title="H-Slim14.png" /></p>
<ul>
<li>Click on environnement variables</li>
</ul>
<p><img alt="H-Slim15.png" src="H-Slim15.png" title="H-Slim15.png" /></p>
<ul>
<li>Click on <strong>new</strong> in system variable</li>
</ul>
<p><img alt="H-Slim16.png" src="H-Slim16.png" title="H-Slim16.png" /></p>
<ul>
<li>Add this for the name and the value of the variable :</li>
</ul>
<p><code>PYTHONPATH</code>
<code>%PYTHONPATH%;C:\Python2.7 ;</code></p>
<p><img alt="H-Slim17.png" src="H-Slim17.png" title="H-Slim17.png" /></p>
<h2 id="creating-the-hackimage">Creating the Hackimage</h2>
<ul>
<li><strong>Download the gggggg-hack</strong> (Free60-Git Repository).</li>
</ul>
<!-- end list -->

<ul>
<li>Put your original NAND dump in the root of the gggggg-folder and
    create an create a folder named "<strong>ouput</strong>" (in the root aswell).</li>
</ul>
<p><img alt="H-Slim18.png" src="H-Slim18.png" title="H-Slim18.png" /></p>
<ul>
<li>Open windows' command prompt again and <strong>navigate to the
    gggggg-folder</strong>, then type this python command (don't forget to
    modify it with your NAND dump name)
:</li>
</ul>
<p><code>python common\imgbuild\build.py nanddumpname.bin common\cdxell\CD common\xell\xell-gggggg.bin</code></p>
<p><img alt="H-Slim19.png" src="H-Slim19.png" title="H-Slim19.png" /></p>
<p>You should see the following</p>
<p><img alt="H-Slim20.png" src="H-Slim20.png" title="H-Slim20.png" /></p>
<p>The file <strong>image_00000000.ecc</strong> is located in the output folder now.</p>
<p><img alt="H-Slim21.png" src="H-Slim21.png" title="H-Slim21.png" /></p>
<ul>
<li><strong>Copy this file into your nandpro folder</strong> and navigate to the
    folder via commandprompt again</li>
</ul>
<!-- end list -->

<ul>
<li>Use the following command to <strong>flash the image</strong> to your console's
    NAND.</li>
</ul>
<p><code>nandpro usb : +w16 image_00000000.ecc</code></p>
<p>/!\ Pay attention that you have to use the <strong>+w16</strong> switch and not the
-w16 one /!\</p>
<p><img alt="H-Slim22.png" src="H-Slim22.png" title="H-Slim22.png" /></p>
<p>The flashed file has a size of 50 blocks so you should see 004F when the
flashing is done.</p>
<h2 id="programming-the-cpld">Programming the CPLD</h2>
<p><strong>Power your CPLD with 3.3V on pin 20 and GND on pin 21</strong>. There are
many solution to do this ... here are some of them :</p>
<ul>
<li>Use an old DVD drive supply cable by cutting 5 and 6 cable (3.3V and
    GND) and connect it to the a CK or the motherboard drive socket
    <strong>OR</strong> Solder the pin 20 to the J2C1.8 point of the motherboard and
    pin 21 (GND) to a point of the motherboard like the legs of the
    various connector-metalcasing.</li>
</ul>
<p><img alt="H-Slim23.gif" src="H-Slim23.gif" title="H-Slim23.gif" />
<img alt="H-Slim24.png" src="H-Slim24.png" title="H-Slim24.png" /></p>
<ul>
<li>Grab your LPT/USB XilinX JTAG programmer cable. <strong>Connect the cable
    to the PC and the CPLD</strong>.</li>
</ul>
<p>(If you don't have one, you can use GliGli's schematic to build a LPT
JTAG Programmer)</p>
<p><img alt="H-Slim25.png" src="H-Slim25.png" title="H-Slim25.png" />
<img alt="H-Slim26.png" src="H-Slim26.png" title="H-Slim26.png" /></p>
<ul>
<li><strong>Launch "iMPACT"</strong> (from XilinX Lab Tools) and let's start the
    programming ... just follow the images.</li>
</ul>
<p>(You have to setup the compatibility mode only if your Programmer does
not get detected right away)</p>
<p><img alt="H-Slim27.png" src="H-Slim27.png" title="H-Slim27.png" />
<img alt="H-Slim28.png" src="H-Slim28.png" title="H-Slim28.png" />
<img alt="H-Slim29.png" src="H-Slim29.png" title="H-Slim29.png" />
<img alt="H-Slim30.png" src="H-Slim30.png" title="H-Slim30.png" />
<img alt="H-Slim31.png" src="H-Slim31.png" title="H-Slim31.png" />
<img alt="H-Slim32.png" src="H-Slim32.png" title="H-Slim32.png" />
<img alt="H-Slim33.png" src="H-Slim33.png" title="H-Slim33.png" />
<img alt="H-Slim34.png" src="H-Slim34.png" title="H-Slim34.png" />
<img alt="H-Slim35.png" src="H-Slim35.png" title="H-Slim35.png" />
<img alt="H-Slim36.png" src="H-Slim36.png" title="H-Slim36.png" />
<img alt="H-Slim37.png" src="H-Slim37.png" title="H-Slim37.png" /></p>
<h2 id="wiring">Wiring</h2>
<ul>
<li>On the CPLD, <strong>remove the Resistor R2 and connect R2's upper pad to
    R1's lower pad</strong>.</li>
</ul>
<p><img alt="H-Slim38.png" src="H-Slim38.png" title="H-Slim38.png" />
<img alt="H-Slim39.png" src="H-Slim39.png" title="H-Slim39.png" /></p>
<ul>
<li>Place the CPLD on the motherboard like you see on the picture. We
    <strong>recommend to use double coated tape + material to isolate the
    CPLD</strong>.</li>
</ul>
<p><img alt="H-Slim40.png" src="H-Slim40.png" title="H-Slim40.png" /></p>
<ul>
<li>Use the following diagram to solder all needed connections. <strong>It's
    recommended to use a socket!</strong></li>
</ul>
<p><img alt="H-Slim41.png" src="H-Slim41.png" title="H-Slim41.png" />
<img alt="H-Slim42.png" src="H-Slim42.png" title="H-Slim42.png" />
<img alt="H-Slim43.png" src="H-Slim43.png" title="H-Slim43.png" />
<img alt="H-Slim44.png" src="H-Slim44.png" title="H-Slim44.png" />
<img alt="H-Slim45.png" src="H-Slim45.png" title="H-Slim45.png" /></p>
<h2 id="enjoy">ENJOY</h2>
<ul>
<li>You can now start your console normally and see XeLL boot within 2
    minutes. You can now <strong>enjoy unsigned code on your slim</strong>.</li>
</ul>
<p><img alt="H-Slim46.png" src="H-Slim46.png" title="H-Slim46.png" /></p>
<h2 id="credits-thanks">CREDITS / THANKS</h2>
<p>GliGli, Tiros: Reverse engineering and hack development. cOz: Reverse
engineering, beta testing. Razkar, tuxuser, Ced2911: beta testing. cjak,
Redline99, SeventhSon, tmbinc, anyone I forgot... : Prior reverse
engineering and/or hacking work on the 360.</p>
<p><a href="Category_Xbox360_System_Software">Category:Xbox360 System Software</a>
<a href="Category_Xbox360_Hardware">Category:Xbox360_Hardware</a></p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing", "select.version.title": "Select version"}, "search": "../assets/javascripts/workers/search.709b4209.min.js", "version": null}</script>
    
    
      <script src="../assets/javascripts/bundle.febc23d1.min.js"></script>
      
    
  </body>
</html>